/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };

        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };

        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::core::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __IncompleteArrayField<T> {}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const _NEWLIB_VERSION_H__: i32 = 1;
pub const _NEWLIB_VERSION: &'static [u8; 6usize] = b"3.1.0\0";
pub const __NEWLIB__: i32 = 3;
pub const __NEWLIB_MINOR__: i32 = 1;
pub const __NEWLIB_PATCHLEVEL__: i32 = 0;
pub const _DEFAULT_SOURCE: i32 = 1;
pub const _POSIX_SOURCE: i32 = 1;
pub const _POSIX_C_SOURCE: i32 = 200809;
pub const _ATFILE_SOURCE: i32 = 1;
pub const __ATFILE_VISIBLE: i32 = 1;
pub const __BSD_VISIBLE: i32 = 1;
pub const __GNU_VISIBLE: i32 = 0;
pub const __ISO_C_VISIBLE: i32 = 2011;
pub const __LARGEFILE_VISIBLE: i32 = 0;
pub const __MISC_VISIBLE: i32 = 1;
pub const __POSIX_VISIBLE: i32 = 200809;
pub const __SVID_VISIBLE: i32 = 1;
pub const __XSI_VISIBLE: i32 = 0;
pub const __SSP_FORTIFY_LEVEL: i32 = 0;
pub const __have_longlong64: i32 = 1;
pub const __have_long32: i32 = 1;
pub const ___int8_t_defined: i32 = 1;
pub const ___int16_t_defined: i32 = 1;
pub const ___int32_t_defined: i32 = 1;
pub const ___int64_t_defined: i32 = 1;
pub const ___int_least8_t_defined: i32 = 1;
pub const ___int_least16_t_defined: i32 = 1;
pub const ___int_least32_t_defined: i32 = 1;
pub const ___int_least64_t_defined: i32 = 1;
pub const __int20: i32 = 2;
pub const __INT8: &'static [u8; 3usize] = b"hh\0";
pub const __INT16: &'static [u8; 2usize] = b"h\0";
pub const __INT64: &'static [u8; 3usize] = b"ll\0";
pub const __FAST8: &'static [u8; 3usize] = b"hh\0";
pub const __FAST16: &'static [u8; 2usize] = b"h\0";
pub const __FAST64: &'static [u8; 3usize] = b"ll\0";
pub const __LEAST8: &'static [u8; 3usize] = b"hh\0";
pub const __LEAST16: &'static [u8; 2usize] = b"h\0";
pub const __LEAST64: &'static [u8; 3usize] = b"ll\0";
pub const __int8_t_defined: i32 = 1;
pub const __int16_t_defined: i32 = 1;
pub const __int32_t_defined: i32 = 1;
pub const __int64_t_defined: i32 = 1;
pub const __int_least8_t_defined: i32 = 1;
pub const __int_least16_t_defined: i32 = 1;
pub const __int_least32_t_defined: i32 = 1;
pub const __int_least64_t_defined: i32 = 1;
pub const __int_fast8_t_defined: i32 = 1;
pub const __int_fast16_t_defined: i32 = 1;
pub const __int_fast32_t_defined: i32 = 1;
pub const __int_fast64_t_defined: i32 = 1;
pub const WINT_MIN: i32 = 0;
pub const true_: i32 = 1;
pub const false_: i32 = 0;
pub const __bool_true_false_are_defined: i32 = 1;
pub const __alignas_is_defined: i32 = 1;
pub const __alignof_is_defined: i32 = 1;
pub const NROHEADER_MAGIC: i32 = 810504782;
pub const NROASSETHEADER_MAGIC: i32 = 1413829441;
pub const NROASSETHEADER_VERSION: i32 = 0;
pub const CUR_PROCESS_HANDLE: u32 = 4294934529;
pub const CUR_THREAD_HANDLE: u32 = 4294934528;
pub const MAX_WAIT_OBJECTS: i32 = 64;
pub const __NEWLIB_H__: i32 = 1;
pub const _WANT_IO_C99_FORMATS: i32 = 1;
pub const _WANT_IO_LONG_LONG: i32 = 1;
pub const _WANT_IO_POS_ARGS: i32 = 1;
pub const _MB_CAPABLE: i32 = 1;
pub const _MB_LEN_MAX: i32 = 8;
pub const HAVE_INITFINI_ARRAY: i32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: i32 = 1;
pub const _HAVE_LONG_DOUBLE: i32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: i32 = 1;
pub const _FVWRITE_IN_STREAMIO: i32 = 1;
pub const _FSEEK_OPTIMIZATION: i32 = 1;
pub const _UNBUF_STREAM_OPT: i32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: i32 = 1;
pub const __OBSOLETE_MATH: i32 = 1;
pub const __RAND_MAX: u32 = 2147483647;
pub const SFCI_MAGIC: i32 = 1229145683;
pub const SFCO_MAGIC: i32 = 1329808979;
pub const IPC_MAX_BUFFERS: i32 = 8;
pub const IPC_MAX_OBJECTS: i32 = 8;
pub const FS_MAX_PATH: i32 = 769;
pub const FS_SAVEDATA_CURRENT_TITLEID: i32 = 0;
pub const FS_SAVEDATA_USERID_COMMONSAVE: i32 = 0;
pub const ACC_USER_LIST_SIZE: i32 = 8;
pub const AUDREN_TIMER_FREQ_HZ: f64 = 200.0;
pub const AUDREN_TIMER_PERIOD_MS: f64 = 5.0;
pub const AUDREN_SAMPLES_PER_FRAME_32KHZ: i32 = 160;
pub const AUDREN_SAMPLES_PER_FRAME_48KHZ: i32 = 240;
pub const AUDREN_INPUT_PARAM_ALIGNMENT: i32 = 4096;
pub const AUDREN_OUTPUT_PARAM_ALIGNMENT: i32 = 16;
pub const AUDREN_MEMPOOL_ALIGNMENT: i32 = 4096;
pub const AUDREN_BUFFER_ALIGNMENT: i32 = 64;
pub const AUDREN_REVISION_1: i32 = 827737426;
pub const AUDREN_REVISION_2: i32 = 844514642;
pub const AUDREN_REVISION_3: i32 = 861291858;
pub const AUDREN_REVISION_4: i32 = 878069074;
pub const AUDREN_REVISION_5: i32 = 894846290;
pub const AUDREN_REVISION_6: i32 = 911623506;
pub const AUDREN_FINAL_MIX_ID: i32 = 0;
pub const AUDREN_UNUSED_MIX_ID: u32 = 2147483647;
pub const AUDREN_UNUSED_SPLITTER_ID: u32 = 4294967295;
pub const AUDREN_DEFAULT_DEVICE_NAME: &'static [u8; 13usize] = b"MainAudioOut\0";
pub const USB_DT_INTERFACE_SIZE: i32 = 9;
pub const USB_DT_ENDPOINT_SIZE: i32 = 7;
pub const USB_DT_DEVICE_SIZE: i32 = 18;
pub const USB_DT_SS_ENDPOINT_COMPANION_SIZE: i32 = 6;
pub const USB_ENDPOINT_ADDRESS_MASK: i32 = 15;
pub const USB_ENDPOINT_DIR_MASK: i32 = 128;
pub const USB_TRANSFER_TYPE_MASK: i32 = 3;
pub const USBDS_DEFAULT_InterfaceNumber: i32 = 4;
pub const JOYSTICK_MAX: i32 = 32768;
pub const JOYSTICK_MIN: i32 = -32768;
pub const SET_MAX_NAME_SIZE: i32 = 72;
pub const SPL_RSA_BUFFER_SIZE: i32 = 256;
pub const BINDER_FIRST_CALL_TRANSACTION: i32 = 1;
pub const PARCEL_MAX_PAYLOAD: i32 = 1024;
pub const _NV_IOC_NRBITS: i32 = 8;
pub const _NV_IOC_TYPEBITS: i32 = 8;
pub const _NV_IOC_SIZEBITS: i32 = 14;
pub const _NV_IOC_DIRBITS: i32 = 2;
pub const _NV_IOC_NRMASK: i32 = 255;
pub const _NV_IOC_TYPEMASK: i32 = 255;
pub const _NV_IOC_SIZEMASK: i32 = 16383;
pub const _NV_IOC_DIRMASK: i32 = 3;
pub const _NV_IOC_NRSHIFT: i32 = 0;
pub const _NV_IOC_TYPESHIFT: i32 = 8;
pub const _NV_IOC_SIZESHIFT: i32 = 16;
pub const _NV_IOC_DIRSHIFT: i32 = 30;
pub const _NV_IOC_NONE: i32 = 0;
pub const _NV_IOC_WRITE: i32 = 1;
pub const _NV_IOC_READ: i32 = 2;
pub const GPFIFO_QUEUE_SIZE: i32 = 2048;
pub const NXLINK_SERVER_PORT: i32 = 28280;
pub const NXLINK_CLIENT_PORT: i32 = 28771;
pub const __GNUCLIKE_ASM: i32 = 3;
pub const __GNUCLIKE___TYPEOF: i32 = 1;
pub const __GNUCLIKE___OFFSETOF: i32 = 1;
pub const __GNUCLIKE___SECTION: i32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: i32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: i32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: i32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: i32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: i32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: i32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: i32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: i32 = 1;
pub const __CC_SUPPORTS_INLINE: i32 = 1;
pub const __CC_SUPPORTS___INLINE: i32 = 1;
pub const __CC_SUPPORTS___INLINE__: i32 = 1;
pub const __CC_SUPPORTS___FUNC__: i32 = 1;
pub const __CC_SUPPORTS_WARNING: i32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: i32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: i32 = 1;
pub const __BIT_TYPES_DEFINED__: i32 = 1;
pub const _LITTLE_ENDIAN: i32 = 1234;
pub const _BIG_ENDIAN: i32 = 4321;
pub const _PDP_ENDIAN: i32 = 3412;
pub const _BYTE_ORDER: i32 = 1234;
pub const _QUAD_HIGHWORD: i32 = 1;
pub const _QUAD_LOWWORD: i32 = 0;
pub const LITTLE_ENDIAN: i32 = 1234;
pub const BIG_ENDIAN: i32 = 4321;
pub const PDP_ENDIAN: i32 = 3412;
pub const BYTE_ORDER: i32 = 1234;
pub const FD_SETSIZE: i32 = 64;
pub const SCHED_OTHER: i32 = 0;
pub const SCHED_FIFO: i32 = 1;
pub const SCHED_RR: i32 = 2;
pub const PTHREAD_SCOPE_PROCESS: i32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: i32 = 1;
pub const PTHREAD_INHERIT_SCHED: i32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: i32 = 2;
pub const PTHREAD_CREATE_DETACHED: i32 = 0;
pub const PTHREAD_CREATE_JOINABLE: i32 = 1;
pub const CONSOLE_COLOR_BOLD: i32 = 1;
pub const CONSOLE_COLOR_FAINT: i32 = 2;
pub const CONSOLE_ITALIC: i32 = 4;
pub const CONSOLE_UNDERLINE: i32 = 8;
pub const CONSOLE_BLINK_SLOW: i32 = 16;
pub const CONSOLE_BLINK_FAST: i32 = 32;
pub const CONSOLE_COLOR_REVERSE: i32 = 64;
pub const CONSOLE_CONCEAL: i32 = 128;
pub const CONSOLE_CROSSED_OUT: i32 = 256;
pub const FSDEV_DIRITER_MAGIC: i32 = 1718838390;
pub const AES_BLOCK_SIZE: i32 = 16;
pub const AES_128_KEY_SIZE: i32 = 16;
pub const AES_128_NUM_ROUNDS: i32 = 10;
pub const AES_192_KEY_SIZE: i32 = 24;
pub const AES_192_NUM_ROUNDS: i32 = 12;
pub const AES_256_KEY_SIZE: i32 = 32;
pub const AES_256_NUM_ROUNDS: i32 = 14;
pub const SHA256_HASH_SIZE: i32 = 32;
pub const SHA256_BLOCK_SIZE: i32 = 64;
pub const SHA1_HASH_SIZE: i32 = 20;
pub const SHA1_BLOCK_SIZE: i32 = 64;
pub type __int8_t = ctypes::c_schar;
pub type __uint8_t = ctypes::c_uchar;
pub type __int16_t = ctypes::c_short;
pub type __uint16_t = ctypes::c_ushort;
pub type __int32_t = ctypes::c_int;
pub type __uint32_t = ctypes::c_uint;
pub type __int64_t = ctypes::c_longlong;
pub type __uint64_t = ctypes::c_ulonglong;
pub type __int_least8_t = ctypes::c_schar;
pub type __uint_least8_t = ctypes::c_uchar;
pub type __int_least16_t = ctypes::c_short;
pub type __uint_least16_t = ctypes::c_ushort;
pub type __int_least32_t = ctypes::c_int;
pub type __uint_least32_t = ctypes::c_uint;
pub type __int_least64_t = ctypes::c_longlong;
pub type __uint_least64_t = ctypes::c_ulonglong;
pub type __intmax_t = ctypes::c_longlong;
pub type __uintmax_t = ctypes::c_ulonglong;
pub type __intptr_t = ctypes::c_longlong;
pub type __uintptr_t = ctypes::c_ulonglong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ctypes::c_schar;
pub type uint_fast8_t = ctypes::c_uchar;
pub type int_fast16_t = ctypes::c_short;
pub type uint_fast16_t = ctypes::c_ushort;
pub type int_fast32_t = ctypes::c_int;
pub type uint_fast32_t = ctypes::c_uint;
pub type int_fast64_t = ctypes::c_longlong;
pub type uint_fast64_t = ctypes::c_ulonglong;
pub type wchar_t = ctypes::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ctypes::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type u128 = __uint128_t;
pub type s8 = i8;
pub type s16 = i16;
pub type s32 = i32;
pub type s64 = i64;
pub type s128 = __int128_t;
pub type vu8 = u8;
pub type vu16 = u16;
pub type vu32 = u32;
pub type vu64 = u64;
pub type vu128 = u128;
pub type vs8 = s8;
pub type vs16 = s16;
pub type vs32 = s32;
pub type vs64 = s64;
pub type vs128 = s128;
pub type Handle = u32;
pub type Result = u32;
pub type ThreadFunc = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ctypes::c_void)>;
pub type VoidFn = ::core::option::Option<unsafe extern "C" fn()>;
pub const Module_Kernel: _bindgen_ty_1 = 1;
pub const Module_Libnx: _bindgen_ty_1 = 345;
pub const Module_HomebrewAbi: _bindgen_ty_1 = 346;
pub const Module_HomebrewLoader: _bindgen_ty_1 = 347;
pub const Module_LibnxNvidia: _bindgen_ty_1 = 348;
pub const Module_LibnxBinder: _bindgen_ty_1 = 349;
/// Module values
pub type _bindgen_ty_1 = u32;
pub const KernelError_OutOfSessions: _bindgen_ty_2 = 7;
pub const KernelError_InvalidCapabilityDescriptor: _bindgen_ty_2 = 14;
pub const KernelError_NotImplemented: _bindgen_ty_2 = 33;
pub const KernelError_ThreadTerminating: _bindgen_ty_2 = 59;
pub const KernelError_OutOfDebugEvents: _bindgen_ty_2 = 70;
pub const KernelError_InvalidSize: _bindgen_ty_2 = 101;
pub const KernelError_InvalidAddress: _bindgen_ty_2 = 102;
pub const KernelError_ResourceExhausted: _bindgen_ty_2 = 103;
pub const KernelError_OutOfMemory: _bindgen_ty_2 = 104;
pub const KernelError_OutOfHandles: _bindgen_ty_2 = 105;
pub const KernelError_InvalidMemoryState: _bindgen_ty_2 = 106;
pub const KernelError_InvalidMemoryPermissions: _bindgen_ty_2 = 108;
pub const KernelError_InvalidMemoryRange: _bindgen_ty_2 = 110;
pub const KernelError_InvalidPriority: _bindgen_ty_2 = 112;
pub const KernelError_InvalidCoreId: _bindgen_ty_2 = 113;
pub const KernelError_InvalidHandle: _bindgen_ty_2 = 114;
pub const KernelError_InvalidUserBuffer: _bindgen_ty_2 = 115;
pub const KernelError_InvalidCombination: _bindgen_ty_2 = 116;
pub const KernelError_TimedOut: _bindgen_ty_2 = 117;
pub const KernelError_Cancelled: _bindgen_ty_2 = 118;
pub const KernelError_OutOfRange: _bindgen_ty_2 = 119;
pub const KernelError_InvalidEnumValue: _bindgen_ty_2 = 120;
pub const KernelError_NotFound: _bindgen_ty_2 = 121;
pub const KernelError_AlreadyExists: _bindgen_ty_2 = 122;
pub const KernelError_ConnectionClosed: _bindgen_ty_2 = 123;
pub const KernelError_UnhandledUserInterrupt: _bindgen_ty_2 = 124;
pub const KernelError_InvalidState: _bindgen_ty_2 = 125;
pub const KernelError_ReservedValue: _bindgen_ty_2 = 126;
pub const KernelError_InvalidHwBreakpoint: _bindgen_ty_2 = 127;
pub const KernelError_FatalUserException: _bindgen_ty_2 = 128;
pub const KernelError_OwnedByAnotherProcess: _bindgen_ty_2 = 129;
pub const KernelError_ConnectionRefused: _bindgen_ty_2 = 131;
pub const KernelError_OutOfResource: _bindgen_ty_2 = 132;
pub const KernelError_IpcMapFailed: _bindgen_ty_2 = 259;
pub const KernelError_IpcCmdbufTooSmall: _bindgen_ty_2 = 260;
pub const KernelError_NotDebugged: _bindgen_ty_2 = 520;
/// Kernel error codes
pub type _bindgen_ty_2 = u32;
pub const LibnxError_BadReloc: _bindgen_ty_3 = 1;
pub const LibnxError_OutOfMemory: _bindgen_ty_3 = 2;
pub const LibnxError_AlreadyMapped: _bindgen_ty_3 = 3;
pub const LibnxError_BadGetInfo_Stack: _bindgen_ty_3 = 4;
pub const LibnxError_BadGetInfo_Heap: _bindgen_ty_3 = 5;
pub const LibnxError_BadQueryMemory: _bindgen_ty_3 = 6;
pub const LibnxError_AlreadyInitialized: _bindgen_ty_3 = 7;
pub const LibnxError_NotInitialized: _bindgen_ty_3 = 8;
pub const LibnxError_NotFound: _bindgen_ty_3 = 9;
pub const LibnxError_IoError: _bindgen_ty_3 = 10;
pub const LibnxError_BadInput: _bindgen_ty_3 = 11;
pub const LibnxError_BadReent: _bindgen_ty_3 = 12;
pub const LibnxError_BufferProducerError: _bindgen_ty_3 = 13;
pub const LibnxError_HandleTooEarly: _bindgen_ty_3 = 14;
pub const LibnxError_HeapAllocFailed: _bindgen_ty_3 = 15;
pub const LibnxError_TooManyOverrides: _bindgen_ty_3 = 16;
pub const LibnxError_ParcelError: _bindgen_ty_3 = 17;
pub const LibnxError_BadGfxInit: _bindgen_ty_3 = 18;
pub const LibnxError_BadGfxEventWait: _bindgen_ty_3 = 19;
pub const LibnxError_BadGfxQueueBuffer: _bindgen_ty_3 = 20;
pub const LibnxError_BadGfxDequeueBuffer: _bindgen_ty_3 = 21;
pub const LibnxError_AppletCmdidNotFound: _bindgen_ty_3 = 22;
pub const LibnxError_BadAppletReceiveMessage: _bindgen_ty_3 = 23;
pub const LibnxError_BadAppletNotifyRunning: _bindgen_ty_3 = 24;
pub const LibnxError_BadAppletGetCurrentFocusState: _bindgen_ty_3 = 25;
pub const LibnxError_BadAppletGetOperationMode: _bindgen_ty_3 = 26;
pub const LibnxError_BadAppletGetPerformanceMode: _bindgen_ty_3 = 27;
pub const LibnxError_BadUsbCommsRead: _bindgen_ty_3 = 28;
pub const LibnxError_BadUsbCommsWrite: _bindgen_ty_3 = 29;
pub const LibnxError_InitFail_SM: _bindgen_ty_3 = 30;
pub const LibnxError_InitFail_AM: _bindgen_ty_3 = 31;
pub const LibnxError_InitFail_HID: _bindgen_ty_3 = 32;
pub const LibnxError_InitFail_FS: _bindgen_ty_3 = 33;
pub const LibnxError_BadGetInfo_Rng: _bindgen_ty_3 = 34;
pub const LibnxError_JitUnavailable: _bindgen_ty_3 = 35;
pub const LibnxError_WeirdKernel: _bindgen_ty_3 = 36;
pub const LibnxError_IncompatSysVer: _bindgen_ty_3 = 37;
pub const LibnxError_InitFail_Time: _bindgen_ty_3 = 38;
pub const LibnxError_TooManyDevOpTabs: _bindgen_ty_3 = 39;
pub const LibnxError_DomainMessageUnknownType: _bindgen_ty_3 = 40;
pub const LibnxError_DomainMessageTooManyObjectIds: _bindgen_ty_3 = 41;
pub const LibnxError_AppletFailedToInitialize: _bindgen_ty_3 = 42;
pub const LibnxError_ApmFailedToInitialize: _bindgen_ty_3 = 43;
pub const LibnxError_NvinfoFailedToInitialize: _bindgen_ty_3 = 44;
pub const LibnxError_NvbufFailedToInitialize: _bindgen_ty_3 = 45;
pub const LibnxError_LibAppletBadExit: _bindgen_ty_3 = 46;
/// libnx error codes
pub type _bindgen_ty_3 = u32;
pub const LibnxBinderError_Unknown: _bindgen_ty_4 = 1;
pub const LibnxBinderError_NoMemory: _bindgen_ty_4 = 2;
pub const LibnxBinderError_InvalidOperation: _bindgen_ty_4 = 3;
pub const LibnxBinderError_BadValue: _bindgen_ty_4 = 4;
pub const LibnxBinderError_BadType: _bindgen_ty_4 = 5;
pub const LibnxBinderError_NameNotFound: _bindgen_ty_4 = 6;
pub const LibnxBinderError_PermissionDenied: _bindgen_ty_4 = 7;
pub const LibnxBinderError_NoInit: _bindgen_ty_4 = 8;
pub const LibnxBinderError_AlreadyExists: _bindgen_ty_4 = 9;
pub const LibnxBinderError_DeadObject: _bindgen_ty_4 = 10;
pub const LibnxBinderError_FailedTransaction: _bindgen_ty_4 = 11;
pub const LibnxBinderError_BadIndex: _bindgen_ty_4 = 12;
pub const LibnxBinderError_NotEnoughData: _bindgen_ty_4 = 13;
pub const LibnxBinderError_WouldBlock: _bindgen_ty_4 = 14;
pub const LibnxBinderError_TimedOut: _bindgen_ty_4 = 15;
pub const LibnxBinderError_UnknownTransaction: _bindgen_ty_4 = 16;
pub const LibnxBinderError_FdsNotAllowed: _bindgen_ty_4 = 17;
/// libnx binder error codes
pub type _bindgen_ty_4 = u32;
pub const LibnxNvidiaError_Unknown: _bindgen_ty_5 = 1;
/// < Maps to Nvidia: 1
pub const LibnxNvidiaError_NotImplemented: _bindgen_ty_5 = 2;
/// < Maps to Nvidia: 2
pub const LibnxNvidiaError_NotSupported: _bindgen_ty_5 = 3;
/// < Maps to Nvidia: 3
pub const LibnxNvidiaError_NotInitialized: _bindgen_ty_5 = 4;
/// < Maps to Nvidia: 4
pub const LibnxNvidiaError_BadParameter: _bindgen_ty_5 = 5;
/// < Maps to Nvidia: 5
pub const LibnxNvidiaError_Timeout: _bindgen_ty_5 = 6;
/// < Maps to Nvidia: 6
pub const LibnxNvidiaError_InsufficientMemory: _bindgen_ty_5 = 7;
/// < Maps to Nvidia: 7
pub const LibnxNvidiaError_ReadOnlyAttribute: _bindgen_ty_5 = 8;
/// < Maps to Nvidia: 8
pub const LibnxNvidiaError_InvalidState: _bindgen_ty_5 = 9;
/// < Maps to Nvidia: 9
pub const LibnxNvidiaError_InvalidAddress: _bindgen_ty_5 = 10;
/// < Maps to Nvidia: 10
pub const LibnxNvidiaError_InvalidSize: _bindgen_ty_5 = 11;
/// < Maps to Nvidia: 11
pub const LibnxNvidiaError_BadValue: _bindgen_ty_5 = 12;
/// < Maps to Nvidia: 13
pub const LibnxNvidiaError_AlreadyAllocated: _bindgen_ty_5 = 13;
/// < Maps to Nvidia: 14
pub const LibnxNvidiaError_Busy: _bindgen_ty_5 = 14;
/// < Maps to Nvidia: 15
pub const LibnxNvidiaError_ResourceError: _bindgen_ty_5 = 15;
/// < Maps to Nvidia: 16
pub const LibnxNvidiaError_CountMismatch: _bindgen_ty_5 = 16;
/// < Maps to Nvidia: 0x1000
pub const LibnxNvidiaError_SharedMemoryTooSmall: _bindgen_ty_5 = 17;
/// < Maps to Nvidia: 0x30003
pub const LibnxNvidiaError_FileOperationFailed: _bindgen_ty_5 = 18;
/// < Maps to Nvidia: 0x3000F
pub const LibnxNvidiaError_IoctlFailed: _bindgen_ty_5 = 19;
/// libnx nvidia error codes
pub type _bindgen_ty_5 = u32;
/// Entry for each segment in the codebin.
#[repr(C)]
pub struct NroSegment {
    pub file_off: u32,
    pub size: u32,
}
#[test]
fn bindgen_test_layout_NroSegment() {
    assert_eq!(
        ::core::mem::size_of::<NroSegment>(),
        8usize,
        concat!("Size of: ", stringify!(NroSegment))
    );
    assert_eq!(
        ::core::mem::align_of::<NroSegment>(),
        4usize,
        concat!("Alignment of ", stringify!(NroSegment))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroSegment>())).file_off as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NroSegment),
            "::",
            stringify!(file_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroSegment>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NroSegment),
            "::",
            stringify!(size)
        )
    );
}
/// Offset 0x0 in the NRO.
#[repr(C)]
pub struct NroStart {
    pub unused: u32,
    pub mod_offset: u32,
    pub padding: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_NroStart() {
    assert_eq!(
        ::core::mem::size_of::<NroStart>(),
        16usize,
        concat!("Size of: ", stringify!(NroStart))
    );
    assert_eq!(
        ::core::mem::align_of::<NroStart>(),
        4usize,
        concat!("Alignment of ", stringify!(NroStart))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroStart>())).unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NroStart),
            "::",
            stringify!(unused)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroStart>())).mod_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NroStart),
            "::",
            stringify!(mod_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroStart>())).padding as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NroStart),
            "::",
            stringify!(padding)
        )
    );
}
/// This follows NroStart, the actual nro-header.
#[repr(C)]
pub struct NroHeader {
    pub magic: u32,
    pub unk1: u32,
    pub size: u32,
    pub unk2: u32,
    pub segments: [NroSegment; 3usize],
    pub bss_size: u32,
    pub unk3: u32,
    pub build_id: [u8; 32usize],
    pub padding: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_NroHeader() {
    assert_eq!(
        ::core::mem::size_of::<NroHeader>(),
        112usize,
        concat!("Size of: ", stringify!(NroHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<NroHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(NroHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroHeader>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NroHeader),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroHeader>())).unk1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NroHeader),
            "::",
            stringify!(unk1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroHeader>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NroHeader),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroHeader>())).unk2 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NroHeader),
            "::",
            stringify!(unk2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroHeader>())).segments as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NroHeader),
            "::",
            stringify!(segments)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroHeader>())).bss_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NroHeader),
            "::",
            stringify!(bss_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroHeader>())).unk3 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(NroHeader),
            "::",
            stringify!(unk3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroHeader>())).build_id as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NroHeader),
            "::",
            stringify!(build_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroHeader>())).padding as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(NroHeader),
            "::",
            stringify!(padding)
        )
    );
}
/// Custom asset section.
#[repr(C)]
pub struct NroAssetSection {
    pub offset: u64,
    pub size: u64,
}
#[test]
fn bindgen_test_layout_NroAssetSection() {
    assert_eq!(
        ::core::mem::size_of::<NroAssetSection>(),
        16usize,
        concat!("Size of: ", stringify!(NroAssetSection))
    );
    assert_eq!(
        ::core::mem::align_of::<NroAssetSection>(),
        8usize,
        concat!("Alignment of ", stringify!(NroAssetSection))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroAssetSection>())).offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NroAssetSection),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroAssetSection>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NroAssetSection),
            "::",
            stringify!(size)
        )
    );
}
/// Custom asset header.
#[repr(C)]
pub struct NroAssetHeader {
    pub magic: u32,
    pub version: u32,
    pub icon: NroAssetSection,
    pub nacp: NroAssetSection,
    pub romfs: NroAssetSection,
}
#[test]
fn bindgen_test_layout_NroAssetHeader() {
    assert_eq!(
        ::core::mem::size_of::<NroAssetHeader>(),
        56usize,
        concat!("Size of: ", stringify!(NroAssetHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<NroAssetHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(NroAssetHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroAssetHeader>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NroAssetHeader),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroAssetHeader>())).version as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NroAssetHeader),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroAssetHeader>())).icon as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NroAssetHeader),
            "::",
            stringify!(icon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroAssetHeader>())).nacp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NroAssetHeader),
            "::",
            stringify!(nacp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroAssetHeader>())).romfs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NroAssetHeader),
            "::",
            stringify!(romfs)
        )
    );
}
/// Language entry. These strings are UTF-8.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NacpLanguageEntry {
    pub name: [ctypes::c_char; 512usize],
    pub author: [ctypes::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_NacpLanguageEntry() {
    assert_eq!(
        ::core::mem::size_of::<NacpLanguageEntry>(),
        768usize,
        concat!("Size of: ", stringify!(NacpLanguageEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<NacpLanguageEntry>(),
        1usize,
        concat!("Alignment of ", stringify!(NacpLanguageEntry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpLanguageEntry>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpLanguageEntry),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpLanguageEntry>())).author as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpLanguageEntry),
            "::",
            stringify!(author)
        )
    );
}
#[repr(C)]
pub struct NacpStruct {
    pub lang: [NacpLanguageEntry; 16usize],
    pub x3000_unk: [u8; 36usize],
    /// Normally all-zero?
    pub x3024_unk: u32,
    pub x3028_unk: u32,
    pub x302C_unk: u32,
    pub x3030_unk: u32,
    pub x3034_unk: u32,
    pub titleID0: u64,
    pub x3040_unk: [u8; 32usize],
    pub version: [ctypes::c_char; 16usize],
    pub titleID_DlcBase: u64,
    pub titleID1: u64,
    pub x3080_unk: u32,
    pub x3084_unk: u32,
    pub x3088_unk: u32,
    pub x308C_unk: [u8; 36usize],
    pub titleID2: u64,
    pub titleIDs: [u64; 7usize],
    pub x30F0_unk: u32,
    pub x30F4_unk: u32,
    pub titleID3: u64,
    pub bcatPassphrase: [ctypes::c_char; 64usize],
    pub x3140_unk: [u8; 3776usize],
}
#[test]
fn bindgen_test_layout_NacpStruct() {
    assert_eq!(
        ::core::mem::size_of::<NacpStruct>(),
        16384usize,
        concat!("Size of: ", stringify!(NacpStruct))
    );
    assert_eq!(
        ::core::mem::align_of::<NacpStruct>(),
        8usize,
        concat!("Alignment of ", stringify!(NacpStruct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).lang as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(lang)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x3000_unk as *const _ as usize },
        12288usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x3000_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x3024_unk as *const _ as usize },
        12324usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x3024_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x3028_unk as *const _ as usize },
        12328usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x3028_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x302C_unk as *const _ as usize },
        12332usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x302C_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x3030_unk as *const _ as usize },
        12336usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x3030_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x3034_unk as *const _ as usize },
        12340usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x3034_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).titleID0 as *const _ as usize },
        12344usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(titleID0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x3040_unk as *const _ as usize },
        12352usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x3040_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).version as *const _ as usize },
        12384usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).titleID_DlcBase as *const _ as usize },
        12400usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(titleID_DlcBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).titleID1 as *const _ as usize },
        12408usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(titleID1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x3080_unk as *const _ as usize },
        12416usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x3080_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x3084_unk as *const _ as usize },
        12420usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x3084_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x3088_unk as *const _ as usize },
        12424usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x3088_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x308C_unk as *const _ as usize },
        12428usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x308C_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).titleID2 as *const _ as usize },
        12464usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(titleID2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).titleIDs as *const _ as usize },
        12472usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(titleIDs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x30F0_unk as *const _ as usize },
        12528usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x30F0_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x30F4_unk as *const _ as usize },
        12532usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x30F4_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).titleID3 as *const _ as usize },
        12536usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(titleID3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).bcatPassphrase as *const _ as usize },
        12544usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(bcatPassphrase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x3140_unk as *const _ as usize },
        12608usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x3140_unk)
        )
    );
}
extern "C" {
    /// Get the NacpLanguageEntry from the input nacp corresponding to the current system language (this may fallback to other languages when needed). Output langentry is NULL if none found / content of entry is empty.
    pub fn nacpGetLanguageEntry(
        nacp: *mut NacpStruct,
        langentry: *mut *mut NacpLanguageEntry,
    ) -> Result;
}
extern "C" {
    /// @brief Performs a data cache flush on the specified buffer.
    /// @param addr Address of the buffer.
    /// @param size Size of the buffer, in bytes.
    /// @remarks Cache flush is defined as Clean + Invalidate.
    /// @note The start and end addresses of the buffer are forcibly rounded to cache line boundaries (read from CTR_EL0 system register).
    pub fn armDCacheFlush(addr: *mut ctypes::c_void, size: usize);
}
extern "C" {
    /// @brief Performs a data cache clean on the specified buffer.
    /// @param addr Address of the buffer.
    /// @param size Size of the buffer, in bytes.
    /// @note The start and end addresses of the buffer are forcibly rounded to cache line boundaries (read from CTR_EL0 system register).
    pub fn armDCacheClean(addr: *mut ctypes::c_void, size: usize);
}
extern "C" {
    /// @brief Performs an instruction cache invalidation clean on the specified buffer.
    /// @param addr Address of the buffer.
    /// @param size Size of the buffer, in bytes.
    /// @note The start and end addresses of the buffer are forcibly rounded to cache line boundaries (read from CTR_EL0 system register).
    pub fn armICacheInvalidate(addr: *mut ctypes::c_void, size: usize);
}
extern "C" {
    /// @brief Performs a data cache zeroing operation on the specified buffer.
    /// @param addr Address of the buffer.
    /// @param size Size of the buffer, in bytes.
    /// @note The start and end addresses of the buffer are forcibly rounded to cache line boundaries (read from CTR_EL0 system register).
    pub fn armDCacheZero(addr: *mut ctypes::c_void, size: usize);
}
/// Armv8 CPU register.
#[repr(C)]
pub union CpuRegister {
    /// < 64-bit AArch64 register view.
    pub x: u64,
    /// < 32-bit AArch64 register view.
    pub w: u32,
    /// < AArch32 register view.
    pub r: u32,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_CpuRegister() {
    assert_eq!(
        ::core::mem::size_of::<CpuRegister>(),
        8usize,
        concat!("Size of: ", stringify!(CpuRegister))
    );
    assert_eq!(
        ::core::mem::align_of::<CpuRegister>(),
        8usize,
        concat!("Alignment of ", stringify!(CpuRegister))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CpuRegister>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuRegister),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CpuRegister>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuRegister),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CpuRegister>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuRegister),
            "::",
            stringify!(r)
        )
    );
}
/// Armv8 NEON register.
#[repr(C)]
#[derive(Copy, Clone)]
pub union FpuRegister {
    /// < 128-bit vector view.
    pub v: u128,
    /// < 64-bit double-precision view.
    pub d: f64,
    /// < 32-bit single-precision view.
    pub s: f32,
    _bindgen_union_align: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_FpuRegister() {
    assert_eq!(
        ::core::mem::size_of::<FpuRegister>(),
        16usize,
        concat!("Size of: ", stringify!(FpuRegister))
    );
    assert_eq!(
        ::core::mem::align_of::<FpuRegister>(),
        16usize,
        concat!("Alignment of ", stringify!(FpuRegister))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FpuRegister>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FpuRegister),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FpuRegister>())).d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FpuRegister),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FpuRegister>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FpuRegister),
            "::",
            stringify!(s)
        )
    );
}
/// < General-purpose CPU registers (x0..x28 or r0..r10,r12).
pub const RegisterGroup_RegisterGroup_CpuGprs: RegisterGroup = 1;
/// < Special-purpose CPU registers (fp, lr, sp, pc, PSTATE or cpsr, TPIDR_EL0).
pub const RegisterGroup_RegisterGroup_CpuSprs: RegisterGroup = 2;
/// < General-purpose NEON registers.
pub const RegisterGroup_RegisterGroup_FpuGprs: RegisterGroup = 4;
/// < Special-purpose NEON registers.
pub const RegisterGroup_RegisterGroup_FpuSprs: RegisterGroup = 8;
/// < All CPU registers.
pub const RegisterGroup_RegisterGroup_CpuAll: RegisterGroup = 3;
/// < All NEON registers.
pub const RegisterGroup_RegisterGroup_FpuAll: RegisterGroup = 12;
/// < All registers.
pub const RegisterGroup_RegisterGroup_All: RegisterGroup = 15;
/// Armv8 register group. @ref svcGetThreadContext3 uses @ref RegisterGroup_All.
pub type RegisterGroup = u32;
/// < Instruction abort
pub const ThreadExceptionDesc_ThreadExceptionDesc_InstructionAbort: ThreadExceptionDesc = 256;
/// < Misaligned PC
pub const ThreadExceptionDesc_ThreadExceptionDesc_MisalignedPC: ThreadExceptionDesc = 258;
/// < Misaligned SP
pub const ThreadExceptionDesc_ThreadExceptionDesc_MisalignedSP: ThreadExceptionDesc = 259;
/// < SError [not in 1.0.0?]
pub const ThreadExceptionDesc_ThreadExceptionDesc_SError: ThreadExceptionDesc = 262;
/// < Bad SVC
pub const ThreadExceptionDesc_ThreadExceptionDesc_BadSVC: ThreadExceptionDesc = 769;
/// < Uncategorized, CP15RTTrap, CP15RRTTrap, CP14RTTrap, CP14RRTTrap, IllegalState, SystemRegisterTrap
pub const ThreadExceptionDesc_ThreadExceptionDesc_Trap: ThreadExceptionDesc = 260;
/// < None of the above, EC <= 0x34 and not a breakpoint
pub const ThreadExceptionDesc_ThreadExceptionDesc_Other: ThreadExceptionDesc = 257;
/// This is for \ref ThreadExceptionDump error_desc.
pub type ThreadExceptionDesc = u32;
/// Thread context structure (register dump)
#[repr(C)]
#[repr(align(16))]
pub struct ThreadContext {
    /// < GPRs 0..28. Note: also contains AArch32 SPRs.
    pub cpu_gprs: [CpuRegister; 29usize],
    /// < Frame pointer (x29) (AArch64). For AArch32, check r11.
    pub fp: u64,
    /// < Link register (x30) (AArch64). For AArch32, check r14.
    pub lr: u64,
    /// < Stack pointer (AArch64). For AArch32, check r13.
    pub sp: u64,
    /// < Program counter.
    pub pc: CpuRegister,
    /// < PSTATE or cpsr.
    pub psr: u32,
    /// < 32 general-purpose NEON registers.
    pub fpu_gprs: [FpuRegister; 32usize],
    /// < Floating-point control register.
    pub fpcr: u32,
    /// < Floating-point status register.
    pub fpsr: u32,
    /// < EL0 Read/Write Software Thread ID Register.
    pub tpidr: u64,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_ThreadContext() {
    assert_eq!(
        ::core::mem::size_of::<ThreadContext>(),
        800usize,
        concat!("Size of: ", stringify!(ThreadContext))
    );
    assert_eq!(
        ::core::mem::align_of::<ThreadContext>(),
        16usize,
        concat!("Alignment of ", stringify!(ThreadContext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadContext>())).cpu_gprs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadContext),
            "::",
            stringify!(cpu_gprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadContext>())).fp as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadContext),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadContext>())).lr as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadContext),
            "::",
            stringify!(lr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadContext>())).sp as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadContext),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadContext>())).pc as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadContext),
            "::",
            stringify!(pc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadContext>())).psr as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadContext),
            "::",
            stringify!(psr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadContext>())).fpu_gprs as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadContext),
            "::",
            stringify!(fpu_gprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadContext>())).fpcr as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadContext),
            "::",
            stringify!(fpcr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadContext>())).fpsr as *const _ as usize },
        788usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadContext),
            "::",
            stringify!(fpsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadContext>())).tpidr as *const _ as usize },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadContext),
            "::",
            stringify!(tpidr)
        )
    );
}
/// Thread exception dump structure.
#[repr(C)]
#[repr(align(16))]
pub struct ThreadExceptionDump {
    /// < See \ref ThreadExceptionDesc.
    pub error_desc: u32,
    pub pad: [u32; 3usize],
    /// < GPRs 0..28. Note: also contains AArch32 registers.
    pub cpu_gprs: [CpuRegister; 29usize],
    /// < Frame pointer.
    pub fp: CpuRegister,
    /// < Link register.
    pub lr: CpuRegister,
    /// < Stack pointer.
    pub sp: CpuRegister,
    /// < Program counter (elr_el1).
    pub pc: CpuRegister,
    pub padding: u64,
    /// < 32 general-purpose NEON registers.
    pub fpu_gprs: [FpuRegister; 32usize],
    /// < pstate & 0xFF0FFE20
    pub pstate: u32,
    pub afsr0: u32,
    pub afsr1: u32,
    pub esr: u32,
    /// < Fault Address Register.
    pub far: CpuRegister,
    pub __bindgen_padding_0: u64,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_ThreadExceptionDump() {
    assert_eq!(
        ::core::mem::size_of::<ThreadExceptionDump>(),
        832usize,
        concat!("Size of: ", stringify!(ThreadExceptionDump))
    );
    assert_eq!(
        ::core::mem::align_of::<ThreadExceptionDump>(),
        16usize,
        concat!("Alignment of ", stringify!(ThreadExceptionDump))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).error_desc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(error_desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).pad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).cpu_gprs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(cpu_gprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).fp as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).lr as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(lr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).sp as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).pc as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(pc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).padding as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).fpu_gprs as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(fpu_gprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).pstate as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(pstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).afsr0 as *const _ as usize },
        804usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(afsr0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).afsr1 as *const _ as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(afsr1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).esr as *const _ as usize },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(esr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).far as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(far)
        )
    );
}
#[repr(C)]
pub struct ThreadExceptionFrameA64 {
    /// < GPRs 0..8.
    pub cpu_gprs: [u64; 9usize],
    pub lr: u64,
    pub sp: u64,
    pub elr_el1: u64,
    /// < pstate & 0xFF0FFE20
    pub pstate: u32,
    pub afsr0: u32,
    pub afsr1: u32,
    pub esr: u32,
    pub far: u64,
}
#[test]
fn bindgen_test_layout_ThreadExceptionFrameA64() {
    assert_eq!(
        ::core::mem::size_of::<ThreadExceptionFrameA64>(),
        120usize,
        concat!("Size of: ", stringify!(ThreadExceptionFrameA64))
    );
    assert_eq!(
        ::core::mem::align_of::<ThreadExceptionFrameA64>(),
        8usize,
        concat!("Alignment of ", stringify!(ThreadExceptionFrameA64))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ThreadExceptionFrameA64>())).cpu_gprs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA64),
            "::",
            stringify!(cpu_gprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA64>())).lr as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA64),
            "::",
            stringify!(lr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA64>())).sp as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA64),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ThreadExceptionFrameA64>())).elr_el1 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA64),
            "::",
            stringify!(elr_el1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA64>())).pstate as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA64),
            "::",
            stringify!(pstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA64>())).afsr0 as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA64),
            "::",
            stringify!(afsr0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA64>())).afsr1 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA64),
            "::",
            stringify!(afsr1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA64>())).esr as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA64),
            "::",
            stringify!(esr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA64>())).far as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA64),
            "::",
            stringify!(far)
        )
    );
}
#[repr(C)]
pub struct ThreadExceptionFrameA32 {
    /// < GPRs 0..7.
    pub cpu_gprs: [u32; 8usize],
    pub sp: u32,
    pub lr: u32,
    pub elr_el1: u32,
    /// < tpidr_el0 = 1
    pub tpidr_el0: u32,
    /// < cpsr & 0xFF0FFE20
    pub cpsr: u32,
    pub afsr0: u32,
    pub afsr1: u32,
    pub esr: u32,
    pub far: u32,
}
#[test]
fn bindgen_test_layout_ThreadExceptionFrameA32() {
    assert_eq!(
        ::core::mem::size_of::<ThreadExceptionFrameA32>(),
        68usize,
        concat!("Size of: ", stringify!(ThreadExceptionFrameA32))
    );
    assert_eq!(
        ::core::mem::align_of::<ThreadExceptionFrameA32>(),
        4usize,
        concat!("Alignment of ", stringify!(ThreadExceptionFrameA32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ThreadExceptionFrameA32>())).cpu_gprs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA32),
            "::",
            stringify!(cpu_gprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA32>())).sp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA32),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA32>())).lr as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA32),
            "::",
            stringify!(lr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ThreadExceptionFrameA32>())).elr_el1 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA32),
            "::",
            stringify!(elr_el1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ThreadExceptionFrameA32>())).tpidr_el0 as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA32),
            "::",
            stringify!(tpidr_el0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA32>())).cpsr as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA32),
            "::",
            stringify!(cpsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA32>())).afsr0 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA32),
            "::",
            stringify!(afsr0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA32>())).afsr1 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA32),
            "::",
            stringify!(afsr1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA32>())).esr as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA32),
            "::",
            stringify!(esr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA32>())).far as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA32),
            "::",
            stringify!(far)
        )
    );
}
/// < Unmapped memory.
pub const MemoryType_MemType_Unmapped: MemoryType = 0;
/// < Mapped by kernel capability parsing in \ref svcCreateProcess.
pub const MemoryType_MemType_Io: MemoryType = 1;
/// < Mapped by kernel capability parsing in \ref svcCreateProcess.
pub const MemoryType_MemType_Normal: MemoryType = 2;
/// < Mapped during \ref svcCreateProcess.
pub const MemoryType_MemType_CodeStatic: MemoryType = 3;
/// < Transition from MemType_CodeStatic performed by \ref svcSetProcessMemoryPermission.
pub const MemoryType_MemType_CodeMutable: MemoryType = 4;
/// < Mapped using \ref svcSetHeapSize.
pub const MemoryType_MemType_Heap: MemoryType = 5;
/// < Mapped using \ref svcMapSharedMemory.
pub const MemoryType_MemType_SharedMem: MemoryType = 6;
/// < Mapped using \ref svcMapMemory.
pub const MemoryType_MemType_WeirdMappedMem: MemoryType = 7;
/// < Mapped using \ref svcMapProcessCodeMemory.
pub const MemoryType_MemType_ModuleCodeStatic: MemoryType = 8;
/// < Transition from \ref MemType_ModuleCodeStatic performed by \ref svcSetProcessMemoryPermission.
pub const MemoryType_MemType_ModuleCodeMutable: MemoryType = 9;
/// < IPC buffers with descriptor flags=0.
pub const MemoryType_MemType_IpcBuffer0: MemoryType = 10;
/// < Mapped using \ref svcMapMemory.
pub const MemoryType_MemType_MappedMemory: MemoryType = 11;
/// < Mapped during \ref svcCreateThread.
pub const MemoryType_MemType_ThreadLocal: MemoryType = 12;
/// < Mapped using \ref svcMapTransferMemory when the owning process has perm=0.
pub const MemoryType_MemType_TransferMemIsolated: MemoryType = 13;
/// < Mapped using \ref svcMapTransferMemory when the owning process has perm!=0.
pub const MemoryType_MemType_TransferMem: MemoryType = 14;
/// < Mapped using \ref svcMapProcessMemory.
pub const MemoryType_MemType_ProcessMem: MemoryType = 15;
/// < Reserved.
pub const MemoryType_MemType_Reserved: MemoryType = 16;
/// < IPC buffers with descriptor flags=1.
pub const MemoryType_MemType_IpcBuffer1: MemoryType = 17;
/// < IPC buffers with descriptor flags=3.
pub const MemoryType_MemType_IpcBuffer3: MemoryType = 18;
/// < Mapped in kernel during \ref svcCreateThread.
pub const MemoryType_MemType_KernelStack: MemoryType = 19;
/// < Mapped in kernel during \ref svcControlCodeMemory.
pub const MemoryType_MemType_CodeReadOnly: MemoryType = 20;
/// < Mapped in kernel during \ref svcControlCodeMemory.
pub const MemoryType_MemType_CodeWritable: MemoryType = 21;
/// Memory type enumeration (lower 8 bits of \ref MemoryState)
pub type MemoryType = u32;
/// < Type field (see \ref MemoryType).
pub const MemoryState_MemState_Type: MemoryState = 255;
/// < Permission change allowed.
pub const MemoryState_MemState_PermChangeAllowed: MemoryState = 256;
/// < Force read/writable by debug syscalls.
pub const MemoryState_MemState_ForceRwByDebugSyscalls: MemoryState = 512;
/// < IPC type 0 send allowed.
pub const MemoryState_MemState_IpcSendAllowed_Type0: MemoryState = 1024;
/// < IPC type 3 send allowed.
pub const MemoryState_MemState_IpcSendAllowed_Type3: MemoryState = 2048;
/// < IPC type 1 send allowed.
pub const MemoryState_MemState_IpcSendAllowed_Type1: MemoryState = 4096;
/// < Process permission change allowed.
pub const MemoryState_MemState_ProcessPermChangeAllowed: MemoryState = 16384;
/// < Map allowed.
pub const MemoryState_MemState_MapAllowed: MemoryState = 32768;
/// < Unmap process code memory allowed.
pub const MemoryState_MemState_UnmapProcessCodeMemAllowed: MemoryState = 65536;
/// < Transfer memory allowed.
pub const MemoryState_MemState_TransferMemAllowed: MemoryState = 131072;
/// < Query physical address allowed.
pub const MemoryState_MemState_QueryPAddrAllowed: MemoryState = 262144;
/// < Map device allowed (\ref svcMapDeviceAddressSpace and \ref svcMapDeviceAddressSpaceByForce).
pub const MemoryState_MemState_MapDeviceAllowed: MemoryState = 524288;
/// < Map device aligned allowed.
pub const MemoryState_MemState_MapDeviceAlignedAllowed: MemoryState = 1048576;
/// < IPC buffer allowed.
pub const MemoryState_MemState_IpcBufferAllowed: MemoryState = 2097152;
/// < Is pool allocated.
pub const MemoryState_MemState_IsPoolAllocated: MemoryState = 4194304;
/// < Alias for \ref MemState_IsPoolAllocated.
pub const MemoryState_MemState_IsRefCounted: MemoryState = 4194304;
/// < Map process allowed.
pub const MemoryState_MemState_MapProcessAllowed: MemoryState = 8388608;
/// < Attribute change allowed.
pub const MemoryState_MemState_AttrChangeAllowed: MemoryState = 16777216;
/// < Code memory allowed.
pub const MemoryState_MemState_CodeMemAllowed: MemoryState = 33554432;
/// Memory state bitmasks.
pub type MemoryState = u32;
/// < Is borrowed memory.
pub const MemoryAttribute_MemAttr_IsBorrowed: MemoryAttribute = 1;
/// < Is IPC mapped (when IpcRefCount > 0).
pub const MemoryAttribute_MemAttr_IsIpcMapped: MemoryAttribute = 2;
/// < Is device mapped (when DeviceRefCount > 0).
pub const MemoryAttribute_MemAttr_IsDeviceMapped: MemoryAttribute = 4;
/// < Is uncached.
pub const MemoryAttribute_MemAttr_IsUncached: MemoryAttribute = 8;
/// Memory attribute bitmasks.
pub type MemoryAttribute = u32;
/// < No permissions.
pub const Permission_Perm_None: Permission = 0;
/// < Read permission.
pub const Permission_Perm_R: Permission = 1;
/// < Write permission.
pub const Permission_Perm_W: Permission = 2;
/// < Execute permission.
pub const Permission_Perm_X: Permission = 4;
/// < Read/write permissions.
pub const Permission_Perm_Rw: Permission = 3;
/// < Read/execute permissions.
pub const Permission_Perm_Rx: Permission = 5;
/// < Don't care
pub const Permission_Perm_DontCare: Permission = 268435456;
/// Memory permission bitmasks.
pub type Permission = u32;
/// Memory information structure.
#[repr(C)]
pub struct MemoryInfo {
    /// < Base address.
    pub addr: u64,
    /// < Size.
    pub size: u64,
    /// < Memory type (see lower 8 bits of \ref MemoryState).
    pub type_: u32,
    /// < Memory attributes (see \ref MemoryAttribute).
    pub attr: u32,
    /// < Memory permissions (see \ref Permission).
    pub perm: u32,
    /// < Device reference count.
    pub device_refcount: u32,
    /// < IPC reference count.
    pub ipc_refcount: u32,
    /// < Padding.
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_MemoryInfo() {
    assert_eq!(
        ::core::mem::size_of::<MemoryInfo>(),
        40usize,
        concat!("Size of: ", stringify!(MemoryInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<MemoryInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(MemoryInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MemoryInfo>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryInfo),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MemoryInfo>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MemoryInfo>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MemoryInfo>())).attr as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryInfo),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MemoryInfo>())).perm as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryInfo),
            "::",
            stringify!(perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MemoryInfo>())).device_refcount as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryInfo),
            "::",
            stringify!(device_refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MemoryInfo>())).ipc_refcount as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryInfo),
            "::",
            stringify!(ipc_refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MemoryInfo>())).padding as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryInfo),
            "::",
            stringify!(padding)
        )
    );
}
/// Secure monitor arguments.
#[repr(C, packed)]
pub struct SecmonArgs {
    /// < Values of X0 through X7.
    pub X: [u64; 8usize],
}
#[test]
fn bindgen_test_layout_SecmonArgs() {
    assert_eq!(
        ::core::mem::size_of::<SecmonArgs>(),
        64usize,
        concat!("Size of: ", stringify!(SecmonArgs))
    );
    assert_eq!(
        ::core::mem::align_of::<SecmonArgs>(),
        1usize,
        concat!("Alignment of ", stringify!(SecmonArgs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SecmonArgs>())).X as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SecmonArgs),
            "::",
            stringify!(X)
        )
    );
}
/// < Map owner.
pub const CodeMapOperation_CodeMapOperation_MapOwner: CodeMapOperation = 0;
/// < Map slave.
pub const CodeMapOperation_CodeMapOperation_MapSlave: CodeMapOperation = 1;
/// < Unmap owner.
pub const CodeMapOperation_CodeMapOperation_UnmapOwner: CodeMapOperation = 2;
/// < Unmap slave.
pub const CodeMapOperation_CodeMapOperation_UnmapSlave: CodeMapOperation = 3;
/// Code memory mapping operations
pub type CodeMapOperation = u32;
/// <How much memory can a process map.
pub const LimitableResource_LimitableResource_Memory: LimitableResource = 0;
/// <How many threads can a process spawn.
pub const LimitableResource_LimitableResource_Threads: LimitableResource = 1;
/// <How many events can a process have.
pub const LimitableResource_LimitableResource_Events: LimitableResource = 2;
/// <How many transfer memories can a process make.
pub const LimitableResource_LimitableResource_TransferMemories: LimitableResource = 3;
/// <How many sessions can a process own.
pub const LimitableResource_LimitableResource_Sessions: LimitableResource = 4;
/// Limitable Resources.
pub type LimitableResource = u32;
/// <What state is a process in.
pub const ProcessInfoType_ProcessInfoType_ProcessState: ProcessInfoType = 0;
/// Process Information.
pub type ProcessInfoType = u32;
/// <Newly-created process, not yet started.
pub const ProcessState_ProcessState_Created: ProcessState = 0;
/// <Newly-created process, not yet started but attached to debugger.
pub const ProcessState_ProcessState_CreatedAttached: ProcessState = 1;
/// <Process that is running normally (and detached from any debugger).
pub const ProcessState_ProcessState_Running: ProcessState = 2;
/// <Process that has just crashed.
pub const ProcessState_ProcessState_Crashed: ProcessState = 3;
/// <Process that is running normally, attached to a debugger.
pub const ProcessState_ProcessState_RunningAttached: ProcessState = 4;
/// <Process has begun exiting.
pub const ProcessState_ProcessState_Exiting: ProcessState = 5;
/// <Process has finished exiting.
pub const ProcessState_ProcessState_Exited: ProcessState = 6;
/// <Process execution suspended by debugger.
pub const ProcessState_ProcessState_DebugSuspended: ProcessState = 7;
/// Process States.
pub type ProcessState = u32;
pub const DebugThreadParam_DebugThreadParam_ActualPriority: DebugThreadParam = 0;
pub const DebugThreadParam_DebugThreadParam_State: DebugThreadParam = 1;
pub const DebugThreadParam_DebugThreadParam_IdealCore: DebugThreadParam = 2;
pub const DebugThreadParam_DebugThreadParam_CurrentCore: DebugThreadParam = 3;
pub const DebugThreadParam_DebugThreadParam_CoreMask: DebugThreadParam = 4;
/// Debug Thread Parameters.
pub type DebugThreadParam = u32;
extern "C" {
    /// @brief Set the process heap to a given size. It can both extend and shrink the heap.
    /// @param[out] out_addr Variable to which write the address of the heap (which is randomized and fixed by the kernel)
    /// @param[in] size Size of the heap, must be a multiple of 0x2000000 and [2.0.0+] less than 0x18000000.
    /// @return Result code.
    /// @note Syscall number 0x00.
    pub fn svcSetHeapSize(out_addr: *mut *mut ctypes::c_void, size: u64) -> Result;
}
extern "C" {
    /// @brief Set the memory permissions of a (page-aligned) range of memory.
    /// @param[in] addr Start address of the range.
    /// @param[in] size Size of the range, in bytes.
    /// @param[in] perm Permissions (see \ref Permission).
    /// @return Result code.
    /// @remark Perm_X is not allowed. Setting write-only is not allowed either (Perm_W).
    /// This can be used to move back and forth between Perm_None, Perm_R and Perm_Rw.
    /// @note Syscall number 0x01.
    pub fn svcSetMemoryPermission(addr: *mut ctypes::c_void, size: u64, perm: u32) -> Result;
}
extern "C" {
    /// @brief Set the memory attributes of a (page-aligned) range of memory.
    /// @param[in] addr Start address of the range.
    /// @param[in] size Size of the range, in bytes.
    /// @param[in] val0 State0
    /// @param[in] val1 State1
    /// @return Result code.
    /// @remark See <a href="https://switchbrew.org/wiki/SVC#svcSetMemoryAttribute">switchbrew.org Wiki</a> for more details.
    /// @note Syscall number 0x02.
    pub fn svcSetMemoryAttribute(
        addr: *mut ctypes::c_void,
        size: u64,
        val0: u32,
        val1: u32,
    ) -> Result;
}
extern "C" {
    /// @brief Maps a memory range into a different range. Mainly used for adding guard pages around stack.
    /// Source range gets reprotected to Perm_None (it can no longer be accessed), and \ref MemAttr_IsBorrowed is set in the source \ref MemoryAttribute.
    /// @param[in] dst_addr Destination address.
    /// @param[in] src_addr Source address.
    /// @param[in] size Size of the range.
    /// @return Result code.
    /// @note Syscall number 0x04.
    pub fn svcMapMemory(
        dst_addr: *mut ctypes::c_void,
        src_addr: *mut ctypes::c_void,
        size: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Unmaps a region that was previously mapped with \ref svcMapMemory.
    /// @param[in] dst_addr Destination address.
    /// @param[in] src_addr Source address.
    /// @param[in] size Size of the range.
    /// @return Result code.
    /// @note Syscall number 0x05.
    pub fn svcUnmapMemory(
        dst_addr: *mut ctypes::c_void,
        src_addr: *mut ctypes::c_void,
        size: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Query information about an address. Will always fetch the lowest page-aligned mapping that contains the provided address.
    /// @param[out] meminfo_ptr \ref MemoryInfo structure which will be filled in.
    /// @param[out] pageinfo Page information which will be filled in.
    /// @param[in] addr Address to query.
    /// @return Result code.
    /// @note Syscall number 0x06.
    pub fn svcQueryMemory(meminfo_ptr: *mut MemoryInfo, pageinfo: *mut u32, addr: u64) -> Result;
}
extern "C" {
    /// @brief Exits the current process.
    /// @note Syscall number 0x07.
    pub fn svcExitProcess();
}
extern "C" {
    /// @brief Creates a thread.
    /// @return Result code.
    /// @note Syscall number 0x08.
    pub fn svcCreateThread(
        out: *mut Handle,
        entry: *mut ctypes::c_void,
        arg: *mut ctypes::c_void,
        stack_top: *mut ctypes::c_void,
        prio: ctypes::c_int,
        cpuid: ctypes::c_int,
    ) -> Result;
}
extern "C" {
    /// @brief Starts a freshly created thread.
    /// @return Result code.
    /// @note Syscall number 0x09.
    pub fn svcStartThread(handle: Handle) -> Result;
}
extern "C" {
    /// @brief Exits the current thread.
    /// @note Syscall number 0x0A.
    pub fn svcExitThread();
}
extern "C" {
    /// @brief Sleeps the current thread for the specified amount of time.
    /// @param[in] nano Number of nanoseconds to sleep, or 0, -1, -2 for yield.
    /// @note Syscall number 0x0B.
    pub fn svcSleepThread(nano: s64);
}
extern "C" {
    /// @brief Gets a thread's priority.
    /// @return Result code.
    /// @note Syscall number 0x0C.
    pub fn svcGetThreadPriority(priority: *mut u32, handle: Handle) -> Result;
}
extern "C" {
    /// @brief Sets a thread's priority.
    /// @return Result code.
    /// @note Syscall number 0x0D.
    pub fn svcSetThreadPriority(handle: Handle, priority: u32) -> Result;
}
extern "C" {
    /// @brief Gets a thread's core mask.
    /// @return Result code.
    /// @note Syscall number 0x0E.
    pub fn svcGetThreadCoreMask(
        preferred_core: *mut s32,
        affinity_mask: *mut u32,
        handle: Handle,
    ) -> Result;
}
extern "C" {
    /// @brief Sets a thread's core mask.
    /// @return Result code.
    /// @note Syscall number 0x0F.
    pub fn svcSetThreadCoreMask(handle: Handle, preferred_core: s32, affinity_mask: u32) -> Result;
}
extern "C" {
    /// @brief Gets the current processor's number.
    /// @return The current processor's number.
    /// @note Syscall number 0x10.
    pub fn svcGetCurrentProcessorNumber() -> u32;
}
extern "C" {
    /// @brief Sets an event's signalled status.
    /// @return Result code.
    /// @note Syscall number 0x11.
    pub fn svcSignalEvent(handle: Handle) -> Result;
}
extern "C" {
    /// @brief Clears an event's signalled status.
    /// @return Result code.
    /// @note Syscall number 0x12.
    pub fn svcClearEvent(handle: Handle) -> Result;
}
extern "C" {
    /// @brief Maps a block of shared memory.
    /// @return Result code.
    /// @note Syscall number 0x13.
    pub fn svcMapSharedMemory(
        handle: Handle,
        addr: *mut ctypes::c_void,
        size: usize,
        perm: u32,
    ) -> Result;
}
extern "C" {
    /// @brief Unmaps a block of shared memory.
    /// @return Result code.
    /// @note Syscall number 0x14.
    pub fn svcUnmapSharedMemory(handle: Handle, addr: *mut ctypes::c_void, size: usize) -> Result;
}
extern "C" {
    /// @brief Creates a block of transfer memory.
    /// @return Result code.
    /// @note Syscall number 0x15.
    pub fn svcCreateTransferMemory(
        out: *mut Handle,
        addr: *mut ctypes::c_void,
        size: usize,
        perm: u32,
    ) -> Result;
}
extern "C" {
    /// @brief Closes a handle, decrementing the reference count of the corresponding kernel object.
    /// This might result in the kernel freeing the object.
    /// @param handle Handle to close.
    /// @return Result code.
    /// @note Syscall number 0x16.
    pub fn svcCloseHandle(handle: Handle) -> Result;
}
extern "C" {
    /// @brief Resets a signal.
    /// @return Result code.
    /// @note Syscall number 0x17.
    pub fn svcResetSignal(handle: Handle) -> Result;
}
extern "C" {
    /// @brief Waits on one or more synchronization objects, optionally with a timeout.
    /// @return Result code.
    /// @note Syscall number 0x18.
    /// @note \p handleCount must not be greater than \ref MAX_WAIT_OBJECTS. This is a Horizon kernel limitation.
    /// @note This is the raw syscall, which can be cancelled by \ref svcCancelSynchronization or other means. \ref waitHandles or \ref waitMultiHandle should normally be used instead.
    pub fn svcWaitSynchronization(
        index: *mut s32,
        handles: *const Handle,
        handleCount: s32,
        timeout: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Waits a \ref svcWaitSynchronization operation being done on a synchronization object in another thread.
    /// @return Result code.
    /// @note Syscall number 0x19.
    pub fn svcCancelSynchronization(thread: Handle) -> Result;
}
extern "C" {
    /// @brief Arbitrates a mutex lock operation in userspace.
    /// @return Result code.
    /// @note Syscall number 0x1A.
    pub fn svcArbitrateLock(wait_tag: u32, tag_location: *mut u32, self_tag: u32) -> Result;
}
extern "C" {
    /// @brief Arbitrates a mutex unlock operation in userspace.
    /// @return Result code.
    /// @note Syscall number 0x1B.
    pub fn svcArbitrateUnlock(tag_location: *mut u32) -> Result;
}
extern "C" {
    /// @brief Performs a condition variable wait operation in userspace.
    /// @return Result code.
    /// @note Syscall number 0x1C.
    pub fn svcWaitProcessWideKeyAtomic(
        key: *mut u32,
        tag_location: *mut u32,
        self_tag: u32,
        timeout: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Performs a condition variable wake-up operation in userspace.
    /// @return Result code.
    /// @note Syscall number 0x1D.
    pub fn svcSignalProcessWideKey(key: *mut u32, num: s32) -> Result;
}
extern "C" {
    /// @brief Gets the current system tick.
    /// @return The current system tick.
    /// @note Syscall number 0x1E.
    pub fn svcGetSystemTick() -> u64;
}
extern "C" {
    /// @brief Connects to a registered named port.
    /// @return Result code.
    /// @note Syscall number 0x1F.
    pub fn svcConnectToNamedPort(session: *mut Handle, name: *const ctypes::c_char) -> Result;
}
extern "C" {
    /// @brief Sends an IPC synchronization request to a session.
    /// @return Result code.
    /// @note Syscall number 0x21.
    pub fn svcSendSyncRequest(session: Handle) -> Result;
}
extern "C" {
    /// @brief Sends an IPC synchronization request to a session from an user allocated buffer.
    /// @return Result code.
    /// @remark size must be allocated to 0x1000 bytes.
    /// @note Syscall number 0x22.
    pub fn svcSendSyncRequestWithUserBuffer(
        usrBuffer: *mut ctypes::c_void,
        size: u64,
        session: Handle,
    ) -> Result;
}
extern "C" {
    /// @brief Sends an IPC synchronization request to a session from an user allocated buffer (asynchronous version).
    /// @return Result code.
    /// @remark size must be allocated to 0x1000 bytes.
    /// @note Syscall number 0x23.
    pub fn svcSendAsyncRequestWithUserBuffer(
        handle: *mut Handle,
        usrBuffer: *mut ctypes::c_void,
        size: u64,
        session: Handle,
    ) -> Result;
}
extern "C" {
    /// @brief Gets the PID associated with a process.
    /// @return Result code.
    /// @note Syscall number 0x24.
    pub fn svcGetProcessId(processID: *mut u64, handle: Handle) -> Result;
}
extern "C" {
    /// @brief Gets the TID associated with a process.
    /// @return Result code.
    /// @note Syscall number 0x25.
    pub fn svcGetThreadId(threadID: *mut u64, handle: Handle) -> Result;
}
extern "C" {
    /// @brief Breaks execution. Panic.
    /// @param[in] breakReason Break reason.
    /// @param[in] inval1 First break parameter.
    /// @param[in] inval2 Second break parameter.
    /// @return Result code.
    /// @note Syscall number 0x26.
    pub fn svcBreak(breakReason: u32, inval1: u64, inval2: u64) -> Result;
}
extern "C" {
    /// @brief Outputs debug text, if used during debugging.
    /// @param[in] str Text to output.
    /// @param[in] size Size of the text in bytes.
    /// @return Result code.
    /// @note Syscall number 0x27.
    pub fn svcOutputDebugString(str: *const ctypes::c_char, size: u64) -> Result;
}
extern "C" {
    /// @brief Returns from an exception.
    /// @param[in] res Result code.
    /// @note Syscall number 0x28.
    pub fn svcReturnFromException(res: Result);
}
extern "C" {
    /// @brief Retrieves information about the system, or a certain kernel object.
    /// @param[out] out Variable to which store the information.
    /// @param[in] id0 First ID of the property to retrieve.
    /// @param[in] handle Handle of the object to retrieve information from, or \ref INVALID_HANDLE to retrieve information about the system.
    /// @param[in] id1 Second ID of the property to retrieve.
    /// @return Result code.
    /// @remark The full list of property IDs can be found on the <a href="https://switchbrew.org/wiki/SVC#svcGetInfo">switchbrew.org wiki</a>.
    /// @note Syscall number 0x29.
    pub fn svcGetInfo(out: *mut u64, id0: u64, handle: Handle, id1: u64) -> Result;
}
extern "C" {
    /// @brief Maps new heap memory at the desired address. [3.0.0+]
    /// @return Result code.
    /// @note Syscall number 0x2C.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcMapPhysicalMemory(address: *mut ctypes::c_void, size: u64) -> Result;
}
extern "C" {
    /// @brief Undoes the effects of \ref svcMapPhysicalMemory. [3.0.0+]
    /// @return Result code.
    /// @note Syscall number 0x2D.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcUnmapPhysicalMemory(address: *mut ctypes::c_void, size: u64) -> Result;
}
extern "C" {
    /// @brief Gets the maximum value a LimitableResource can have, for a Resource Limit handle.
    /// @return Result code.
    /// @note Syscall number 0x30.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcGetResourceLimitLimitValue(
        out: *mut u64,
        reslimit_h: Handle,
        which: LimitableResource,
    ) -> Result;
}
extern "C" {
    /// @brief Gets the maximum value a LimitableResource can have, for a Resource Limit handle.
    /// @return Result code.
    /// @note Syscall number 0x31.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcGetResourceLimitCurrentValue(
        out: *mut u64,
        reslimit_h: Handle,
        which: LimitableResource,
    ) -> Result;
}
extern "C" {
    /// @brief Configures the pause/unpause status of a thread.
    /// @return Result code.
    /// @note Syscall number 0x32.
    pub fn svcSetThreadActivity(thread: Handle, paused: bool) -> Result;
}
extern "C" {
    /// @brief Dumps the registers of a thread paused by @ref svcSetThreadActivity (register groups: all).
    /// @param[out] ctx Output thread context (register dump).
    /// @param[in] thread Thread handle.
    /// @return Result code.
    /// @note Syscall number 0x33.
    /// @warning Official kernel will not dump x0..x18 if the thread is currently executing a system call, and prior to 6.0.0 doesn't dump TPIDR_EL0.
    pub fn svcGetThreadContext3(ctx: *mut ThreadContext, thread: Handle) -> Result;
}
extern "C" {
    /// @brief Creates an IPC session.
    /// @return Result code.
    /// @note Syscall number 0x40.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcCreateSession(
        server_handle: *mut Handle,
        client_handle: *mut Handle,
        unk0: u32,
        unk1: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Accepts an IPC session.
    /// @return Result code.
    /// @note Syscall number 0x41.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcAcceptSession(session_handle: *mut Handle, port_handle: Handle) -> Result;
}
extern "C" {
    /// @brief Performs IPC input/output.
    /// @return Result code.
    /// @note Syscall number 0x43.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcReplyAndReceive(
        index: *mut s32,
        handles: *const Handle,
        handleCount: s32,
        replyTarget: Handle,
        timeout: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Performs IPC input/output from an user allocated buffer.
    /// @return Result code.
    /// @note Syscall number 0x44.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcReplyAndReceiveWithUserBuffer(
        index: *mut s32,
        usrBuffer: *mut ctypes::c_void,
        size: u64,
        handles: *const Handle,
        handleCount: s32,
        replyTarget: Handle,
        timeout: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Creates a system event.
    /// @return Result code.
    /// @note Syscall number 0x45.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcCreateEvent(server_handle: *mut Handle, client_handle: *mut Handle) -> Result;
}
extern "C" {
    /// @brief Maps unsafe memory (usable for GPU DMA) for a system module at the desired address. [5.0.0+]
    /// @return Result code.
    /// @note Syscall number 0x48.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcMapPhysicalMemoryUnsafe(address: *mut ctypes::c_void, size: u64) -> Result;
}
extern "C" {
    /// @brief Undoes the effects of \ref svcMapPhysicalMemoryUnsafe. [5.0.0+]
    /// @return Result code.
    /// @note Syscall number 0x49.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcUnmapPhysicalMemoryUnsafe(address: *mut ctypes::c_void, size: u64) -> Result;
}
extern "C" {
    /// @brief Sets the system-wide limit for unsafe memory mappable using \ref svcMapPhysicalMemoryUnsafe. [5.0.0+]
    /// @return Result code.
    /// @note Syscall number 0x4A.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcSetUnsafeLimit(size: u64) -> Result;
}
extern "C" {
    /// @brief Creates code memory in the caller's address space [4.0.0+].
    /// @return Result code.
    /// @note Syscall number 0x4B.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcCreateCodeMemory(
        code_handle: *mut Handle,
        src_addr: *mut ctypes::c_void,
        size: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Maps code memory in the caller's address space [4.0.0+].
    /// @return Result code.
    /// @note Syscall number 0x4C.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcControlCodeMemory(
        code_handle: Handle,
        op: CodeMapOperation,
        dst_addr: *mut ctypes::c_void,
        size: u64,
        perm: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Reads/writes a protected MMIO register.
    /// @return Result code.
    /// @note Syscall number 0x4E.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcReadWriteRegister(outVal: *mut u32, regAddr: u64, rwMask: u32, inVal: u32) -> Result;
}
extern "C" {
    /// @brief Creates a block of shared memory.
    /// @return Result code.
    /// @note Syscall number 0x50.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcCreateSharedMemory(
        out: *mut Handle,
        size: usize,
        local_perm: u32,
        other_perm: u32,
    ) -> Result;
}
extern "C" {
    /// @brief Maps a block of transfer memory.
    /// @return Result code.
    /// @note Syscall number 0x51.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcMapTransferMemory(
        tmem_handle: Handle,
        addr: *mut ctypes::c_void,
        size: usize,
        perm: u32,
    ) -> Result;
}
extern "C" {
    /// @brief Unmaps a block of transfer memory.
    /// @return Result code.
    /// @note Syscall number 0x52.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcUnmapTransferMemory(
        tmem_handle: Handle,
        addr: *mut ctypes::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    /// @brief Creates an event and binds it to a specific hardware interrupt.
    /// @return Result code.
    /// @note Syscall number 0x53.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcCreateInterruptEvent(handle: *mut Handle, irqNum: u64, flag: u32) -> Result;
}
extern "C" {
    /// @brief Queries information about a certain virtual address, including its physical address.
    /// @return Result code.
    /// @note Syscall number 0x54.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcQueryPhysicalAddress(out: *mut u64, virtaddr: u64) -> Result;
}
extern "C" {
    /// @brief Returns a virtual address mapped to a given IO range.
    /// @return Result code.
    /// @note Syscall number 0x55.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcQueryIoMapping(virtaddr: *mut u64, physaddr: u64, size: u64) -> Result;
}
extern "C" {
    /// @brief Creates a virtual address space for binding device address spaces.
    /// @return Result code.
    /// @note Syscall number 0x56.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcCreateDeviceAddressSpace(handle: *mut Handle, dev_addr: u64, dev_size: u64)
        -> Result;
}
extern "C" {
    /// @brief Attaches a device address space to a device.
    /// @return Result code.
    /// @note Syscall number 0x57.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcAttachDeviceAddressSpace(device: u64, handle: Handle) -> Result;
}
extern "C" {
    /// @brief Detaches a device address space from a device.
    /// @return Result code.
    /// @note Syscall number 0x58.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcDetachDeviceAddressSpace(device: u64, handle: Handle) -> Result;
}
extern "C" {
    /// @brief Maps an attached device address space to an userspace address.
    /// @return Result code.
    /// @remark The userspace destination address must have the \ref MemState_MapDeviceAllowed bit set.
    /// @note Syscall number 0x59.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcMapDeviceAddressSpaceByForce(
        handle: Handle,
        proc_handle: Handle,
        map_addr: u64,
        dev_size: u64,
        dev_addr: u64,
        perm: u32,
    ) -> Result;
}
extern "C" {
    /// @brief Maps an attached device address space to an userspace address.
    /// @return Result code.
    /// @remark The userspace destination address must have the \ref MemState_MapDeviceAlignedAllowed bit set.
    /// @note Syscall number 0x5A.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcMapDeviceAddressSpaceAligned(
        handle: Handle,
        proc_handle: Handle,
        map_addr: u64,
        dev_size: u64,
        dev_addr: u64,
        perm: u32,
    ) -> Result;
}
extern "C" {
    /// @brief Unmaps an attached device address space from an userspace address.
    /// @return Result code.
    /// @note Syscall number 0x5C.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcUnmapDeviceAddressSpace(
        handle: Handle,
        proc_handle: Handle,
        map_addr: u64,
        map_size: u64,
        dev_addr: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Debugs an active process.
    /// @return Result code.
    /// @note Syscall number 0x60.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcDebugActiveProcess(debug: *mut Handle, processID: u64) -> Result;
}
extern "C" {
    /// @brief Breaks an active debugging session.
    /// @return Result code.
    /// @note Syscall number 0x61.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcBreakDebugProcess(debug: Handle) -> Result;
}
extern "C" {
    /// @brief Terminates the process of an active debugging session.
    /// @return Result code.
    /// @note Syscall number 0x62.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcTerminateDebugProcess(debug: Handle) -> Result;
}
extern "C" {
    /// @brief Gets an incoming debug event from a debugging session.
    /// @return Result code.
    /// @note Syscall number 0x63.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcGetDebugEvent(event_out: *mut u8, debug: Handle) -> Result;
}
extern "C" {
    /// @brief Continues a debugging session.
    /// @return Result code.
    /// @note Syscall number 0x64.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    /// @warning Only exists on 3.0.0+. For older versions use \ref svcLegacyContinueDebugEvent.
    pub fn svcContinueDebugEvent(
        debug: Handle,
        flags: u32,
        tid_list: *mut u64,
        num_tids: u32,
    ) -> Result;
}
extern "C" {
    /// @brief Continues a debugging session.
    /// @return Result code.
    /// @note Syscall number 0x64.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    /// @warning Only exists on 1.0.0-2.3.0. For newer versions use \ref svcContinueDebugEvent.
    pub fn svcLegacyContinueDebugEvent(debug: Handle, flags: u32, threadID: u64) -> Result;
}
extern "C" {
    /// @brief Gets the context (dump the registers) of a thread in a debugging session.
    /// @return Result code.
    /// @param[out] ctx Output thread context (register dump).
    /// @param[in] debug Debug handle.
    /// @param[in] threadID ID of the thread to dump the context of.
    /// @param[in] flags Register groups to select, combination of @ref RegisterGroup flags.
    /// @note Syscall number 0x67.
    /// @warning Official kernel will not dump any CPU GPR if the thread is currently executing a system call (except @ref svcBreak and @ref svcReturnFromException).
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcGetDebugThreadContext(
        ctx: *mut ThreadContext,
        debug: Handle,
        threadID: u64,
        flags: u32,
    ) -> Result;
}
extern "C" {
    /// @brief Gets the context (dump the registers) of a thread in a debugging session.
    /// @return Result code.
    /// @param[in] debug Debug handle.
    /// @param[in] threadID ID of the thread to set the context of.
    /// @param[in] ctx Input thread context (register dump).
    /// @param[in] flags Register groups to select, combination of @ref RegisterGroup flags.
    /// @note Syscall number 0x68.
    /// @warning Official kernel will return an error if the thread is currently executing a system call (except @ref svcBreak and @ref svcReturnFromException).
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcSetDebugThreadContext(
        debug: Handle,
        threadID: u64,
        ctx: *const ThreadContext,
        flags: u32,
    ) -> Result;
}
extern "C" {
    /// @brief Retrieves a list of all running processes.
    /// @return Result code.
    /// @note Syscall number 0x65.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcGetProcessList(num_out: *mut u32, pids_out: *mut u64, max_pids: u32) -> Result;
}
extern "C" {
    /// @brief Retrieves a list of all threads for a debug handle (or zero).
    /// @return Result code.
    /// @note Syscall number 0x66.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcGetThreadList(
        num_out: *mut u32,
        tids_out: *mut u64,
        max_tids: u32,
        debug: Handle,
    ) -> Result;
}
extern "C" {
    /// @brief Queries memory information from a process that is being debugged.
    /// @return Result code.
    /// @note Syscall number 0x69.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcQueryDebugProcessMemory(
        meminfo_ptr: *mut MemoryInfo,
        pageinfo: *mut u32,
        debug: Handle,
        addr: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Reads memory from a process that is being debugged.
    /// @return Result code.
    /// @note Syscall number 0x6A.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcReadDebugProcessMemory(
        buffer: *mut ctypes::c_void,
        debug: Handle,
        addr: u64,
        size: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Writes to memory in a process that is being debugged.
    /// @return Result code.
    /// @note Syscall number 0x6B.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcWriteDebugProcessMemory(
        debug: Handle,
        buffer: *const ctypes::c_void,
        addr: u64,
        size: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Gets parameters from a thread in a debugging session.
    /// @return Result code.
    /// @note Syscall number 0x6D.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcGetDebugThreadParam(
        out_64: *mut u64,
        out_32: *mut u32,
        debug: Handle,
        threadID: u64,
        param: DebugThreadParam,
    ) -> Result;
}
extern "C" {
    /// @brief Retrieves privileged information about the system, or a certain kernel object.
    /// @param[out] out Variable to which store the information.
    /// @param[in] id0 First ID of the property to retrieve.
    /// @param[in] handle Handle of the object to retrieve information from, or \ref INVALID_HANDLE to retrieve information about the system.
    /// @param[in] id1 Second ID of the property to retrieve.
    /// @return Result code.
    /// @remark The full list of property IDs can be found on the <a href="https://switchbrew.org/wiki/SVC#svcGetSystemInfo">switchbrew.org wiki</a>.
    /// @note Syscall number 0x6F.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcGetSystemInfo(out: *mut u64, id0: u64, handle: Handle, id1: u64) -> Result;
}
extern "C" {
    /// @brief Creates a port.
    /// @return Result code.
    /// @note Syscall number 0x70.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcCreatePort(
        portServer: *mut Handle,
        portClient: *mut Handle,
        max_sessions: s32,
        is_light: bool,
        name: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    /// @brief Manages a named port.
    /// @return Result code.
    /// @note Syscall number 0x71.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcManageNamedPort(
        portServer: *mut Handle,
        name: *const ctypes::c_char,
        maxSessions: s32,
    ) -> Result;
}
extern "C" {
    /// @brief Manages a named port.
    /// @return Result code.
    /// @note Syscall number 0x72.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcConnectToPort(session: *mut Handle, port: Handle) -> Result;
}
extern "C" {
    /// @brief Sets the memory permissions for the specified memory with the supplied process handle.
    /// @param[in] proc Process handle.
    /// @param[in] addr Address of the memory.
    /// @param[in] size Size of the memory.
    /// @param[in] perm Permissions (see \ref Permission).
    /// @return Result code.
    /// @remark This returns an error (0xD801) when \p perm is >0x5, hence -WX and RWX are not allowed.
    /// @note Syscall number 0x73.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcSetProcessMemoryPermission(proc_: Handle, addr: u64, size: u64, perm: u32) -> Result;
}
extern "C" {
    /// @brief Maps the src address from the supplied process handle into the current process.
    /// @param[in] dst Address to which map the memory in the current process.
    /// @param[in] proc Process handle.
    /// @param[in] src Source mapping address.
    /// @param[in] size Size of the memory.
    /// @return Result code.
    /// @remark This allows mapping code and rodata with RW- permission.
    /// @note Syscall number 0x74.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcMapProcessMemory(
        dst: *mut ctypes::c_void,
        proc_: Handle,
        src: u64,
        size: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Undoes the effects of \ref svcMapProcessMemory.
    /// @param[in] dst Destination mapping address
    /// @param[in] proc Process handle.
    /// @param[in] src Address of the memory in the process.
    /// @param[in] size Size of the memory.
    /// @return Result code.
    /// @remark This allows mapping code and rodata with RW- permission.
    /// @note Syscall number 0x75.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcUnmapProcessMemory(
        dst: *mut ctypes::c_void,
        proc_: Handle,
        src: u64,
        size: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Maps normal heap in a certain process as executable code (used when loading NROs).
    /// @param[in] proc Process handle (cannot be \ref CUR_PROCESS_HANDLE).
    /// @param[in] dst Destination mapping address.
    /// @param[in] src Source mapping address.
    /// @param[in] size Size of the mapping.
    /// @return Result code.
    /// @note Syscall number 0x77.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcMapProcessCodeMemory(proc_: Handle, dst: u64, src: u64, size: u64) -> Result;
}
extern "C" {
    /// @brief Undoes the effects of \ref svcMapProcessCodeMemory.
    /// @param[in] proc Process handle (cannot be \ref CUR_PROCESS_HANDLE).
    /// @param[in] dst Destination mapping address.
    /// @param[in] src Source mapping address.
    /// @param[in] size Size of the mapping.
    /// @return Result code.
    /// @note Syscall number 0x78.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcUnmapProcessCodeMemory(proc_: Handle, dst: u64, src: u64, size: u64) -> Result;
}
extern "C" {
    /// @brief Creates a new process.
    /// @return Result code.
    /// @note Syscall number 0x79.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcCreateProcess(
        out: *mut Handle,
        proc_info: *mut ctypes::c_void,
        caps: *mut u32,
        cap_num: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Starts executing a freshly created process.
    /// @return Result code.
    /// @note Syscall number 0x7A.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcStartProcess(
        proc_: Handle,
        main_prio: s32,
        default_cpu: s32,
        stack_size: u32,
    ) -> Result;
}
extern "C" {
    /// @brief Terminates a running process.
    /// @return Result code.
    /// @note Syscall number 0x7B.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcTerminateProcess(proc_: Handle) -> Result;
}
extern "C" {
    /// @brief Gets a \ref ProcessInfoType for a process.
    /// @return Result code.
    /// @note Syscall number 0x7C.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcGetProcessInfo(out: *mut u64, proc_: Handle, which: ProcessInfoType) -> Result;
}
extern "C" {
    /// @brief Creates a new Resource Limit handle.
    /// @return Result code.
    /// @note Syscall number 0x7D.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcCreateResourceLimit(out: *mut Handle) -> Result;
}
extern "C" {
    /// @brief Sets the value for a \ref LimitableResource for a Resource Limit handle.
    /// @return Result code.
    /// @note Syscall number 0x7E.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcSetResourceLimitLimitValue(
        reslimit: Handle,
        which: LimitableResource,
        value: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Calls a secure monitor function (TrustZone, EL3).
    /// @param regs Arguments to pass to the secure monitor.
    /// @return Return value from the secure monitor.
    /// @note Syscall number 0x7F.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcCallSecureMonitor(regs: *mut SecmonArgs) -> u64;
}
pub type _LOCK_T = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock_t {
    pub lock: _LOCK_T,
    pub thread_tag: u32,
    pub counter: u32,
}
#[test]
fn bindgen_test_layout___lock_t() {
    assert_eq!(
        ::core::mem::size_of::<__lock_t>(),
        12usize,
        concat!("Size of: ", stringify!(__lock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__lock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__lock_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__lock_t>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lock_t),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__lock_t>())).thread_tag as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__lock_t),
            "::",
            stringify!(thread_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__lock_t>())).counter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__lock_t),
            "::",
            stringify!(counter)
        )
    );
}
pub type _LOCK_RECURSIVE_T = __lock_t;
pub type _COND_T = u32;
extern "C" {
    pub fn __libc_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_init_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_close(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_close_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_acquire(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_release(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_release_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_try_acquire(lock: *mut _LOCK_T) -> ctypes::c_int;
}
extern "C" {
    pub fn __libc_lock_try_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T) -> ctypes::c_int;
}
extern "C" {
    pub fn __libc_cond_init(cond: *mut _COND_T) -> ctypes::c_int;
}
extern "C" {
    pub fn __libc_cond_signal(cond: *mut _COND_T) -> ctypes::c_int;
}
extern "C" {
    pub fn __libc_cond_broadcast(cond: *mut _COND_T) -> ctypes::c_int;
}
extern "C" {
    pub fn __libc_cond_wait(
        cond: *mut _COND_T,
        lock: *mut _LOCK_T,
        timeout_ns: u64,
    ) -> ctypes::c_int;
}
extern "C" {
    pub fn __libc_cond_wait_recursive(
        cond: *mut _COND_T,
        lock: *mut _LOCK_RECURSIVE_T,
        timeout_ns: u64,
    ) -> ctypes::c_int;
}
/// Mutex datatype, defined in newlib.
pub type Mutex = _LOCK_T;
/// Recursive mutex datatype, defined in newlib.
pub type RMutex = _LOCK_RECURSIVE_T;
extern "C" {
    /// @brief Locks a mutex.
    /// @param m Mutex object.
    pub fn mutexLock(m: *mut Mutex);
}
extern "C" {
    /// @brief Attempts to lock a mutex without waiting.
    /// @param m Mutex object.
    /// @return 1 if the mutex has been acquired successfully, and 0 on contention.
    pub fn mutexTryLock(m: *mut Mutex) -> bool;
}
extern "C" {
    /// @brief Unlocks a mutex.
    /// @param m Mutex object.
    pub fn mutexUnlock(m: *mut Mutex);
}
extern "C" {
    /// @brief Locks a recursive mutex.
    /// @param m Recursive mutex object.
    pub fn rmutexLock(m: *mut RMutex);
}
extern "C" {
    /// @brief Attempts to lock a recursive mutex without waiting.
    /// @param m Recursive mutex object.
    /// @return 1 if the mutex has been acquired successfully, and 0 on contention.
    pub fn rmutexTryLock(m: *mut RMutex) -> bool;
}
extern "C" {
    /// @brief Unlocks a recursive mutex.
    /// @param m Recursive mutex object.
    pub fn rmutexUnlock(m: *mut RMutex);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WaitableMethods {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WaitableNode {
    pub prev: *mut WaitableNode,
    pub next: *mut WaitableNode,
}
#[test]
fn bindgen_test_layout_WaitableNode() {
    assert_eq!(
        ::core::mem::size_of::<WaitableNode>(),
        16usize,
        concat!("Size of: ", stringify!(WaitableNode))
    );
    assert_eq!(
        ::core::mem::align_of::<WaitableNode>(),
        8usize,
        concat!("Alignment of ", stringify!(WaitableNode))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WaitableNode>())).prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WaitableNode),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WaitableNode>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WaitableNode),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Waitable {
    pub vt: *const WaitableMethods,
    pub list: WaitableNode,
    pub mutex: Mutex,
}
#[test]
fn bindgen_test_layout_Waitable() {
    assert_eq!(
        ::core::mem::size_of::<Waitable>(),
        32usize,
        concat!("Size of: ", stringify!(Waitable))
    );
    assert_eq!(
        ::core::mem::align_of::<Waitable>(),
        8usize,
        concat!("Alignment of ", stringify!(Waitable))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Waitable>())).vt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Waitable),
            "::",
            stringify!(vt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Waitable>())).list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Waitable),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Waitable>())).mutex as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Waitable),
            "::",
            stringify!(mutex)
        )
    );
}
pub const WaiterType_WaiterType_Handle: WaiterType = 0;
pub const WaiterType_WaiterType_HandleWithClear: WaiterType = 1;
pub const WaiterType_WaiterType_Waitable: WaiterType = 2;
pub type WaiterType = u32;
/// Waiter structure, representing any generic waitable synchronization object; both kernel-mode and user-mode.
#[repr(C)]
pub struct Waiter {
    pub type_: WaiterType,
    pub __bindgen_anon_1: Waiter__bindgen_ty_1,
}
#[repr(C)]
pub struct Waiter__bindgen_ty_1 {
    pub handle: __BindgenUnionField<Handle>,
    pub waitable: __BindgenUnionField<*mut Waitable>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_Waiter__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<Waiter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(Waiter__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<Waiter__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(Waiter__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Waiter__bindgen_ty_1>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Waiter__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Waiter__bindgen_ty_1>())).waitable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Waiter__bindgen_ty_1),
            "::",
            stringify!(waitable)
        )
    );
}
#[test]
fn bindgen_test_layout_Waiter() {
    assert_eq!(
        ::core::mem::size_of::<Waiter>(),
        16usize,
        concat!("Size of: ", stringify!(Waiter))
    );
    assert_eq!(
        ::core::mem::align_of::<Waiter>(),
        8usize,
        concat!("Alignment of ", stringify!(Waiter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Waiter>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Waiter),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    /// @brief Waits for an arbitrary number of generic waitable synchronization objects, optionally with a timeout.
    /// @param[out] idx_out Variable that will received the index of the signalled object.
    /// @param[in] objects Array containing \ref Waiter structures.
    /// @param[in] num_objects Number of objects in the array.
    /// @param[in] timeout Timeout (in nanoseconds).
    /// @return Result code.
    /// @note The number of objects must not be greater than \ref MAX_WAIT_OBJECTS. This is a Horizon kernel limitation.
    pub fn waitObjects(
        idx_out: *mut s32,
        objects: *const Waiter,
        num_objects: s32,
        timeout: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Waits for an arbitrary number of kernel synchronization objects, optionally with a timeout. This function replaces \ref svcWaitSynchronization.
    /// @param[out] idx_out Variable that will received the index of the signalled object.
    /// @param[in] handles Array containing handles.
    /// @param[in] num_handles Number of handles in the array.
    /// @param[in] timeout Timeout (in nanoseconds).
    /// @return Result code.
    /// @note The number of objects must not be greater than \ref MAX_WAIT_OBJECTS. This is a Horizon kernel limitation.
    pub fn waitHandles(
        idx_out: *mut s32,
        handles: *const Handle,
        num_handles: s32,
        timeout: u64,
    ) -> Result;
}
/// Transfer memory information structure.
#[repr(C)]
pub struct TransferMemory {
    /// < Kernel object handle.
    pub handle: Handle,
    /// < Size of the transfer memory object.
    pub size: usize,
    /// < Permissions of the transfer memory object.
    pub perm: Permission,
    /// < Address of the source backing memory.
    pub src_addr: *mut ctypes::c_void,
    /// < Address to which the transfer memory object is mapped.
    pub map_addr: *mut ctypes::c_void,
}
#[test]
fn bindgen_test_layout_TransferMemory() {
    assert_eq!(
        ::core::mem::size_of::<TransferMemory>(),
        40usize,
        concat!("Size of: ", stringify!(TransferMemory))
    );
    assert_eq!(
        ::core::mem::align_of::<TransferMemory>(),
        8usize,
        concat!("Alignment of ", stringify!(TransferMemory))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TransferMemory>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TransferMemory),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TransferMemory>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TransferMemory),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TransferMemory>())).perm as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TransferMemory),
            "::",
            stringify!(perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TransferMemory>())).src_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TransferMemory),
            "::",
            stringify!(src_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TransferMemory>())).map_addr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TransferMemory),
            "::",
            stringify!(map_addr)
        )
    );
}
extern "C" {
    /// @brief Creates a transfer memory object.
    /// @param t Transfer memory information structure that will be filled in.
    /// @param size Size of the transfer memory object to create.
    /// @param perm Permissions with which to protect the transfer memory in the local process.
    /// @return Result code.
    pub fn tmemCreate(t: *mut TransferMemory, size: usize, perm: Permission) -> Result;
}
extern "C" {
    /// @brief Creates a transfer memory object from existing memory.
    /// @param t Transfer memory information structure that will be filled in.
    /// @param buf Pointer to a page-aligned buffer.
    /// @param size Size of the transfer memory object to create.
    /// @param perm Permissions with which to protect the transfer memory in the local process.
    /// @return Result code.
    pub fn tmemCreateFromMemory(
        t: *mut TransferMemory,
        buf: *mut ctypes::c_void,
        size: usize,
        perm: Permission,
    ) -> Result;
}
extern "C" {
    /// @brief Loads a transfer memory object coming from a remote process.
    /// @param t Transfer memory information structure which will be filled in.
    /// @param handle Handle of the transfer memory object.
    /// @param size Size of the transfer memory object that is being loaded.
    /// @param perm Permissions which the transfer memory is expected to have in the process that owns the memory.
    /// @warning This is a privileged operation; in normal circumstances applications shouldn't use this function.
    pub fn tmemLoadRemote(t: *mut TransferMemory, handle: Handle, size: usize, perm: Permission);
}
extern "C" {
    /// @brief Maps a transfer memory object.
    /// @param t Transfer memory information structure.
    /// @return Result code.
    /// @warning This is a privileged operation; in normal circumstances applications cannot use this function.
    pub fn tmemMap(t: *mut TransferMemory) -> Result;
}
extern "C" {
    /// @brief Unmaps a transfer memory object.
    /// @param t Transfer memory information structure.
    /// @return Result code.
    /// @warning This is a privileged operation; in normal circumstances applications cannot use this function.
    pub fn tmemUnmap(t: *mut TransferMemory) -> Result;
}
extern "C" {
    /// @brief Frees up resources used by a transfer memory object, unmapping and closing handles, etc.
    /// @param t Transfer memory information structure.
    /// @return Result code.
    pub fn tmemClose(t: *mut TransferMemory) -> Result;
}
/// Shared memory information structure.
#[repr(C)]
pub struct SharedMemory {
    /// < Kernel object handle.
    pub handle: Handle,
    /// < Size of the shared memory object.
    pub size: usize,
    /// < Permissions.
    pub perm: Permission,
    /// < Address to which the shared memory object is mapped.
    pub map_addr: *mut ctypes::c_void,
}
#[test]
fn bindgen_test_layout_SharedMemory() {
    assert_eq!(
        ::core::mem::size_of::<SharedMemory>(),
        32usize,
        concat!("Size of: ", stringify!(SharedMemory))
    );
    assert_eq!(
        ::core::mem::align_of::<SharedMemory>(),
        8usize,
        concat!("Alignment of ", stringify!(SharedMemory))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SharedMemory>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SharedMemory),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SharedMemory>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SharedMemory),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SharedMemory>())).perm as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SharedMemory),
            "::",
            stringify!(perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SharedMemory>())).map_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SharedMemory),
            "::",
            stringify!(map_addr)
        )
    );
}
extern "C" {
    /// @brief Creates a shared memory object.
    /// @param s Shared memory information structure which will be filled in.
    /// @param size Size of the shared memory object to create.
    /// @param local_perm Permissions with which the shared memory object will be mapped in the local process.
    /// @param remote_perm Permissions with which the shared memory object will be mapped in the remote process (can be Perm_DontCare).
    /// @return Result code.
    /// @warning This is a privileged operation; in normal circumstances applications cannot use this function.
    pub fn shmemCreate(
        s: *mut SharedMemory,
        size: usize,
        local_perm: Permission,
        remote_perm: Permission,
    ) -> Result;
}
extern "C" {
    /// @brief Loads a shared memory object coming from a remote process.
    /// @param s Shared memory information structure which will be filled in.
    /// @param handle Handle of the shared memory object.
    /// @param size Size of the shared memory object that is being loaded.
    /// @param perm Permissions with which the shared memory object will be mapped in the local process.
    pub fn shmemLoadRemote(s: *mut SharedMemory, handle: Handle, size: usize, perm: Permission);
}
extern "C" {
    /// @brief Maps a shared memory object.
    /// @param s Shared memory information structure.
    /// @return Result code.
    pub fn shmemMap(s: *mut SharedMemory) -> Result;
}
extern "C" {
    /// @brief Unmaps a shared memory object.
    /// @param s Shared memory information structure.
    /// @return Result code.
    pub fn shmemUnmap(s: *mut SharedMemory) -> Result;
}
extern "C" {
    /// @brief Frees up resources used by a shared memory object, unmapping and closing handles, etc.
    /// @param s Shared memory information structure.
    /// @return Result code.
    pub fn shmemClose(s: *mut SharedMemory) -> Result;
}
#[repr(C)]
pub struct Event {
    pub revent: Handle,
    pub wevent: Handle,
    pub autoclear: bool,
}
#[test]
fn bindgen_test_layout_Event() {
    assert_eq!(
        ::core::mem::size_of::<Event>(),
        12usize,
        concat!("Size of: ", stringify!(Event))
    );
    assert_eq!(
        ::core::mem::align_of::<Event>(),
        4usize,
        concat!("Alignment of ", stringify!(Event))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Event>())).revent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Event),
            "::",
            stringify!(revent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Event>())).wevent as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Event),
            "::",
            stringify!(wevent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Event>())).autoclear as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Event),
            "::",
            stringify!(autoclear)
        )
    );
}
extern "C" {
    pub fn eventCreate(t: *mut Event, autoclear: bool) -> Result;
}
extern "C" {
    pub fn eventLoadRemote(t: *mut Event, handle: Handle, autoclear: bool);
}
extern "C" {
    pub fn eventClose(t: *mut Event);
}
extern "C" {
    pub fn eventWait(t: *mut Event, timeout: u64) -> Result;
}
extern "C" {
    pub fn eventFire(t: *mut Event) -> Result;
}
extern "C" {
    pub fn eventClear(t: *mut Event) -> Result;
}
/// User-mode event object.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UEvent {
    pub waitable: Waitable,
    pub signal: bool,
    pub auto_clear: bool,
}
#[test]
fn bindgen_test_layout_UEvent() {
    assert_eq!(
        ::core::mem::size_of::<UEvent>(),
        40usize,
        concat!("Size of: ", stringify!(UEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<UEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(UEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UEvent>())).waitable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UEvent),
            "::",
            stringify!(waitable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UEvent>())).signal as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UEvent),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UEvent>())).auto_clear as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(UEvent),
            "::",
            stringify!(auto_clear)
        )
    );
}
extern "C" {
    /// @brief Creates a user-mode event.
    /// @param[out] e UEvent object.
    /// @param[in] auto_clear Whether to automatically clear the event.
    /// @note It is safe to wait on this event with several threads simultaneously.
    /// @note If more than one thread is listening on it, at least one thread will get the signal. No other guarantees.
    pub fn ueventCreate(e: *mut UEvent, auto_clear: bool);
}
extern "C" {
    /// @brief Clears the event signal.
    /// @param[in] e UEvent object.
    pub fn ueventClear(e: *mut UEvent);
}
extern "C" {
    /// @brief Signals the event.
    /// @param[in] e UEvent object.
    pub fn ueventSignal(e: *mut UEvent);
}
/// < Timers of this kind fire once and then stop automatically.
pub const TimerType_TimerType_OneShot: TimerType = 0;
/// < Timers of this kind fire periodically.
pub const TimerType_TimerType_Repeating: TimerType = 1;
/// Valid types for a user-mode timer.
pub type TimerType = u32;
/// User-mode timer object.
#[repr(C)]
pub struct UTimer {
    pub waitable: Waitable,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub next_tick: u64,
    pub interval: u64,
}
#[test]
fn bindgen_test_layout_UTimer() {
    assert_eq!(
        ::core::mem::size_of::<UTimer>(),
        56usize,
        concat!("Size of: ", stringify!(UTimer))
    );
    assert_eq!(
        ::core::mem::align_of::<UTimer>(),
        8usize,
        concat!("Alignment of ", stringify!(UTimer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UTimer>())).waitable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UTimer),
            "::",
            stringify!(waitable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UTimer>())).next_tick as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UTimer),
            "::",
            stringify!(next_tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UTimer>())).interval as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(UTimer),
            "::",
            stringify!(interval)
        )
    );
}
impl UTimer {
    #[inline]
    pub fn type_(&self) -> TimerType {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: TimerType) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn started(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_started(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: TimerType,
        started: bool,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let started: u8 = unsafe { ::core::mem::transmute(started) };
            started as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    /// @brief Creates a user-mode timer.
    /// @param[out] t UTimer object.
    /// @param[in] interval Interval (in nanoseconds).
    /// @param[in] type Type of timer to create (see \ref TimerType).
    /// @note The timer is stopped when it is created. Use \ref utimerStart to start it.
    /// @note It is safe to wait on this timer with several threads simultaneously.
    /// @note If more than one thread is listening on it, at least one thread will get the signal. No other guarantees.
    /// @note For a repeating timer: If the timer triggers twice before you wait on it, you will only get one signal.
    pub fn utimerCreate(t: *mut UTimer, interval: u64, type_: TimerType);
}
extern "C" {
    /// @brief Starts the timer.
    /// @param[in] t UTimer object.
    pub fn utimerStart(t: *mut UTimer);
}
extern "C" {
    /// @brief Stops the timer.
    /// @param[in] t UTimer object.
    pub fn utimerStop(t: *mut UTimer);
}
/// Condition variable.
pub type CondVar = u32;
extern "C" {
    /// @brief Waits on a condition variable with a timeout.
    /// @param[in] c Condition variable object.
    /// @param[in] m Mutex object to use inside the condition variable.
    /// @param[in] timeout Timeout in nanoseconds.
    /// @return Result code (0xEA01 on timeout).
    /// @remark On function return, the underlying mutex is acquired.
    pub fn condvarWaitTimeout(c: *mut CondVar, m: *mut Mutex, timeout: u64) -> Result;
}
/// Read/write lock structure.
#[repr(C)]
pub struct RwLock {
    pub mutex: Mutex,
    pub condvar_readers: CondVar,
    pub condvar_writer: CondVar,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_RwLock() {
    assert_eq!(
        ::core::mem::size_of::<RwLock>(),
        16usize,
        concat!("Size of: ", stringify!(RwLock))
    );
    assert_eq!(
        ::core::mem::align_of::<RwLock>(),
        4usize,
        concat!("Alignment of ", stringify!(RwLock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RwLock>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RwLock),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RwLock>())).condvar_readers as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RwLock),
            "::",
            stringify!(condvar_readers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RwLock>())).condvar_writer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RwLock),
            "::",
            stringify!(condvar_writer)
        )
    );
}
impl RwLock {
    #[inline]
    pub fn readers(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_readers(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn writer(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_writer(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(readers: u32, writer: bool) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let readers: u32 = unsafe { ::core::mem::transmute(readers) };
            readers as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let writer: u8 = unsafe { ::core::mem::transmute(writer) };
            writer as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    /// @brief Initializes the read/write lock.
    /// @param r Read/write lock object.
    pub fn rwlockInit(r: *mut RwLock);
}
extern "C" {
    /// @brief Locks the read/write lock for reading.
    /// @param r Read/write lock object.
    pub fn rwlockReadLock(r: *mut RwLock);
}
extern "C" {
    /// @brief Unlocks the read/write lock for reading.
    /// @param r Read/write lock object.
    pub fn rwlockReadUnlock(r: *mut RwLock);
}
extern "C" {
    /// @brief Locks the read/write lock for writing.
    /// @param r Read/write lock object.
    pub fn rwlockWriteLock(r: *mut RwLock);
}
extern "C" {
    /// @brief Unlocks the read/write lock for writing.
    /// @param r Read/write lock object.
    pub fn rwlockWriteUnlock(r: *mut RwLock);
}
/// Thread information structure.
#[repr(C)]
pub struct Thread {
    /// < Thread handle.
    pub handle: Handle,
    /// < Pointer to stack memory.
    pub stack_mem: *mut ctypes::c_void,
    /// < Pointer to stack memory mirror.
    pub stack_mirror: *mut ctypes::c_void,
    /// < Stack size.
    pub stack_sz: usize,
    pub tls_array: *mut *mut ctypes::c_void,
    pub next: *mut Thread,
    pub prev_next: *mut *mut Thread,
}
#[test]
fn bindgen_test_layout_Thread() {
    assert_eq!(
        ::core::mem::size_of::<Thread>(),
        56usize,
        concat!("Size of: ", stringify!(Thread))
    );
    assert_eq!(
        ::core::mem::align_of::<Thread>(),
        8usize,
        concat!("Alignment of ", stringify!(Thread))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Thread>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Thread>())).stack_mem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(stack_mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Thread>())).stack_mirror as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(stack_mirror)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Thread>())).stack_sz as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(stack_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Thread>())).tls_array as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(tls_array)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Thread>())).next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Thread>())).prev_next as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(prev_next)
        )
    );
}
extern "C" {
    /// @brief Creates a thread.
    /// @param t Thread information structure which will be filled in.
    /// @param entry Entrypoint of the thread.
    /// @param arg Argument to pass to the entrypoint.
    /// @param stack_sz Stack size (rounded up to page alignment).
    /// @param prio Thread priority (0x00~0x3F); 0x2C is the usual priority of the main thread, 0x3B is a special priority on cores 0..2 that enables preemptive multithreading (0x3F on core 3).
    /// @param cpuid ID of the core on which to create the thread (0~3); or -2 to use the default core for the current process.
    /// @return Result code.
    pub fn threadCreate(
        t: *mut Thread,
        entry: ThreadFunc,
        arg: *mut ctypes::c_void,
        stack_sz: usize,
        prio: ctypes::c_int,
        cpuid: ctypes::c_int,
    ) -> Result;
}
extern "C" {
    /// @brief Starts the execution of a thread.
    /// @param t Thread information structure.
    /// @return Result code.
    pub fn threadStart(t: *mut Thread) -> Result;
}
extern "C" {
    /// @brief Exits the current thread immediately.
    pub fn threadExit();
}
extern "C" {
    /// @brief Waits for a thread to finish executing.
    /// @param t Thread information structure.
    /// @return Result code.
    pub fn threadWaitForExit(t: *mut Thread) -> Result;
}
extern "C" {
    /// @brief Frees up resources associated with a thread.
    /// @param t Thread information structure.
    /// @return Result code.
    pub fn threadClose(t: *mut Thread) -> Result;
}
extern "C" {
    /// @brief Pauses the execution of a thread.
    /// @param t Thread information structure.
    /// @return Result code.
    pub fn threadPause(t: *mut Thread) -> Result;
}
extern "C" {
    /// @brief Resumes the execution of a thread, after having been paused.
    /// @param t Thread information structure.
    /// @return Result code.
    pub fn threadResume(t: *mut Thread) -> Result;
}
extern "C" {
    /// @brief Dumps the registers of a thread paused by @ref threadPause (register groups: all).
    /// @param[out] ctx Output thread context (register dump).
    /// @param t Thread information structure.
    /// @return Result code.
    /// @warning Official kernel will not dump x0..x18 if the thread is currently executing a system call, and prior to 6.0.0 doesn't dump TPIDR_EL0.
    pub fn threadDumpContext(ctx: *mut ThreadContext, t: *mut Thread) -> Result;
}
extern "C" {
    /// @brief Gets the raw handle to the current thread.
    /// @return The current thread's handle.
    pub fn threadGetCurHandle() -> Handle;
}
extern "C" {
    /// @brief Allocates a TLS slot.
    /// @param destructor Function to run automatically when a thread exits.
    /// @return TLS slot ID on success, or a negative value on failure.
    pub fn threadTlsAlloc(
        destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ctypes::c_void)>,
    ) -> s32;
}
extern "C" {
    /// @brief Retrieves the value stored in a TLS slot.
    /// @param slot_id TLS slot ID.
    /// @return Value.
    pub fn threadTlsGet(slot_id: s32) -> *mut ctypes::c_void;
}
extern "C" {
    /// @brief Stores the specified value into a TLS slot.
    /// @param slot_id TLS slot ID.
    /// @param value Value.
    pub fn threadTlsSet(slot_id: s32, value: *mut ctypes::c_void);
}
extern "C" {
    /// @brief Frees a TLS slot.
    /// @param slot_id TLS slot ID.
    pub fn threadTlsFree(slot_id: s32);
}
/// Semaphore structure.
#[repr(C)]
pub struct Semaphore {
    /// < Condition variable object.
    pub condvar: CondVar,
    /// < Mutex object.
    pub mutex: Mutex,
    /// < Internal counter.
    pub count: u64,
}
#[test]
fn bindgen_test_layout_Semaphore() {
    assert_eq!(
        ::core::mem::size_of::<Semaphore>(),
        16usize,
        concat!("Size of: ", stringify!(Semaphore))
    );
    assert_eq!(
        ::core::mem::align_of::<Semaphore>(),
        8usize,
        concat!("Alignment of ", stringify!(Semaphore))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Semaphore>())).condvar as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Semaphore),
            "::",
            stringify!(condvar)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Semaphore>())).mutex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Semaphore),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Semaphore>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Semaphore),
            "::",
            stringify!(count)
        )
    );
}
extern "C" {
    /// @brief Initializes a semaphore and its internal counter.
    /// @param s Semaphore object.
    /// @param initial_count initial value for internal counter (typically the # of free resources).
    pub fn semaphoreInit(s: *mut Semaphore, initial_count: u64);
}
extern "C" {
    /// @brief Increments the Semaphore to allow other threads to continue.
    /// @param s Semaphore object.
    pub fn semaphoreSignal(s: *mut Semaphore);
}
extern "C" {
    /// @brief Decrements Semaphore and waits if 0.
    /// @param s Semaphore object.
    pub fn semaphoreWait(s: *mut Semaphore);
}
extern "C" {
    /// @brief Attempts to get lock without waiting.
    /// @param s Semaphore object.
    /// @return true if no wait and successful lock, false otherwise.
    pub fn semaphoreTryWait(s: *mut Semaphore) -> bool;
}
extern "C" {
    /// @brief Reserves a slice of general purpose address space.
    /// @param size The size of the slice of address space that will be reserved (rounded up to page alignment).
    /// @return Pointer to the slice of address space, or NULL on failure.
    pub fn virtmemReserve(size: usize) -> *mut ctypes::c_void;
}
extern "C" {
    /// @brief Relinquishes a slice of address space reserved with virtmemReserve (currently no-op).
    /// @param addr Pointer to the slice.
    /// @param size Size of the slice.
    pub fn virtmemFree(addr: *mut ctypes::c_void, size: usize);
}
extern "C" {
    /// @brief Reserves a slice of address space inside the stack memory mapping region (for use with svcMapMemory).
    /// @param size The size of the slice of address space that will be reserved (rounded up to page alignment).
    /// @return Pointer to the slice of address space, or NULL on failure.
    pub fn virtmemReserveStack(size: usize) -> *mut ctypes::c_void;
}
extern "C" {
    /// @brief Relinquishes a slice of address space reserved with virtmemReserveStack (currently no-op).
    /// @param addr Pointer to the slice.
    /// @param size Size of the slice.
    pub fn virtmemFreeStack(addr: *mut ctypes::c_void, size: usize);
}
extern "C" {
    /// Returns the kernel version that can be detected by checking kernel capabilities. This only goes from 1 (representing 1.0.0) up to 6 (representing 6.0.0 and above). Generally, \ref hosversionGet should be used instead of this function.
    pub fn detectKernelVersion() -> ctypes::c_int;
}
extern "C" {
    /// Returns true if the process has a debugger attached.
    pub fn detectDebugger() -> bool;
}
extern "C" {
    /// Returns true if the kernel is patched to allow self-process-jit.
    pub fn detectJitKernelPatch() -> bool;
}
extern "C" {
    /// After this has been called, libnx will ignore the self-process-jit kernel patch. For testing purposes only.
    pub fn detectIgnoreJitKernelPatch();
}
extern "C" {
    /// @brief Fills a buffer with random data.
    /// @param buf Pointer to the buffer.
    /// @param len Size of the buffer in bytes.
    pub fn randomGet(buf: *mut ctypes::c_void, len: usize);
}
extern "C" {
    /// @brief Returns a random 64-bit value.
    /// @return Random value.
    pub fn randomGet64() -> u64;
}
/// < JIT supported using svcSetProcessMemoryPermission
pub const JitType_JitType_CodeMemory: JitType = 0;
/// < JIT supported using 4.0.0+ code-memory syscalls (this isn't usable on 5.0.0+ so JitType_CodeMemory is used instead).
pub const JitType_JitType_JitMemory: JitType = 1;
/// JIT implementation type.
pub type JitType = u32;
/// JIT buffer object.
#[repr(C)]
pub struct Jit {
    pub type_: JitType,
    pub size: usize,
    pub src_addr: *mut ctypes::c_void,
    pub rx_addr: *mut ctypes::c_void,
    pub rw_addr: *mut ctypes::c_void,
    pub is_executable: bool,
    pub handle: Handle,
}
#[test]
fn bindgen_test_layout_Jit() {
    assert_eq!(
        ::core::mem::size_of::<Jit>(),
        48usize,
        concat!("Size of: ", stringify!(Jit))
    );
    assert_eq!(
        ::core::mem::align_of::<Jit>(),
        8usize,
        concat!("Alignment of ", stringify!(Jit))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Jit>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Jit),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Jit>())).size as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Jit), "::", stringify!(size))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Jit>())).src_addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Jit),
            "::",
            stringify!(src_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Jit>())).rx_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Jit),
            "::",
            stringify!(rx_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Jit>())).rw_addr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Jit),
            "::",
            stringify!(rw_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Jit>())).is_executable as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Jit),
            "::",
            stringify!(is_executable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Jit>())).handle as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Jit),
            "::",
            stringify!(handle)
        )
    );
}
extern "C" {
    /// @brief Creates a JIT buffer.
    /// @param j JIT buffer.
    /// @param size Size of the JIT buffer.
    /// @return Result code.
    pub fn jitCreate(j: *mut Jit, size: usize) -> Result;
}
extern "C" {
    /// @brief Transition a JIT buffer to have writable permission.
    /// @param j JIT buffer.
    /// @return Result code.
    pub fn jitTransitionToWritable(j: *mut Jit) -> Result;
}
extern "C" {
    /// @brief Transition a JIT buffer to have executable permission.
    /// @param j JIT buffer.
    /// @return Result code.
    pub fn jitTransitionToExecutable(j: *mut Jit) -> Result;
}
extern "C" {
    /// @brief Destroys a JIT buffer.
    /// @param j JIT buffer.
    /// @return Result code.
    pub fn jitClose(j: *mut Jit) -> Result;
}
extern "C" {
    /// @brief Gets the address of the writable memory alias of a JIT buffer.
    /// @param j JIT buffer.
    /// @return Pointer to alias of the JIT buffer that can be written to.
    pub fn jitGetRwAddr(j: *mut Jit) -> *mut ctypes::c_void;
}
extern "C" {
    /// @brief Gets the address of the executable memory alias of a JIT buffer.
    /// @param j JIT buffer.
    /// @return Pointer to alias of the JIT buffer that can be executed.
    pub fn jitGetRxAddr(j: *mut Jit) -> *mut ctypes::c_void;
}
/// < Regular buffer.
pub const BufferType_BufferType_Normal: BufferType = 0;
/// < Allows ProcessMemory and shared TransferMemory.
pub const BufferType_BufferType_Type1: BufferType = 1;
pub const BufferType_BufferType_Invalid: BufferType = 2;
/// < Same as Type1 except remote process is not allowed to use device-mapping.
pub const BufferType_BufferType_Type3: BufferType = 3;
pub type BufferType = u32;
pub const BufferDirection_BufferDirection_Send: BufferDirection = 0;
pub const BufferDirection_BufferDirection_Recv: BufferDirection = 1;
pub const BufferDirection_BufferDirection_Exch: BufferDirection = 2;
pub type BufferDirection = u32;
pub const IpcCommandType_IpcCommandType_Invalid: IpcCommandType = 0;
pub const IpcCommandType_IpcCommandType_LegacyRequest: IpcCommandType = 1;
pub const IpcCommandType_IpcCommandType_Close: IpcCommandType = 2;
pub const IpcCommandType_IpcCommandType_LegacyControl: IpcCommandType = 3;
pub const IpcCommandType_IpcCommandType_Request: IpcCommandType = 4;
pub const IpcCommandType_IpcCommandType_Control: IpcCommandType = 5;
pub const IpcCommandType_IpcCommandType_RequestWithContext: IpcCommandType = 6;
pub const IpcCommandType_IpcCommandType_ControlWithContext: IpcCommandType = 7;
pub type IpcCommandType = u32;
pub const DomainMessageType_DomainMessageType_Invalid: DomainMessageType = 0;
pub const DomainMessageType_DomainMessageType_SendMessage: DomainMessageType = 1;
pub const DomainMessageType_DomainMessageType_Close: DomainMessageType = 2;
pub type DomainMessageType = u32;
/// IPC domain message header.
#[repr(C)]
pub struct DomainMessageHeader {
    pub Type: u8,
    pub NumObjectIds: u8,
    pub Length: u16,
    pub ThisObjectId: u32,
    pub Pad: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_DomainMessageHeader() {
    assert_eq!(
        ::core::mem::size_of::<DomainMessageHeader>(),
        16usize,
        concat!("Size of: ", stringify!(DomainMessageHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<DomainMessageHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(DomainMessageHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DomainMessageHeader>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DomainMessageHeader),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DomainMessageHeader>())).NumObjectIds as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(DomainMessageHeader),
            "::",
            stringify!(NumObjectIds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DomainMessageHeader>())).Length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(DomainMessageHeader),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DomainMessageHeader>())).ThisObjectId as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DomainMessageHeader),
            "::",
            stringify!(ThisObjectId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DomainMessageHeader>())).Pad as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DomainMessageHeader),
            "::",
            stringify!(Pad)
        )
    );
}
/// IPC domain response header.
#[repr(C)]
pub struct DomainResponseHeader {
    pub NumObjectIds: u32,
    pub Pad: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_DomainResponseHeader() {
    assert_eq!(
        ::core::mem::size_of::<DomainResponseHeader>(),
        16usize,
        concat!("Size of: ", stringify!(DomainResponseHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<DomainResponseHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(DomainResponseHeader))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DomainResponseHeader>())).NumObjectIds as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DomainResponseHeader),
            "::",
            stringify!(NumObjectIds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DomainResponseHeader>())).Pad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DomainResponseHeader),
            "::",
            stringify!(Pad)
        )
    );
}
#[repr(C)]
pub struct IpcCommand {
    pub NumSend: usize,
    pub NumRecv: usize,
    pub NumExch: usize,
    pub Buffers: [*const ctypes::c_void; 8usize],
    pub BufferSizes: [usize; 8usize],
    pub BufferTypes: [BufferType; 8usize],
    pub NumStaticIn: usize,
    pub NumStaticOut: usize,
    pub Statics: [*const ctypes::c_void; 8usize],
    pub StaticSizes: [usize; 8usize],
    pub StaticIndices: [u8; 8usize],
    pub SendPid: bool,
    pub NumHandlesCopy: usize,
    pub NumHandlesMove: usize,
    pub Handles: [Handle; 8usize],
    pub NumObjectIds: usize,
    pub ObjectIds: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_IpcCommand() {
    assert_eq!(
        ::core::mem::size_of::<IpcCommand>(),
        432usize,
        concat!("Size of: ", stringify!(IpcCommand))
    );
    assert_eq!(
        ::core::mem::align_of::<IpcCommand>(),
        8usize,
        concat!("Alignment of ", stringify!(IpcCommand))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).NumSend as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(NumSend)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).NumRecv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(NumRecv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).NumExch as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(NumExch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).Buffers as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(Buffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).BufferSizes as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(BufferSizes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).BufferTypes as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(BufferTypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).NumStaticIn as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(NumStaticIn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).NumStaticOut as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(NumStaticOut)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).Statics as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(Statics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).StaticSizes as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(StaticSizes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).StaticIndices as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(StaticIndices)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).SendPid as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(SendPid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).NumHandlesCopy as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(NumHandlesCopy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).NumHandlesMove as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(NumHandlesMove)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).Handles as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(Handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).NumObjectIds as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(NumObjectIds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).ObjectIds as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(ObjectIds)
        )
    );
}
/// IPC buffer descriptor.
#[repr(C)]
pub struct IpcBufferDescriptor {
    /// < Size of the buffer.
    pub Size: u32,
    /// < Lower 32-bits of the address of the buffer
    pub Addr: u32,
    /// < Packed data (including higher bits of the address)
    pub Packed: u32,
}
#[test]
fn bindgen_test_layout_IpcBufferDescriptor() {
    assert_eq!(
        ::core::mem::size_of::<IpcBufferDescriptor>(),
        12usize,
        concat!("Size of: ", stringify!(IpcBufferDescriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<IpcBufferDescriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(IpcBufferDescriptor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcBufferDescriptor>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcBufferDescriptor),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcBufferDescriptor>())).Addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcBufferDescriptor),
            "::",
            stringify!(Addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcBufferDescriptor>())).Packed as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcBufferDescriptor),
            "::",
            stringify!(Packed)
        )
    );
}
/// IPC static send-buffer descriptor.
#[repr(C)]
pub struct IpcStaticSendDescriptor {
    /// < Packed data (including higher bits of the address)
    pub Packed: u32,
    /// < Lower 32-bits of the address
    pub Addr: u32,
}
#[test]
fn bindgen_test_layout_IpcStaticSendDescriptor() {
    assert_eq!(
        ::core::mem::size_of::<IpcStaticSendDescriptor>(),
        8usize,
        concat!("Size of: ", stringify!(IpcStaticSendDescriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<IpcStaticSendDescriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(IpcStaticSendDescriptor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcStaticSendDescriptor>())).Packed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcStaticSendDescriptor),
            "::",
            stringify!(Packed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcStaticSendDescriptor>())).Addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcStaticSendDescriptor),
            "::",
            stringify!(Addr)
        )
    );
}
/// IPC static receive-buffer descriptor.
#[repr(C)]
pub struct IpcStaticRecvDescriptor {
    /// < Lower 32-bits of the address of the buffer
    pub Addr: u32,
    /// < Packed data (including higher bits of the address)
    pub Packed: u32,
}
#[test]
fn bindgen_test_layout_IpcStaticRecvDescriptor() {
    assert_eq!(
        ::core::mem::size_of::<IpcStaticRecvDescriptor>(),
        8usize,
        concat!("Size of: ", stringify!(IpcStaticRecvDescriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<IpcStaticRecvDescriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(IpcStaticRecvDescriptor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcStaticRecvDescriptor>())).Addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcStaticRecvDescriptor),
            "::",
            stringify!(Addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcStaticRecvDescriptor>())).Packed as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcStaticRecvDescriptor),
            "::",
            stringify!(Packed)
        )
    );
}
/// IPC parsed command (response) structure.
#[repr(C)]
pub struct IpcParsedCommand {
    /// < Type of the command
    pub CommandType: IpcCommandType,
    /// < true if the 'Pid' field is filled out.
    pub HasPid: bool,
    /// < PID included in the response (only if HasPid is true)
    pub Pid: u64,
    /// < Number of handles copied.
    pub NumHandles: usize,
    /// < Handles.
    pub Handles: [Handle; 8usize],
    /// < true if the handle was moved, false if it was copied.
    pub WasHandleCopied: [bool; 8usize],
    /// < true if the the message is a Domain message.
    pub IsDomainRequest: bool,
    /// < Type of the domain message.
    pub InMessageType: DomainMessageType,
    /// < Size of rawdata (for domain messages).
    pub InMessageLength: u32,
    /// < Object ID to call the command on (for domain messages).
    pub InThisObjectId: u32,
    /// < Number of object IDs (for domain messages).
    pub InNumObjectIds: usize,
    /// < Object IDs (for domain messages).
    pub InObjectIds: [u32; 8usize],
    /// < true if the the message is a Domain response.
    pub IsDomainResponse: bool,
    /// < Number of object IDs (for domain responses).
    pub OutNumObjectIds: usize,
    /// < Object IDs (for domain responses).
    pub OutObjectIds: [u32; 8usize],
    /// < Number of buffers in the response.
    pub NumBuffers: usize,
    /// < Pointers to the buffers.
    pub Buffers: [*mut ctypes::c_void; 8usize],
    /// < Sizes of the buffers.
    pub BufferSizes: [usize; 8usize],
    /// < Types of the buffers.
    pub BufferTypes: [BufferType; 8usize],
    /// < Direction of each buffer.
    pub BufferDirections: [BufferDirection; 8usize],
    /// < Number of statics in the response.
    pub NumStatics: usize,
    /// < Pointers to the statics.
    pub Statics: [*mut ctypes::c_void; 8usize],
    /// < Sizes of the statics.
    pub StaticSizes: [usize; 8usize],
    /// < Indices of the statics.
    pub StaticIndices: [u8; 8usize],
    /// < Number of output statics available in the response.
    pub NumStaticsOut: usize,
    /// < Pointer to the raw embedded data structure in the response.
    pub Raw: *mut ctypes::c_void,
    /// < Pointer to the raw embedded data structure, without padding.
    pub RawWithoutPadding: *mut ctypes::c_void,
    /// < Size of the raw embedded data.
    pub RawSize: usize,
}
#[test]
fn bindgen_test_layout_IpcParsedCommand() {
    assert_eq!(
        ::core::mem::size_of::<IpcParsedCommand>(),
        544usize,
        concat!("Size of: ", stringify!(IpcParsedCommand))
    );
    assert_eq!(
        ::core::mem::align_of::<IpcParsedCommand>(),
        8usize,
        concat!("Alignment of ", stringify!(IpcParsedCommand))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).CommandType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(CommandType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).HasPid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(HasPid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).Pid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(Pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).NumHandles as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(NumHandles)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).Handles as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(Handles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IpcParsedCommand>())).WasHandleCopied as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(WasHandleCopied)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IpcParsedCommand>())).IsDomainRequest as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(IsDomainRequest)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).InMessageType as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(InMessageType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IpcParsedCommand>())).InMessageLength as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(InMessageLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IpcParsedCommand>())).InThisObjectId as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(InThisObjectId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IpcParsedCommand>())).InNumObjectIds as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(InNumObjectIds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).InObjectIds as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(InObjectIds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IpcParsedCommand>())).IsDomainResponse as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(IsDomainResponse)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IpcParsedCommand>())).OutNumObjectIds as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(OutNumObjectIds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).OutObjectIds as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(OutObjectIds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).NumBuffers as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(NumBuffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).Buffers as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(Buffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).BufferSizes as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(BufferSizes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).BufferTypes as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(BufferTypes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IpcParsedCommand>())).BufferDirections as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(BufferDirections)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).NumStatics as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(NumStatics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).Statics as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(Statics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).StaticSizes as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(StaticSizes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).StaticIndices as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(StaticIndices)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).NumStaticsOut as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(NumStaticsOut)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).Raw as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(Raw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IpcParsedCommand>())).RawWithoutPadding as *const _ as usize
        },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(RawWithoutPadding)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).RawSize as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(RawSize)
        )
    );
}
/// Barrier structure.
#[repr(C)]
pub struct Barrier {
    /// < Number of threads to reach the barrier.
    pub count: u64,
    /// < Number of threads to wait on.
    pub total: u64,
    pub mutex: Mutex,
    pub condvar: CondVar,
}
#[test]
fn bindgen_test_layout_Barrier() {
    assert_eq!(
        ::core::mem::size_of::<Barrier>(),
        24usize,
        concat!("Size of: ", stringify!(Barrier))
    );
    assert_eq!(
        ::core::mem::align_of::<Barrier>(),
        8usize,
        concat!("Alignment of ", stringify!(Barrier))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Barrier>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Barrier),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Barrier>())).total as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Barrier),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Barrier>())).mutex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Barrier),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Barrier>())).condvar as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Barrier),
            "::",
            stringify!(condvar)
        )
    );
}
extern "C" {
    /// @brief Initializes a barrier and the number of threads to wait on.
    /// @param b Barrier object.
    /// @param thread_count Initial value for the number of threads the barrier must wait for.
    pub fn barrierInit(b: *mut Barrier, thread_count: u64);
}
extern "C" {
    /// @brief Forces threads to wait until all threads have called barrierWait.
    /// @param b Barrier object.
    pub fn barrierWait(b: *mut Barrier);
}
/// < Uninitialized service.
pub const ServiceType_ServiceType_Uninitialized: ServiceType = 0;
/// < Normal service.
pub const ServiceType_ServiceType_Normal: ServiceType = 1;
/// < Domain.
pub const ServiceType_ServiceType_Domain: ServiceType = 2;
/// < Domain subservice;
pub const ServiceType_ServiceType_DomainSubservice: ServiceType = 3;
/// < Service overriden in the homebrew environment.
pub const ServiceType_ServiceType_Override: ServiceType = 4;
/// Service type.
pub type ServiceType = u32;
/// Service object structure.
#[repr(C)]
pub struct Service {
    pub handle: Handle,
    pub object_id: u32,
    pub type_: ServiceType,
}
#[test]
fn bindgen_test_layout_Service() {
    assert_eq!(
        ::core::mem::size_of::<Service>(),
        12usize,
        concat!("Size of: ", stringify!(Service))
    );
    assert_eq!(
        ::core::mem::align_of::<Service>(),
        4usize,
        concat!("Alignment of ", stringify!(Service))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Service>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Service),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Service>())).object_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Service),
            "::",
            stringify!(object_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Service>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Service),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    /// @brief Initializes SM.
    /// @return Result code.
    /// @note This function is already called in the default application startup code (before main() is called).
    pub fn smInitialize() -> Result;
}
extern "C" {
    /// @brief Uninitializes SM.
    /// @return Result code.
    /// @note This function is already handled in the default application exit code (after main() returns).
    pub fn smExit();
}
extern "C" {
    /// @brief Requests a service from SM.
    /// @param[out] service_out Service structure which will be filled in.
    /// @param[in] name Name of the service to request.
    /// @return Result code.
    pub fn smGetService(service_out: *mut Service, name: *const ctypes::c_char) -> Result;
}
extern "C" {
    /// @brief Requests a service from SM, as an IPC session handle directly
    /// @param[out] handle_out Variable containing IPC session handle.
    /// @param[in] name Name of the service to request.
    /// @return Result code.
    pub fn smGetServiceOriginal(handle_out: *mut Handle, name: u64) -> Result;
}
extern "C" {
    /// @brief Retrieves an overriden service in the homebrew environment.
    /// @param[in] name Name of the service to request (as 64-bit integer).
    /// @return IPC session handle.
    pub fn smGetServiceOverride(name: u64) -> Handle;
}
extern "C" {
    /// @brief Creates and registers a new service within SM.
    /// @param[out] handle_out Variable containing IPC port handle.
    /// @param[in] name Name of the service.
    /// @param[in] is_light "Is light"
    /// @param[in] max_sessions Maximum number of concurrent sessions that the service will accept.
    /// @return Result code.
    pub fn smRegisterService(
        handle_out: *mut Handle,
        name: *const ctypes::c_char,
        is_light: bool,
        max_sessions: ctypes::c_int,
    ) -> Result;
}
extern "C" {
    /// @brief Unregisters a previously registered service in SM.
    /// @param[in] name Name of the service.
    /// @return Result code.
    pub fn smUnregisterService(name: *const ctypes::c_char) -> Result;
}
extern "C" {
    /// @brief Check whether SM is initialized.
    /// @return true if initialized.
    pub fn smHasInitialized() -> bool;
}
extern "C" {
    /// @brief Encodes a service name as a 64-bit integer.
    /// @param[in] name Name of the service.
    /// @return Encoded name.
    pub fn smEncodeName(name: *const ctypes::c_char) -> u64;
}
extern "C" {
    /// @brief Overrides a service with a custom IPC service handle.
    /// @param[in] name Name of the service (as 64-bit integer).
    /// @param[in] handle IPC session handle.
    pub fn smAddOverrideHandle(name: u64, handle: Handle);
}
#[repr(C)]
pub struct FsFileSystem {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_FsFileSystem() {
    assert_eq!(
        ::core::mem::size_of::<FsFileSystem>(),
        12usize,
        concat!("Size of: ", stringify!(FsFileSystem))
    );
    assert_eq!(
        ::core::mem::align_of::<FsFileSystem>(),
        4usize,
        concat!("Alignment of ", stringify!(FsFileSystem))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsFileSystem>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FsFileSystem),
            "::",
            stringify!(s)
        )
    );
}
#[repr(C)]
pub struct FsFile {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_FsFile() {
    assert_eq!(
        ::core::mem::size_of::<FsFile>(),
        12usize,
        concat!("Size of: ", stringify!(FsFile))
    );
    assert_eq!(
        ::core::mem::align_of::<FsFile>(),
        4usize,
        concat!("Alignment of ", stringify!(FsFile))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsFile>())).s as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(FsFile), "::", stringify!(s))
    );
}
#[repr(C)]
pub struct FsDir {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_FsDir() {
    assert_eq!(
        ::core::mem::size_of::<FsDir>(),
        12usize,
        concat!("Size of: ", stringify!(FsDir))
    );
    assert_eq!(
        ::core::mem::align_of::<FsDir>(),
        4usize,
        concat!("Alignment of ", stringify!(FsDir))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsDir>())).s as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(FsDir), "::", stringify!(s))
    );
}
#[repr(C)]
pub struct FsStorage {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_FsStorage() {
    assert_eq!(
        ::core::mem::size_of::<FsStorage>(),
        12usize,
        concat!("Size of: ", stringify!(FsStorage))
    );
    assert_eq!(
        ::core::mem::align_of::<FsStorage>(),
        4usize,
        concat!("Alignment of ", stringify!(FsStorage))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsStorage>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FsStorage),
            "::",
            stringify!(s)
        )
    );
}
#[repr(C)]
pub struct FsSaveDataIterator {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_FsSaveDataIterator() {
    assert_eq!(
        ::core::mem::size_of::<FsSaveDataIterator>(),
        12usize,
        concat!("Size of: ", stringify!(FsSaveDataIterator))
    );
    assert_eq!(
        ::core::mem::align_of::<FsSaveDataIterator>(),
        4usize,
        concat!("Alignment of ", stringify!(FsSaveDataIterator))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSaveDataIterator>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSaveDataIterator),
            "::",
            stringify!(s)
        )
    );
}
#[repr(C)]
pub struct FsEventNotifier {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_FsEventNotifier() {
    assert_eq!(
        ::core::mem::size_of::<FsEventNotifier>(),
        12usize,
        concat!("Size of: ", stringify!(FsEventNotifier))
    );
    assert_eq!(
        ::core::mem::align_of::<FsEventNotifier>(),
        4usize,
        concat!("Alignment of ", stringify!(FsEventNotifier))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsEventNotifier>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FsEventNotifier),
            "::",
            stringify!(s)
        )
    );
}
#[repr(C)]
pub struct FsDeviceOperator {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_FsDeviceOperator() {
    assert_eq!(
        ::core::mem::size_of::<FsDeviceOperator>(),
        12usize,
        concat!("Size of: ", stringify!(FsDeviceOperator))
    );
    assert_eq!(
        ::core::mem::align_of::<FsDeviceOperator>(),
        4usize,
        concat!("Alignment of ", stringify!(FsDeviceOperator))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsDeviceOperator>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FsDeviceOperator),
            "::",
            stringify!(s)
        )
    );
}
/// Directory entry.
#[repr(C)]
pub struct FsDirectoryEntry {
    /// < Entry name.
    pub name: [ctypes::c_char; 769usize],
    pub pad: [u8; 3usize],
    /// < See FsEntryType.
    pub type_: s8,
    /// < ?
    pub pad2: [u8; 3usize],
    /// < File size.
    pub fileSize: u64,
}
#[test]
fn bindgen_test_layout_FsDirectoryEntry() {
    assert_eq!(
        ::core::mem::size_of::<FsDirectoryEntry>(),
        784usize,
        concat!("Size of: ", stringify!(FsDirectoryEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<FsDirectoryEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(FsDirectoryEntry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsDirectoryEntry>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FsDirectoryEntry),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsDirectoryEntry>())).pad as *const _ as usize },
        769usize,
        concat!(
            "Offset of field: ",
            stringify!(FsDirectoryEntry),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsDirectoryEntry>())).type_ as *const _ as usize },
        772usize,
        concat!(
            "Offset of field: ",
            stringify!(FsDirectoryEntry),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsDirectoryEntry>())).pad2 as *const _ as usize },
        773usize,
        concat!(
            "Offset of field: ",
            stringify!(FsDirectoryEntry),
            "::",
            stringify!(pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsDirectoryEntry>())).fileSize as *const _ as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(FsDirectoryEntry),
            "::",
            stringify!(fileSize)
        )
    );
}
/// Save Struct
#[repr(C)]
pub struct FsSave {
    /// < titleID of the savedata to access when accessing other titles' savedata via SaveData, otherwise FS_SAVEDATA_CURRENT_TITLEID.
    pub titleID: u64,
    pub __bindgen_anon_1: FsSave__bindgen_ty_1,
    /// < saveID, 0 for SaveData.
    pub saveID: u64,
    /// < See \ref FsSaveDataType.
    pub SaveDataType: u8,
    /// < Save data 'rank' or 'precedence'. 0 if this save data is considered the primary save data. 1 if it's considered the secondary save data.
    pub rank: u8,
    /// < Save data index.
    pub index: u16,
    /// < Padding.
    pub pad_x24: u32,
    /// < 0 for SystemSaveData/SaveData.
    pub unk_x28: u64,
    /// < 0 for SystemSaveData/SaveData.
    pub unk_x30: u64,
    /// < 0 for SystemSaveData/SaveData.
    pub unk_x38: u64,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union FsSave__bindgen_ty_1 {
    /// < userID of the user-specific savedata to access, otherwise FS_SAVEDATA_USERID_COMMONSAVE. See account.h.
    pub userID: u128,
    _bindgen_union_align: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_FsSave__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<FsSave__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(FsSave__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<FsSave__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(FsSave__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSave__bindgen_ty_1>())).userID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSave__bindgen_ty_1),
            "::",
            stringify!(userID)
        )
    );
}
#[test]
fn bindgen_test_layout_FsSave() {
    assert_eq!(
        ::core::mem::size_of::<FsSave>(),
        64usize,
        concat!("Size of: ", stringify!(FsSave))
    );
    assert_eq!(
        ::core::mem::align_of::<FsSave>(),
        8usize,
        concat!("Alignment of ", stringify!(FsSave))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSave>())).titleID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSave),
            "::",
            stringify!(titleID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSave>())).saveID as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSave),
            "::",
            stringify!(saveID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSave>())).SaveDataType as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSave),
            "::",
            stringify!(SaveDataType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSave>())).rank as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSave),
            "::",
            stringify!(rank)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSave>())).index as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSave),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSave>())).pad_x24 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSave),
            "::",
            stringify!(pad_x24)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSave>())).unk_x28 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSave),
            "::",
            stringify!(unk_x28)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSave>())).unk_x30 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSave),
            "::",
            stringify!(unk_x30)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSave>())).unk_x38 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSave),
            "::",
            stringify!(unk_x38)
        )
    );
}
#[repr(C)]
pub struct FsSaveDataInfo {
    pub saveID_unk: u64,
    /// < See \ref FsSaveDataSpaceId.
    pub SaveDataSpaceId: u8,
    /// < See \ref FsSaveDataType.
    pub SaveDataType: u8,
    /// < Padding.
    pub pad: [u8; 6usize],
    /// < See userID for \ref FsSave.
    pub userID: u128,
    /// < See saveID for \ref FsSave.
    pub saveID: u64,
    /// < titleID for FsSaveDataType_SaveData.
    pub titleID: u64,
    /// < Raw saveimage size.
    pub size: u64,
    /// < Save data index.
    pub index: u16,
    /// < Save data 'rank' or 'precedence'. 0 if this save data is considered the primary save data. 1 if it's considered the secondary save data.
    pub rank: u8,
    /// < Unknown. Usually zeros?
    pub unk_x3b: [u8; 37usize],
}
#[test]
fn bindgen_test_layout_FsSaveDataInfo() {
    assert_eq!(
        ::core::mem::size_of::<FsSaveDataInfo>(),
        96usize,
        concat!("Size of: ", stringify!(FsSaveDataInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<FsSaveDataInfo>(),
        16usize,
        concat!("Alignment of ", stringify!(FsSaveDataInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSaveDataInfo>())).saveID_unk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSaveDataInfo),
            "::",
            stringify!(saveID_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSaveDataInfo>())).SaveDataSpaceId as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSaveDataInfo),
            "::",
            stringify!(SaveDataSpaceId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSaveDataInfo>())).SaveDataType as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSaveDataInfo),
            "::",
            stringify!(SaveDataType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSaveDataInfo>())).pad as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSaveDataInfo),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSaveDataInfo>())).userID as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSaveDataInfo),
            "::",
            stringify!(userID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSaveDataInfo>())).saveID as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSaveDataInfo),
            "::",
            stringify!(saveID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSaveDataInfo>())).titleID as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSaveDataInfo),
            "::",
            stringify!(titleID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSaveDataInfo>())).size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSaveDataInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSaveDataInfo>())).index as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSaveDataInfo),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSaveDataInfo>())).rank as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSaveDataInfo),
            "::",
            stringify!(rank)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSaveDataInfo>())).unk_x3b as *const _ as usize },
        59usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSaveDataInfo),
            "::",
            stringify!(unk_x3b)
        )
    );
}
#[repr(C)]
pub struct FsTimeStampRaw {
    /// < POSIX timestamp.
    pub created: u64,
    /// < POSIX timestamp.
    pub modified: u64,
    /// < POSIX timestamp.
    pub accessed: u64,
    /// < 0x1 when the timestamps are set.
    pub is_valid: u8,
    pub padding: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_FsTimeStampRaw() {
    assert_eq!(
        ::core::mem::size_of::<FsTimeStampRaw>(),
        32usize,
        concat!("Size of: ", stringify!(FsTimeStampRaw))
    );
    assert_eq!(
        ::core::mem::align_of::<FsTimeStampRaw>(),
        8usize,
        concat!("Alignment of ", stringify!(FsTimeStampRaw))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsTimeStampRaw>())).created as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FsTimeStampRaw),
            "::",
            stringify!(created)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsTimeStampRaw>())).modified as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FsTimeStampRaw),
            "::",
            stringify!(modified)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsTimeStampRaw>())).accessed as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FsTimeStampRaw),
            "::",
            stringify!(accessed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsTimeStampRaw>())).is_valid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FsTimeStampRaw),
            "::",
            stringify!(is_valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsTimeStampRaw>())).padding as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(FsTimeStampRaw),
            "::",
            stringify!(padding)
        )
    );
}
pub const FsEntryType_ENTRYTYPE_DIR: FsEntryType = 0;
pub const FsEntryType_ENTRYTYPE_FILE: FsEntryType = 1;
pub type FsEntryType = u32;
/// < Open for reading.
pub const FsFileFlags_FS_OPEN_READ: FsFileFlags = 1;
/// < Open for writing.
pub const FsFileFlags_FS_OPEN_WRITE: FsFileFlags = 2;
/// < Append file.
pub const FsFileFlags_FS_OPEN_APPEND: FsFileFlags = 4;
pub type FsFileFlags = u32;
/// < Enable reading directory entries.
pub const FsDirectoryFlags_FS_DIROPEN_DIRECTORY: FsDirectoryFlags = 1;
/// < Enable reading file entries.
pub const FsDirectoryFlags_FS_DIROPEN_FILE: FsDirectoryFlags = 2;
/// For use with fsFsOpenDirectory.
pub type FsDirectoryFlags = u32;
pub const FsStorageId_FsStorageId_None: FsStorageId = 0;
pub const FsStorageId_FsStorageId_Host: FsStorageId = 1;
pub const FsStorageId_FsStorageId_GameCard: FsStorageId = 2;
pub const FsStorageId_FsStorageId_NandSystem: FsStorageId = 3;
pub const FsStorageId_FsStorageId_NandUser: FsStorageId = 4;
pub const FsStorageId_FsStorageId_SdCard: FsStorageId = 5;
pub type FsStorageId = u32;
pub const FsContentStorageId_FS_CONTENTSTORAGEID_NandSystem: FsContentStorageId = 0;
pub const FsContentStorageId_FS_CONTENTSTORAGEID_NandUser: FsContentStorageId = 1;
pub const FsContentStorageId_FS_CONTENTSTORAGEID_SdCard: FsContentStorageId = 2;
pub type FsContentStorageId = u32;
pub const FsSaveDataSpaceId_FsSaveDataSpaceId_NandSystem: FsSaveDataSpaceId = 0;
pub const FsSaveDataSpaceId_FsSaveDataSpaceId_NandUser: FsSaveDataSpaceId = 1;
pub const FsSaveDataSpaceId_FsSaveDataSpaceId_SdCard: FsSaveDataSpaceId = 2;
pub const FsSaveDataSpaceId_FsSaveDataSpaceId_TemporaryStorage: FsSaveDataSpaceId = 3;
/// < Pseudo value for fsOpenSaveDataIterator().
pub const FsSaveDataSpaceId_FsSaveDataSpaceId_All: FsSaveDataSpaceId = -1;
pub type FsSaveDataSpaceId = i32;
pub const FsSaveDataType_FsSaveDataType_SystemSaveData: FsSaveDataType = 0;
pub const FsSaveDataType_FsSaveDataType_SaveData: FsSaveDataType = 1;
pub const FsSaveDataType_FsSaveDataType_BcatDeliveryCacheStorage: FsSaveDataType = 2;
pub const FsSaveDataType_FsSaveDataType_DeviceSaveData: FsSaveDataType = 3;
/// < [3.0.0+]
pub const FsSaveDataType_FsSaveDataType_TemporaryStorage: FsSaveDataType = 4;
/// < [3.0.0+]
pub const FsSaveDataType_FsSaveDataType_CacheStorage: FsSaveDataType = 5;
pub type FsSaveDataType = u32;
/// < Causes the cartridge to automatically start on bootup
pub const FsGameCardAttribute_FsGameCardAttribute_AutoBoot: FsGameCardAttribute = 1;
/// < Causes NS to throw an error on attempt to load the cartridge
pub const FsGameCardAttribute_FsGameCardAttribute_ForceError: FsGameCardAttribute = 2;
/// < Indicates that this gamecard is a repair tool.
pub const FsGameCardAttribute_FsGameCardAttribute_Repair: FsGameCardAttribute = 4;
pub type FsGameCardAttribute = u32;
#[repr(C)]
pub struct FsGameCardHandle {
    pub value: u32,
}
#[test]
fn bindgen_test_layout_FsGameCardHandle() {
    assert_eq!(
        ::core::mem::size_of::<FsGameCardHandle>(),
        4usize,
        concat!("Size of: ", stringify!(FsGameCardHandle))
    );
    assert_eq!(
        ::core::mem::align_of::<FsGameCardHandle>(),
        4usize,
        concat!("Alignment of ", stringify!(FsGameCardHandle))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsGameCardHandle>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FsGameCardHandle),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    pub fn fsInitialize() -> Result;
}
extern "C" {
    pub fn fsExit();
}
extern "C" {
    pub fn fsGetServiceSession() -> *mut Service;
}
extern "C" {
    pub fn fsOpenBisStorage(out: *mut FsStorage, PartitionId: u32) -> Result;
}
extern "C" {
    pub fn fsOpenBisFileSystem(
        out: *mut FsFileSystem,
        PartitionId: u32,
        string: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    pub fn fsIsExFatSupported(out: *mut bool) -> Result;
}
extern "C" {
    /// Do not call this directly, see fs_dev.h.
    pub fn fsMountSdcard(out: *mut FsFileSystem) -> Result;
}
extern "C" {
    pub fn fsMountSaveData(out: *mut FsFileSystem, inval: u8, save: *mut FsSave) -> Result;
}
extern "C" {
    pub fn fsMountSystemSaveData(out: *mut FsFileSystem, inval: u8, save: *mut FsSave) -> Result;
}
extern "C" {
    pub fn fsOpenSaveDataIterator(out: *mut FsSaveDataIterator, SaveDataSpaceId: s32) -> Result;
}
extern "C" {
    pub fn fsOpenDataStorageByCurrentProcess(out: *mut FsStorage) -> Result;
}
extern "C" {
    pub fn fsOpenDataStorageByDataId(
        out: *mut FsStorage,
        dataId: u64,
        storageId: FsStorageId,
    ) -> Result;
}
extern "C" {
    pub fn fsOpenDeviceOperator(out: *mut FsDeviceOperator) -> Result;
}
extern "C" {
    pub fn fsOpenSdCardDetectionEventNotifier(out: *mut FsEventNotifier) -> Result;
}
extern "C" {
    /// Wrapper(s) for fsMountSaveData.
    /// See FsSave for titleID and userID.
    pub fn fsMount_SaveData(out: *mut FsFileSystem, titleID: u64, userID: u128) -> Result;
}
extern "C" {
    /// Wrapper for fsMountSystemSaveData.
    /// WARNING: You can brick when writing to SystemSaveData, if the data is corrupted etc.
    pub fn fsMount_SystemSaveData(out: *mut FsFileSystem, saveID: u64) -> Result;
}
pub const FsFileSystemType_FsFileSystemType_Logo: FsFileSystemType = 2;
pub const FsFileSystemType_FsFileSystemType_ContentControl: FsFileSystemType = 3;
pub const FsFileSystemType_FsFileSystemType_ContentManual: FsFileSystemType = 4;
pub const FsFileSystemType_FsFileSystemType_ContentMeta: FsFileSystemType = 5;
pub const FsFileSystemType_FsFileSystemType_ContentData: FsFileSystemType = 6;
pub const FsFileSystemType_FsFileSystemType_ApplicationPackage: FsFileSystemType = 7;
pub type FsFileSystemType = u32;
pub const FsFileSystemQueryType_FsFileSystemQueryType_SetArchiveBit: FsFileSystemQueryType = 0;
pub type FsFileSystemQueryType = u32;
extern "C" {
    /// Mount requested filesystem type from content file
    pub fn fsOpenFileSystem(
        out: *mut FsFileSystem,
        fsType: FsFileSystemType,
        contentPath: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    /// same as calling fsOpenFileSystemWithId with 0 as titleId
    pub fn fsOpenFileSystemWithId(
        out: *mut FsFileSystem,
        titleId: u64,
        fsType: FsFileSystemType,
        contentPath: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    /// works on all firmwares, titleId is ignored on 1.0.0
    pub fn fsFsCreateFile(
        fs: *mut FsFileSystem,
        path: *const ctypes::c_char,
        size: usize,
        flags: ctypes::c_int,
    ) -> Result;
}
extern "C" {
    pub fn fsFsDeleteFile(fs: *mut FsFileSystem, path: *const ctypes::c_char) -> Result;
}
extern "C" {
    pub fn fsFsCreateDirectory(fs: *mut FsFileSystem, path: *const ctypes::c_char) -> Result;
}
extern "C" {
    pub fn fsFsDeleteDirectory(fs: *mut FsFileSystem, path: *const ctypes::c_char) -> Result;
}
extern "C" {
    pub fn fsFsDeleteDirectoryRecursively(
        fs: *mut FsFileSystem,
        path: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    pub fn fsFsRenameFile(
        fs: *mut FsFileSystem,
        path0: *const ctypes::c_char,
        path1: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    pub fn fsFsRenameDirectory(
        fs: *mut FsFileSystem,
        path0: *const ctypes::c_char,
        path1: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    pub fn fsFsGetEntryType(
        fs: *mut FsFileSystem,
        path: *const ctypes::c_char,
        out: *mut FsEntryType,
    ) -> Result;
}
extern "C" {
    pub fn fsFsOpenFile(
        fs: *mut FsFileSystem,
        path: *const ctypes::c_char,
        flags: ctypes::c_int,
        out: *mut FsFile,
    ) -> Result;
}
extern "C" {
    pub fn fsFsOpenDirectory(
        fs: *mut FsFileSystem,
        path: *const ctypes::c_char,
        flags: ctypes::c_int,
        out: *mut FsDir,
    ) -> Result;
}
extern "C" {
    pub fn fsFsCommit(fs: *mut FsFileSystem) -> Result;
}
extern "C" {
    pub fn fsFsGetFreeSpace(
        fs: *mut FsFileSystem,
        path: *const ctypes::c_char,
        out: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn fsFsGetTotalSpace(
        fs: *mut FsFileSystem,
        path: *const ctypes::c_char,
        out: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn fsFsGetFileTimeStampRaw(
        fs: *mut FsFileSystem,
        path: *const ctypes::c_char,
        out: *mut FsTimeStampRaw,
    ) -> Result;
}
extern "C" {
    /// 3.0.0+
    pub fn fsFsCleanDirectoryRecursively(
        fs: *mut FsFileSystem,
        path: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    /// 3.0.0+
    pub fn fsFsQueryEntry(
        fs: *mut FsFileSystem,
        out: *mut ctypes::c_void,
        out_size: usize,
        in_: *const ctypes::c_void,
        in_size: usize,
        path: *const ctypes::c_char,
        query_type: FsFileSystemQueryType,
    ) -> Result;
}
extern "C" {
    /// 4.0.0+
    pub fn fsFsClose(fs: *mut FsFileSystem);
}
extern "C" {
    /// Uses \ref fsFsQueryEntry to set the archive bit on the specified absolute directory path.
    /// This will cause HOS to treat the directory as if it were a file containing the directory's concatenated contents.
    pub fn fsFsSetArchiveBit(fs: *mut FsFileSystem, path: *const ctypes::c_char) -> Result;
}
extern "C" {
    pub fn fsFileRead(
        f: *mut FsFile,
        off: u64,
        buf: *mut ctypes::c_void,
        len: usize,
        out: *mut usize,
    ) -> Result;
}
extern "C" {
    pub fn fsFileWrite(f: *mut FsFile, off: u64, buf: *const ctypes::c_void, len: usize) -> Result;
}
extern "C" {
    pub fn fsFileFlush(f: *mut FsFile) -> Result;
}
extern "C" {
    pub fn fsFileSetSize(f: *mut FsFile, sz: u64) -> Result;
}
extern "C" {
    pub fn fsFileGetSize(f: *mut FsFile, out: *mut u64) -> Result;
}
extern "C" {
    pub fn fsFileClose(f: *mut FsFile);
}
extern "C" {
    pub fn fsDirRead(
        d: *mut FsDir,
        inval: u64,
        total_entries: *mut usize,
        max_entries: usize,
        buf: *mut FsDirectoryEntry,
    ) -> Result;
}
extern "C" {
    pub fn fsDirGetEntryCount(d: *mut FsDir, count: *mut u64) -> Result;
}
extern "C" {
    pub fn fsDirClose(d: *mut FsDir);
}
extern "C" {
    pub fn fsStorageRead(
        s: *mut FsStorage,
        off: u64,
        buf: *mut ctypes::c_void,
        len: usize,
    ) -> Result;
}
extern "C" {
    pub fn fsStorageWrite(
        s: *mut FsStorage,
        off: u64,
        buf: *const ctypes::c_void,
        len: usize,
    ) -> Result;
}
extern "C" {
    pub fn fsStorageFlush(s: *mut FsStorage) -> Result;
}
extern "C" {
    pub fn fsStorageSetSize(s: *mut FsStorage, sz: u64) -> Result;
}
extern "C" {
    pub fn fsStorageGetSize(s: *mut FsStorage, out: *mut u64) -> Result;
}
extern "C" {
    pub fn fsStorageClose(s: *mut FsStorage);
}
extern "C" {
    /// Read FsSaveDataInfo data into the buf array.
    pub fn fsSaveDataIteratorRead(
        s: *mut FsSaveDataIterator,
        buf: *mut FsSaveDataInfo,
        max_entries: usize,
        total_entries: *mut usize,
    ) -> Result;
}
extern "C" {
    pub fn fsSaveDataIteratorClose(s: *mut FsSaveDataIterator);
}
extern "C" {
    pub fn fsEventNotifierGetEventHandle(e: *mut FsEventNotifier, out: *mut Handle) -> Result;
}
extern "C" {
    pub fn fsEventNotifierClose(e: *mut FsEventNotifier);
}
extern "C" {
    pub fn fsDeviceOperatorIsSdCardInserted(d: *mut FsDeviceOperator, out: *mut bool) -> Result;
}
extern "C" {
    pub fn fsDeviceOperatorIsGameCardInserted(d: *mut FsDeviceOperator, out: *mut bool) -> Result;
}
extern "C" {
    pub fn fsDeviceOperatorGetGameCardHandle(
        d: *mut FsDeviceOperator,
        out: *mut FsGameCardHandle,
    ) -> Result;
}
extern "C" {
    pub fn fsDeviceOperatorGetGameCardAttribute(
        d: *mut FsDeviceOperator,
        handle: *const FsGameCardHandle,
        out: *mut u8,
    ) -> Result;
}
extern "C" {
    pub fn fsDeviceOperatorClose(d: *mut FsDeviceOperator);
}
extern "C" {
    pub fn smManagerInitialize() -> Result;
}
extern "C" {
    pub fn smManagerExit();
}
extern "C" {
    pub fn smManagerRegisterProcess(
        pid: u64,
        acid_sac: *const ctypes::c_void,
        acid_sac_size: usize,
        aci0_sac: *const ctypes::c_void,
        aci0_sac_size: usize,
    ) -> Result;
}
extern "C" {
    pub fn smManagerUnregisterProcess(pid: u64) -> Result;
}
extern "C" {
    pub fn fsldrInitialize() -> Result;
}
extern "C" {
    pub fn fsldrExit();
}
extern "C" {
    pub fn fsldrOpenCodeFileSystem(
        tid: u64,
        path: *const ctypes::c_char,
        out: *mut FsFileSystem,
    ) -> Result;
}
extern "C" {
    pub fn fsldrIsArchivedProgram(pid: u64, out: *mut bool) -> Result;
}
extern "C" {
    pub fn fsldrSetCurrentProcess() -> Result;
}
extern "C" {
    pub fn fsprInitialize() -> Result;
}
extern "C" {
    pub fn fsprExit();
}
extern "C" {
    pub fn fsprRegisterProgram(
        pid: u64,
        titleID: u64,
        storageID: FsStorageId,
        fs_access_header: *const ctypes::c_void,
        fah_size: usize,
        fs_access_control: *const ctypes::c_void,
        fac_size: usize,
    ) -> Result;
}
extern "C" {
    pub fn fsprUnregisterProgram(pid: u64) -> Result;
}
extern "C" {
    pub fn fsprSetCurrentProcess() -> Result;
}
extern "C" {
    pub fn fsprSetEnabledProgramVerification(enabled: bool) -> Result;
}
#[repr(C)]
pub struct AccountProfile {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_AccountProfile() {
    assert_eq!(
        ::core::mem::size_of::<AccountProfile>(),
        12usize,
        concat!("Size of: ", stringify!(AccountProfile))
    );
    assert_eq!(
        ::core::mem::align_of::<AccountProfile>(),
        4usize,
        concat!("Alignment of ", stringify!(AccountProfile))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AccountProfile>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AccountProfile),
            "::",
            stringify!(s)
        )
    );
}
#[repr(C, packed)]
pub struct AccountUserData {
    pub unk_x0: u32,
    /// < Icon ID. 0 = Mii, the rest are character icon IDs.
    pub iconID: u32,
    /// < Profile icon background color ID
    pub iconBackgroundColorID: u8,
    pub unk_x9: [u8; 7usize],
    /// < Some ID related to the Mii? All zeros when a character icon is used.
    pub miiID: [u8; 16usize],
    /// < Usually zeros?
    pub unk_x20: [u8; 96usize],
}
#[test]
fn bindgen_test_layout_AccountUserData() {
    assert_eq!(
        ::core::mem::size_of::<AccountUserData>(),
        128usize,
        concat!("Size of: ", stringify!(AccountUserData))
    );
    assert_eq!(
        ::core::mem::align_of::<AccountUserData>(),
        1usize,
        concat!("Alignment of ", stringify!(AccountUserData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AccountUserData>())).unk_x0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AccountUserData),
            "::",
            stringify!(unk_x0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AccountUserData>())).iconID as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AccountUserData),
            "::",
            stringify!(iconID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AccountUserData>())).iconBackgroundColorID as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AccountUserData),
            "::",
            stringify!(iconBackgroundColorID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AccountUserData>())).unk_x9 as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(AccountUserData),
            "::",
            stringify!(unk_x9)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AccountUserData>())).miiID as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AccountUserData),
            "::",
            stringify!(miiID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AccountUserData>())).unk_x20 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AccountUserData),
            "::",
            stringify!(unk_x20)
        )
    );
}
#[repr(C, packed)]
pub struct AccountProfileBase {
    pub userID: u128,
    /// < POSIX UTC timestamp, for the last account edit.
    pub lastEditTimestamp: u64,
    /// < UTF-8 Username.
    pub username: [ctypes::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_AccountProfileBase() {
    assert_eq!(
        ::core::mem::size_of::<AccountProfileBase>(),
        56usize,
        concat!("Size of: ", stringify!(AccountProfileBase))
    );
    assert_eq!(
        ::core::mem::align_of::<AccountProfileBase>(),
        1usize,
        concat!("Alignment of ", stringify!(AccountProfileBase))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AccountProfileBase>())).userID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AccountProfileBase),
            "::",
            stringify!(userID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AccountProfileBase>())).lastEditTimestamp as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AccountProfileBase),
            "::",
            stringify!(lastEditTimestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AccountProfileBase>())).username as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AccountProfileBase),
            "::",
            stringify!(username)
        )
    );
}
extern "C" {
    pub fn accountInitialize() -> Result;
}
extern "C" {
    pub fn accountExit();
}
extern "C" {
    pub fn accountGetService() -> *mut Service;
}
extern "C" {
    /// Get the total number of user profiles
    pub fn accountGetUserCount(user_count: *mut s32) -> Result;
}
extern "C" {
    /// @brief Get a list of all user IDs. The returned list will never be larger than ACC_USER_LIST_SIZE.
    /// @param userIDs Pointer to array of user IDs.
    /// @param max_userIDs Maximum number of user IDs to return.
    /// @param actual_total The actual total number of user IDs found.
    pub fn accountListAllUsers(
        userIDs: *mut u128,
        max_userIDs: usize,
        actual_total: *mut usize,
    ) -> Result;
}
extern "C" {
    /// Get the userID for the currently active user. The output userID is only valid when the output account_selected==1, otherwise no user is currently selected.
    /// An user is only selected when the user-account selection applet was used to select an user at least once before.
    pub fn accountGetActiveUser(userID: *mut u128, account_selected: *mut bool) -> Result;
}
extern "C" {
    /// Get an AccountProfile for the specified userID.
    pub fn accountGetProfile(out: *mut AccountProfile, userID: u128) -> Result;
}
extern "C" {
    /// Get \ref AccountUserData and \ref AccountProfileBase for the specified profile, userdata is optional (can be NULL).
    pub fn accountProfileGet(
        profile: *mut AccountProfile,
        userdata: *mut AccountUserData,
        profilebase: *mut AccountProfileBase,
    ) -> Result;
}
extern "C" {
    /// Get the icon image size.
    pub fn accountProfileGetImageSize(
        profile: *mut AccountProfile,
        image_size: *mut usize,
    ) -> Result;
}
extern "C" {
    /// Load the JPEG profile icon, valid for both Miis and character icons. The output image_size is the same as the one from \ref accountProfileGetImageSize.
    pub fn accountProfileLoadImage(
        profile: *mut AccountProfile,
        buf: *mut ctypes::c_void,
        len: usize,
        image_size: *mut usize,
    ) -> Result;
}
extern "C" {
    pub fn accountProfileClose(profile: *mut AccountProfile);
}
extern "C" {
    /// Gets the userID which was selected by the profile-selector applet (if any), prior to launching the currently running Application title. This can only be used once under the current process, under an Application title.
    pub fn accountGetPreselectedUser(userID: *mut u128) -> Result;
}
extern "C" {
    /// These are used internally by applet.
    pub fn apmInitialize() -> Result;
}
extern "C" {
    pub fn apmExit();
}
extern "C" {
    pub fn apmSetPerformanceConfiguration(
        PerformanceMode: u32,
        PerformanceConfiguration: u32,
    ) -> Result;
}
extern "C" {
    pub fn apmGetPerformanceConfiguration(
        PerformanceMode: u32,
        PerformanceConfiguration: *mut u32,
    ) -> Result;
}
pub const AppletType_AppletType_None: AppletType = -2;
pub const AppletType_AppletType_Default: AppletType = -1;
pub const AppletType_AppletType_Application: AppletType = 0;
pub const AppletType_AppletType_SystemApplet: AppletType = 1;
pub const AppletType_AppletType_LibraryApplet: AppletType = 2;
pub const AppletType_AppletType_OverlayApplet: AppletType = 3;
pub const AppletType_AppletType_SystemApplication: AppletType = 4;
pub type AppletType = i32;
pub const AppletOperationMode_AppletOperationMode_Handheld: AppletOperationMode = 0;
pub const AppletOperationMode_AppletOperationMode_Docked: AppletOperationMode = 1;
pub type AppletOperationMode = u32;
/// < FocusState changed.
pub const AppletHookType_AppletHookType_OnFocusState: AppletHookType = 0;
/// < OperationMode changed.
pub const AppletHookType_AppletHookType_OnOperationMode: AppletHookType = 1;
/// < PerformanceMode changed.
pub const AppletHookType_AppletHookType_OnPerformanceMode: AppletHookType = 2;
/// < Exit requested.
pub const AppletHookType_AppletHookType_OnExitRequest: AppletHookType = 3;
/// < Number of applet hook types.
pub const AppletHookType_AppletHookType_Max: AppletHookType = 4;
/// applet hook types.
pub type AppletHookType = u32;
/// < Applet is focused.
pub const AppletFocusState_AppletFocusState_Focused: AppletFocusState = 1;
/// < Out of focus - LibraryApplet open.
pub const AppletFocusState_AppletFocusState_NotFocusedLibraryApplet: AppletFocusState = 2;
/// < Out of focus - HOME menu open / console is sleeping.
pub const AppletFocusState_AppletFocusState_NotFocusedHomeSleep: AppletFocusState = 3;
pub type AppletFocusState = u32;
/// < Suspend only when HOME menu is open / console is sleeping (default).
pub const AppletFocusHandlingMode_AppletFocusHandlingMode_SuspendHomeSleep:
    AppletFocusHandlingMode = 0;
/// < Don't suspend when out of focus.
pub const AppletFocusHandlingMode_AppletFocusHandlingMode_NoSuspend: AppletFocusHandlingMode = 1;
/// < Suspend only when HOME menu is open / console is sleeping but still receive OnFocusState hook.
pub const AppletFocusHandlingMode_AppletFocusHandlingMode_SuspendHomeSleepNotify:
    AppletFocusHandlingMode = 2;
/// < Always suspend when out of focus, regardless of the reason.
pub const AppletFocusHandlingMode_AppletFocusHandlingMode_AlwaysSuspend: AppletFocusHandlingMode =
    3;
/// < Number of focus handling modes.
pub const AppletFocusHandlingMode_AppletFocusHandlingMode_Max: AppletFocusHandlingMode = 4;
pub type AppletFocusHandlingMode = u32;
/// < Application-specific LaunchParameter
pub const AppletLaunchParameterKind_AppletLaunchParameterKind_Application:
    AppletLaunchParameterKind = 1;
/// < account PreselectedUser
pub const AppletLaunchParameterKind_AppletLaunchParameterKind_PreselectedUser:
    AppletLaunchParameterKind = 2;
/// < Unknown if used by anything?
pub const AppletLaunchParameterKind_AppletLaunchParameterKind_Unknown: AppletLaunchParameterKind =
    3;
pub type AppletLaunchParameterKind = u32;
/// < 010000000000100C "overlayDisp"
pub const AppletId_AppletId_overlayDisp: AppletId = 2;
/// < 0100000000001000 "qlaunch" (SystemAppletMenu)
pub const AppletId_AppletId_qlaunch: AppletId = 3;
/// < 0100000000001012 "starter"
pub const AppletId_AppletId_starter: AppletId = 4;
/// < 0100000000001001 "auth"
pub const AppletId_AppletId_auth: AppletId = 10;
/// < 0100000000001002 "cabinet"
pub const AppletId_AppletId_cabinet: AppletId = 11;
/// < 0100000000001003 "controller"
pub const AppletId_AppletId_controller: AppletId = 12;
/// < 0100000000001004 "dataErase"
pub const AppletId_AppletId_dataErase: AppletId = 13;
/// < 0100000000001005 "error"
pub const AppletId_AppletId_error: AppletId = 14;
/// < 0100000000001006 "netConnect"
pub const AppletId_AppletId_netConnect: AppletId = 15;
/// < 0100000000001007 "playerSelect"
pub const AppletId_AppletId_playerSelect: AppletId = 16;
/// < 0100000000001008 "swkbd"
pub const AppletId_AppletId_swkbd: AppletId = 17;
/// < 0100000000001009 "miiEdit"
pub const AppletId_AppletId_miiEdit: AppletId = 18;
/// < 010000000000100A "LibAppletWeb" WebApplet applet
pub const AppletId_AppletId_web: AppletId = 19;
/// < 010000000000100B "LibAppletShop" ShopN applet
pub const AppletId_AppletId_shop: AppletId = 20;
/// < 010000000000100D "photoViewer"
pub const AppletId_AppletId_photoViewer: AppletId = 21;
/// < 010000000000100E "set" (This title is currently not present on retail devices.)
pub const AppletId_AppletId_set: AppletId = 22;
/// < 010000000000100F "LibAppletOff" Offline web-applet
pub const AppletId_AppletId_offlineWeb: AppletId = 23;
/// < 0100000000001010 "LibAppletLns" Whitelisted web-applet
pub const AppletId_AppletId_loginShare: AppletId = 24;
/// < 0100000000001011 "LibAppletAuth" WifiWebAuth applet
pub const AppletId_AppletId_wifiWebAuth: AppletId = 25;
/// < 0100000000001013 "myPage"
pub const AppletId_AppletId_myPage: AppletId = 26;
pub type AppletId = u32;
/// < Foreground
pub const LibAppletMode_LibAppletMode_AllForeground: LibAppletMode = 0;
/// < Background
pub const LibAppletMode_LibAppletMode_Background: LibAppletMode = 1;
/// < Unknown
pub const LibAppletMode_LibAppletMode_Unknown2: LibAppletMode = 2;
/// < Unknown
pub const LibAppletMode_LibAppletMode_Unknown3: LibAppletMode = 3;
/// LibraryAppletMode
pub type LibAppletMode = u32;
pub const LibAppletExitReason_LibAppletExitReason_Normal: LibAppletExitReason = 0;
pub const LibAppletExitReason_LibAppletExitReason_Canceled: LibAppletExitReason = 1;
pub const LibAppletExitReason_LibAppletExitReason_Abnormal: LibAppletExitReason = 2;
pub const LibAppletExitReason_LibAppletExitReason_Unexpected: LibAppletExitReason = 10;
/// LibraryAppletExitReason
pub type LibAppletExitReason = u32;
pub const AppletThemeColorType_AppletThemeColorType_Default: AppletThemeColorType = 0;
pub const AppletThemeColorType_AppletThemeColorType_Unknown1: AppletThemeColorType = 1;
pub const AppletThemeColorType_AppletThemeColorType_Unknown2: AppletThemeColorType = 2;
pub const AppletThemeColorType_AppletThemeColorType_Unknown3: AppletThemeColorType = 3;
/// ThemeColorType
pub type AppletThemeColorType = u32;
/// applet hook function.
pub type AppletHookFn =
    ::core::option::Option<unsafe extern "C" fn(hook: AppletHookType, param: *mut ctypes::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AppletHookCookie {
    /// < Next cookie.
    pub next: *mut AppletHookCookie,
    /// < Hook callback.
    pub callback: AppletHookFn,
    /// < Callback parameter.
    pub param: *mut ctypes::c_void,
}
#[test]
fn bindgen_test_layout_AppletHookCookie() {
    assert_eq!(
        ::core::mem::size_of::<AppletHookCookie>(),
        24usize,
        concat!("Size of: ", stringify!(AppletHookCookie))
    );
    assert_eq!(
        ::core::mem::align_of::<AppletHookCookie>(),
        8usize,
        concat!("Alignment of ", stringify!(AppletHookCookie))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AppletHookCookie>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletHookCookie),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AppletHookCookie>())).callback as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletHookCookie),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AppletHookCookie>())).param as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletHookCookie),
            "::",
            stringify!(param)
        )
    );
}
/// applet IStorage
#[repr(C)]
pub struct AppletStorage {
    pub s: Service,
    pub tmem: TransferMemory,
}
#[test]
fn bindgen_test_layout_AppletStorage() {
    assert_eq!(
        ::core::mem::size_of::<AppletStorage>(),
        56usize,
        concat!("Size of: ", stringify!(AppletStorage))
    );
    assert_eq!(
        ::core::mem::align_of::<AppletStorage>(),
        8usize,
        concat!("Alignment of ", stringify!(AppletStorage))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AppletStorage>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletStorage),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AppletStorage>())).tmem as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletStorage),
            "::",
            stringify!(tmem)
        )
    );
}
/// LibraryApplet state.
#[repr(C)]
pub struct AppletHolder {
    /// < ILibraryAppletAccessor
    pub s: Service,
    /// < Output from GetAppletStateChangedEvent, autoclear=false.
    pub StateChangedEvent: Event,
    /// < Output from GetPopInteractiveOutDataEvent, autoclear=false.
    pub PopInteractiveOutDataEvent: Event,
    /// < See ref \ref LibAppletMode.
    pub mode: LibAppletMode,
    /// < Output from GetIndirectLayerConsumerHandle on 2.0.0+.
    pub layer_handle: u64,
    /// < When set, indicates that the LibraryApplet title is creating itself.
    pub creating_self: bool,
    /// < Set by \ref appletHolderJoin using the output from cmd GetResult, see \ref LibAppletExitReason.
    pub exitreason: LibAppletExitReason,
}
#[test]
fn bindgen_test_layout_AppletHolder() {
    assert_eq!(
        ::core::mem::size_of::<AppletHolder>(),
        56usize,
        concat!("Size of: ", stringify!(AppletHolder))
    );
    assert_eq!(
        ::core::mem::align_of::<AppletHolder>(),
        8usize,
        concat!("Alignment of ", stringify!(AppletHolder))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AppletHolder>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletHolder),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AppletHolder>())).StateChangedEvent as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletHolder),
            "::",
            stringify!(StateChangedEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AppletHolder>())).PopInteractiveOutDataEvent as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletHolder),
            "::",
            stringify!(PopInteractiveOutDataEvent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AppletHolder>())).mode as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletHolder),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AppletHolder>())).layer_handle as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletHolder),
            "::",
            stringify!(layer_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AppletHolder>())).creating_self as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletHolder),
            "::",
            stringify!(creating_self)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AppletHolder>())).exitreason as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletHolder),
            "::",
            stringify!(exitreason)
        )
    );
}
/// 'pdm' ApplicationPlayStatistics
#[repr(C)]
pub struct AppletApplicationPlayStatistics {
    pub unk_x0: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_AppletApplicationPlayStatistics() {
    assert_eq!(
        ::core::mem::size_of::<AppletApplicationPlayStatistics>(),
        8usize,
        concat!("Size of: ", stringify!(AppletApplicationPlayStatistics))
    );
    assert_eq!(
        ::core::mem::align_of::<AppletApplicationPlayStatistics>(),
        1usize,
        concat!("Alignment of ", stringify!(AppletApplicationPlayStatistics))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AppletApplicationPlayStatistics>())).unk_x0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletApplicationPlayStatistics),
            "::",
            stringify!(unk_x0)
        )
    );
}
/// Attributes for launching applications for Quest.
#[repr(C)]
pub struct AppletApplicationAttributeForQuest {
    pub unk_x0: u32,
    pub unk_x4: u32,
}
#[test]
fn bindgen_test_layout_AppletApplicationAttributeForQuest() {
    assert_eq!(
        ::core::mem::size_of::<AppletApplicationAttributeForQuest>(),
        8usize,
        concat!("Size of: ", stringify!(AppletApplicationAttributeForQuest))
    );
    assert_eq!(
        ::core::mem::align_of::<AppletApplicationAttributeForQuest>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(AppletApplicationAttributeForQuest)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AppletApplicationAttributeForQuest>())).unk_x0 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletApplicationAttributeForQuest),
            "::",
            stringify!(unk_x0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AppletApplicationAttributeForQuest>())).unk_x4 as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletApplicationAttributeForQuest),
            "::",
            stringify!(unk_x4)
        )
    );
}
extern "C" {
    /// Initialize applet, called automatically during app startup.
    pub fn appletInitialize() -> Result;
}
extern "C" {
    /// Exit applet, called automatically during app startup.
    pub fn appletExit();
}
extern "C" {
    pub fn appletGetAppletResourceUserId(out: *mut u64) -> Result;
}
extern "C" {
    pub fn appletGetAppletType() -> AppletType;
}
extern "C" {
    pub fn appletNotifyRunning(out: *mut u8);
}
extern "C" {
    pub fn appletCreateManagedDisplayLayer(out: *mut u64) -> Result;
}
extern "C" {
    /// Sets the state field for \ref AppletThemeColorType.
    pub fn appletSetThemeColorType(theme: AppletThemeColorType);
}
extern "C" {
    /// Gets the state field for \ref AppletThemeColorType. Used internally by \ref libappletArgsCreate.
    pub fn appletGetThemeColorType() -> AppletThemeColorType;
}
extern "C" {
    /// @brief Pops a LaunchParameter AppletStorage, the storage will be removed from sysmodule state during this.
    /// @param s Output storage.
    /// @param kind See \ref AppletLaunchParameterKind.
    /// @note Can only be used in Applications.
    /// @note See also acc.h \ref accountGetPreselectedUser (wrapper for appletPopLaunchParameter etc).
    pub fn appletPopLaunchParameter(
        s: *mut AppletStorage,
        kind: AppletLaunchParameterKind,
    ) -> Result;
}
extern "C" {
    /// @brief Requests to launch the specified application.
    /// @note Only available with AppletType_*Application, or AppletType_LibraryApplet on 5.0.0+.
    /// @param[in] titleID Application titleID. Value 0 can be used to relaunch the current application.
    /// @param s Optional AppletStorage object, can be NULL. This is automatically closed. When NULL on pre-4.0.0 (or with AppletType_LibraryApplet), this will internally create a tmp storage with size 0 for use with the cmd. This is the storage available to the launched application via \ref appletPopLaunchParameter with ::AppletLaunchParameterKind_Application.
    pub fn appletRequestLaunchApplication(titleID: u64, s: *mut AppletStorage) -> Result;
}
extern "C" {
    /// @brief Requests to launch the specified application, for kiosk systems.
    /// @note Only available with AppletType_*Application on 3.0.0+.
    /// @param[in] titleID Application titleID
    /// @param s Optional AppletStorage object, can be NULL. This is automatically closed. When NULL on pre-4.0.0, this will internally create a tmp storage with size 0 for use with the cmd. This is the storage available to the launched application via \ref appletPopLaunchParameter with ::AppletLaunchParameterKind_Application.
    /// @param[in] attr Kiosk application attributes.
    pub fn appletRequestLaunchApplicationForQuest(
        titleID: u64,
        s: *mut AppletStorage,
        attr: *const AppletApplicationAttributeForQuest,
    ) -> Result;
}
extern "C" {
    pub fn appletGetDesiredLanguage(LanguageCode: *mut u64) -> Result;
}
extern "C" {
    /// Only available with AppletType_*Application.
    pub fn appletSetTerminateResult(res: Result) -> Result;
}
extern "C" {
    /// Set media playback state.
    /// If state is set to true, screen dimming and auto sleep is disabled.
    /// For *Application, this uses cmd SetMediaPlaybackStateForApplication, otherwise cmd SetMediaPlaybackState is used.
    pub fn appletSetMediaPlaybackState(state: bool) -> Result;
}
extern "C" {
    /// Gets whether video recording is supported.
    /// See also \ref appletInitializeGamePlayRecording.
    pub fn appletIsGamePlayRecordingSupported(flag: *mut bool) -> Result;
}
extern "C" {
    /// Disable/enable video recording. Only available after \ref appletInitializeGamePlayRecording was used.
    /// See also \ref appletInitializeGamePlayRecording.
    pub fn appletSetGamePlayRecordingState(state: bool) -> Result;
}
extern "C" {
    /// Initializes video recording. This allocates a 0x6000000-byte buffer for the TransferMemory, cleanup is handled automatically during app exit in \ref appletExit.
    /// Only available with AppletType_Application on 3.0.0+, hence errors from this can be ignored.
    /// Video recording is only fully available system-side with 4.0.0+.
    /// Only usable when running under a title which supports video recording.
    pub fn appletInitializeGamePlayRecording() -> Result;
}
extern "C" {
    /// @brief Blocks the usage of the home button.
    /// @param val Unknown nanoseconds. Value 0 can be used.
    /// @note Can only be used in regularapps.
    pub fn appletBeginBlockingHomeButton(val: s64) -> Result;
}
extern "C" {
    pub fn appletEndBlockingHomeButton() -> Result;
}
extern "C" {
    /// @brief Gets ApplicationPlayStatistics.
    /// @note Only available with AppletType_*Application on 5.0.0+.
    /// @note This may return no output in some cases.
    /// @param stats Output \ref AppletApplicationPlayStatistics array.
    /// @param titleIDs Input titleIDs array.
    /// @param count Total entries in the input/output arrays.
    /// @param out Output s32.
    pub fn appletQueryApplicationPlayStatistics(
        stats: *mut AppletApplicationPlayStatistics,
        titleIDs: *const u64,
        count: s32,
        out: *mut s32,
    ) -> Result;
}
extern "C" {
    /// @brief Delay exiting until \ref appletUnlockExit is called, with a 15 second timeout once exit is requested.
    /// @note When exit is requested \ref appletMainLoop will return false, hence any main-loop using appletMainLoop will exit. This allows the app to handle cleanup post-main-loop instead of being force-terminated.
    /// @note If the above timeout occurs after exit was requested where \ref appletUnlockExit was not called, the process will be forced-terminated.
    /// @note \ref appletUnlockExit must be used before main() returns.
    pub fn appletLockExit() -> Result;
}
extern "C" {
    /// Unlocks exiting, see \ref appletLockExit.
    pub fn appletUnlockExit() -> Result;
}
extern "C" {
    /// @brief Controls whether screenshot-capture is allowed.
    /// @param val 0 = disable, 1 = enable.
    pub fn appletSetScreenShotPermission(val: s32) -> Result;
}
extern "C" {
    pub fn appletSetScreenShotImageOrientation(val: s32) -> Result;
}
extern "C" {
    /// @brief Stops forwarding the input to the foreground app, works only in the Overlay applet context.
    /// @note You have to call this to receive inputs through the hid service when running as the overlay applet.
    pub fn appletBeginToWatchShortHomeButtonMessage() -> Result;
}
extern "C" {
    /// @brief Forwards input to the foreground app, works only in the Overlay applet context.
    /// @note After calling this the overlay applet won't receive any input until \ref appletBeginToWatchShortHomeButtonMessage is called again.
    pub fn appletEndToWatchShortHomeButtonMessage() -> Result;
}
extern "C" {
    /// @brief Get an event that fires when the home button is pressed, doesn't interfere with home menu. This event does not auto clear.
    /// @note Doesn't fire for long press.
    pub fn appletHomeButtonReaderLockAccessorGetEvent(out_event: *mut Event) -> Result;
}
extern "C" {
    /// @brief Pushes a storage to the general channel. Used for sending requests to qlaunch.
    /// @note  This is not usable under an Application, however it is usable under a LibraryApplet.
    /// @note  This uses \ref appletStorageClose automatically.
    /// @param s Storage object.
    pub fn appletPushToGeneralChannel(s: *mut AppletStorage) -> Result;
}
extern "C" {
    /// @brief Creates a LibraryApplet.
    /// @param h AppletHolder object.
    /// @param id See \ref AppletId.
    /// @param mode See \ref LibAppletMode.
    pub fn appletCreateLibraryApplet(
        h: *mut AppletHolder,
        id: AppletId,
        mode: LibAppletMode,
    ) -> Result;
}
extern "C" {
    /// @brief Creates a LibraryApplet. This is for when a LibraryApplet title creates itself.
    /// @note  Identical to \ref appletCreateLibraryApplet except this sets the creating_self flag to true.
    /// @param h AppletHolder object.
    /// @param id See \ref AppletId.
    /// @param mode See \ref LibAppletMode.
    pub fn appletCreateLibraryAppletSelf(
        h: *mut AppletHolder,
        id: AppletId,
        mode: LibAppletMode,
    ) -> Result;
}
extern "C" {
    /// Closes an AppletHolder object.
    pub fn appletHolderClose(h: *mut AppletHolder);
}
extern "C" {
    /// Returns whether the AppletHolder object was initialized.
    pub fn appletHolderActive(h: *mut AppletHolder) -> bool;
}
extern "C" {
    /// @brief Gets the IndirectLayerConsumerHandle loaded during \ref appletCreateLibraryApplet, on 2.0.0+.
    /// @note  Only available when \ref LibAppletMode is ::LibAppletMode_Unknown3.
    /// @param h AppletHolder object.
    /// @param out Output IndirectLayerConsumerHandle.
    pub fn appletHolderGetIndirectLayerConsumerHandle(
        h: *mut AppletHolder,
        out: *mut u64,
    ) -> Result;
}
extern "C" {
    /// @brief Starts the LibraryApplet.
    /// @param h AppletHolder object.
    pub fn appletHolderStart(h: *mut AppletHolder) -> Result;
}
extern "C" {
    /// @brief Requests the LibraryApplet to exit. The command is only used if \ref appletHolderCheckFinished returns false.
    /// @param h AppletHolder object.
    pub fn appletHolderRequestExit(h: *mut AppletHolder) -> Result;
}
extern "C" {
    /// @brief Waits for the LibraryApplet to exit.
    /// @param h AppletHolder object.
    pub fn appletHolderJoin(h: *mut AppletHolder);
}
extern "C" {
    /// @brief Waits on the LibraryApplet StateChangedEvent with timeout=0, and returns whether it was successful.
    /// @param h AppletHolder object.
    pub fn appletHolderCheckFinished(h: *mut AppletHolder) -> bool;
}
extern "C" {
    /// @brief Gets the \ref LibAppletExitReason set by \ref appletHolderJoin.
    /// @param h AppletHolder object.
    pub fn appletHolderGetExitReason(h: *mut AppletHolder) -> LibAppletExitReason;
}
extern "C" {
    /// @brief Waits for the PopInteractiveOutDataEvent and StateChangedEvent.
    /// @return false for error / when StateChangedEvent was signaled, and true when PopInteractiveOutDataEvent was signaled.
    /// @param h AppletHolder object.
    pub fn appletHolderWaitInteractiveOut(h: *mut AppletHolder) -> bool;
}
extern "C" {
    /// @brief Pushes a storage for LibraryApplet input.
    /// @note  This uses \ref appletStorageClose automatically.
    /// @param h AppletHolder object.
    /// @param s Storage object.
    pub fn appletHolderPushInData(h: *mut AppletHolder, s: *mut AppletStorage) -> Result;
}
extern "C" {
    /// @brief Pops a storage from LibraryApplet output.
    /// @param h AppletHolder object.
    /// @param s Storage object.
    pub fn appletHolderPopOutData(h: *mut AppletHolder, s: *mut AppletStorage) -> Result;
}
extern "C" {
    /// @brief Pushes a storage for LibraryApplet Extra storage input.
    /// @note  This uses \ref appletStorageClose automatically.
    /// @param h AppletHolder object.
    /// @param s Storage object.
    pub fn appletHolderPushExtraStorage(h: *mut AppletHolder, s: *mut AppletStorage) -> Result;
}
extern "C" {
    /// @brief Pushes a storage for LibraryApplet Interactive input.
    /// @note  This uses \ref appletStorageClose automatically.
    /// @param h AppletHolder object.
    /// @param s Storage object.
    pub fn appletHolderPushInteractiveInData(h: *mut AppletHolder, s: *mut AppletStorage)
        -> Result;
}
extern "C" {
    /// @brief Pops a storage from LibraryApplet Interactive output.
    /// @param h AppletHolder object.
    /// @param s Storage object.
    pub fn appletHolderPopInteractiveOutData(h: *mut AppletHolder, s: *mut AppletStorage)
        -> Result;
}
extern "C" {
    /// @brief Creates a storage.
    /// @param s Storage object.
    /// @param size Size of storage.
    pub fn appletCreateStorage(s: *mut AppletStorage, size: s64) -> Result;
}
extern "C" {
    /// @brief Creates a TransferMemory storage.
    /// @param s Storage object.
    /// @param buffer TransferMemory buffer, will be automatically allocated if NULL.
    /// @param size Size of storage.
    /// @param writable Controls whether writing to the storage is allowed with \ref appletStorageWrite.
    pub fn appletCreateTransferMemoryStorage(
        s: *mut AppletStorage,
        buffer: *mut ctypes::c_void,
        size: s64,
        writable: bool,
    ) -> Result;
}
extern "C" {
    /// @brief Creates a HandleStorage. Only available on 2.0.0+.
    /// @param s Storage object.
    /// @param inval Arbitrary input value.
    /// @param handle Arbitrary input handle.
    pub fn appletCreateHandleStorage(s: *mut AppletStorage, inval: s64, handle: Handle) -> Result;
}
extern "C" {
    /// @brief Creates a HandleStorage using TransferMemory. Wrapper for \ref appletCreateHandleStorage.
    /// @param s Storage object.
    /// @param buffer TransferMemory buffer, will be automatically allocated if NULL.
    /// @param size Size of storage.
    pub fn appletCreateHandleStorageTmem(
        s: *mut AppletStorage,
        buffer: *mut ctypes::c_void,
        size: s64,
    ) -> Result;
}
extern "C" {
    /// Closes the storage object. TransferMemory closing is seperate, see \ref appletStorageCloseTmem.
    /// Other applet functions which push an input storage will automatically call this.
    pub fn appletStorageClose(s: *mut AppletStorage);
}
extern "C" {
    /// Closes the TransferMemory in the storage object. For TransferMemory storage created by the current process, this must be called after the LibraryApplet finishes using it (if sent to one).
    pub fn appletStorageCloseTmem(s: *mut AppletStorage);
}
extern "C" {
    /// Gets the size of the storage. This is not usable with HandleStorage, use \ref appletStorageGetHandle or \ref appletStorageMap instead for that.
    pub fn appletStorageGetSize(s: *mut AppletStorage, size: *mut s64) -> Result;
}
extern "C" {
    /// @brief Writes to a storage. offset(+size) must be within the actual storage size.
    /// @note  This is not usable with HandleStorage.
    /// @param s Storage object.
    /// @param offset Offset in storage.
    /// @param buffer Input data.
    /// @param size Data size.
    pub fn appletStorageWrite(
        s: *mut AppletStorage,
        offset: s64,
        buffer: *const ctypes::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    /// @brief Reads from a storage. offset(+size) must be within the actual storage size.
    /// @note  This is not usable with HandleStorage.
    /// @param s Storage object.
    /// @param offset Offset in storage.
    /// @param buffer Input data.
    /// @param size Data size.
    pub fn appletStorageRead(
        s: *mut AppletStorage,
        offset: s64,
        buffer: *mut ctypes::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    /// @brief Gets data for a HandleStorage originally from \ref appletCreateHandleStorage input.
    /// @note  Only available on 2.0.0+.
    /// @param s Storage object.
    /// @param out Output value.
    /// @param handle Output handle.
    pub fn appletStorageGetHandle(
        s: *mut AppletStorage,
        out: *mut s64,
        handle: *mut Handle,
    ) -> Result;
}
extern "C" {
    /// @brief Maps TransferMemory for a HandleStorage. Wrapper for \ref appletCreateHandleStorage.
    /// @note  The TransferMemory can be unmapped with \ref appletStorageCloseTmem.
    /// @note  Do not use this if the AppletStorage already contains initialized TransferMemory state.
    /// @param s Storage object.
    /// @param addr Output mapped address (optional).
    /// @param size Output size (optional).
    pub fn appletStorageMap(
        s: *mut AppletStorage,
        addr: *mut *mut ctypes::c_void,
        size: *mut usize,
    ) -> Result;
}
extern "C" {
    /// @brief Gets a notification message.
    pub fn appletGetMessage(msg: *mut u32) -> Result;
}
extern "C" {
    /// @brief Processes the current applet status using the specified msg.
    /// @param msg Notification message, normally from \ref appletGetMessage.
    /// @return Whether the application should continue running.
    pub fn appletProcessMessage(msg: u32) -> bool;
}
extern "C" {
    /// @brief Processes the current applet status. Generally used within a main loop.
    /// @note Uses \ref appletGetMessage and \ref appletProcessMessage internally.
    /// @return Whether the application should continue running.
    pub fn appletMainLoop() -> bool;
}
extern "C" {
    /// @brief Sets up an applet status hook.
    /// @param cookie Hook cookie to use.
    /// @param callback Function to call when applet's status changes.
    /// @param param User-defined parameter to pass to the callback.
    pub fn appletHook(
        cookie: *mut AppletHookCookie,
        callback: AppletHookFn,
        param: *mut ctypes::c_void,
    );
}
extern "C" {
    /// @brief Removes an applet status hook.
    /// @param cookie Hook cookie to remove.
    pub fn appletUnhook(cookie: *mut AppletHookCookie);
}
extern "C" {
    /// These return state which is updated by appletMainLoop() when notifications are received.
    pub fn appletGetOperationMode() -> u8;
}
extern "C" {
    pub fn appletGetPerformanceMode() -> u32;
}
extern "C" {
    pub fn appletGetFocusState() -> AppletFocusState;
}
extern "C" {
    pub fn appletSetFocusHandlingMode(mode: AppletFocusHandlingMode) -> Result;
}
pub const PcmFormat_PcmFormat_Invalid: PcmFormat = 0;
pub const PcmFormat_PcmFormat_Int8: PcmFormat = 1;
pub const PcmFormat_PcmFormat_Int16: PcmFormat = 2;
pub const PcmFormat_PcmFormat_Int24: PcmFormat = 3;
pub const PcmFormat_PcmFormat_Int32: PcmFormat = 4;
pub const PcmFormat_PcmFormat_Float: PcmFormat = 5;
pub const PcmFormat_PcmFormat_Adpcm: PcmFormat = 6;
pub type PcmFormat = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AudioDeviceName {
    pub name: [ctypes::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_AudioDeviceName() {
    assert_eq!(
        ::core::mem::size_of::<AudioDeviceName>(),
        256usize,
        concat!("Size of: ", stringify!(AudioDeviceName))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioDeviceName>(),
        1usize,
        concat!("Alignment of ", stringify!(AudioDeviceName))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDeviceName>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDeviceName),
            "::",
            stringify!(name)
        )
    );
}
pub const AudioInState_AudioInState_Started: AudioInState = 0;
pub const AudioInState_AudioInState_Stopped: AudioInState = 1;
pub type AudioInState = u32;
#[repr(C)]
pub struct AudioInBuffer {
    /// < Next buffer. (Unused)
    pub next: *mut AudioInBuffer,
    /// < Sample buffer (aligned to 0x1000 bytes).
    pub buffer: *mut ctypes::c_void,
    /// < Sample buffer size (aligned to 0x1000 bytes).
    pub buffer_size: u64,
    /// < Size of data inside the buffer.
    pub data_size: u64,
    /// < Offset of data inside the buffer. (Unused?)
    pub data_offset: u64,
}
#[test]
fn bindgen_test_layout_AudioInBuffer() {
    assert_eq!(
        ::core::mem::size_of::<AudioInBuffer>(),
        40usize,
        concat!("Size of: ", stringify!(AudioInBuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioInBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioInBuffer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioInBuffer>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioInBuffer),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioInBuffer>())).buffer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioInBuffer),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioInBuffer>())).buffer_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioInBuffer),
            "::",
            stringify!(buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioInBuffer>())).data_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioInBuffer),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioInBuffer>())).data_offset as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioInBuffer),
            "::",
            stringify!(data_offset)
        )
    );
}
extern "C" {
    pub fn audinInitialize() -> Result;
}
extern "C" {
    pub fn audinExit();
}
extern "C" {
    pub fn audinListAudioIns(
        DeviceNames: *mut ctypes::c_char,
        DeviceNamesCount: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn audinOpenAudioIn(
        DeviceNameIn: *const ctypes::c_char,
        DeviceNameOut: *mut ctypes::c_char,
        SampleRateIn: u32,
        ChannelCountIn: u32,
        SampleRateOut: *mut u32,
        ChannelCountOut: *mut u32,
        Format: *mut PcmFormat,
        State: *mut AudioInState,
    ) -> Result;
}
extern "C" {
    pub fn audinGetAudioInState(State: *mut AudioInState) -> Result;
}
extern "C" {
    pub fn audinStartAudioIn() -> Result;
}
extern "C" {
    pub fn audinStopAudioIn() -> Result;
}
extern "C" {
    /// Submits an \ref AudioInBuffer for capturing.
    pub fn audinAppendAudioInBuffer(Buffer: *mut AudioInBuffer) -> Result;
}
extern "C" {
    pub fn audinGetReleasedAudioInBuffer(
        Buffer: *mut *mut AudioInBuffer,
        ReleasedBuffersCount: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn audinContainsAudioInBuffer(
        Buffer: *mut AudioInBuffer,
        ContainsBuffer: *mut bool,
    ) -> Result;
}
extern "C" {
    /// @brief Submits an audio sample data buffer for capturing and waits for it to finish capturing.
    /// @brief Uses \ref audinAppendAudioInBuffer and \ref audinWaitCaptureFinish internally.
    /// @param source AudioInBuffer containing the buffer to hold the captured sample data.
    /// @param released AudioInBuffer to receive the captured buffer after being released.
    pub fn audinCaptureBuffer(
        source: *mut AudioInBuffer,
        released: *mut *mut AudioInBuffer,
    ) -> Result;
}
extern "C" {
    /// @brief Waits for audio capture to finish.
    /// @param released AudioInBuffer to receive the first captured buffer after being released.
    /// @param released_count Pointer to receive the number of captured buffers.
    /// @param timeout Timeout value, use U64_MAX to wait until all finished.
    pub fn audinWaitCaptureFinish(
        released: *mut *mut AudioInBuffer,
        released_count: *mut u32,
        timeout: u64,
    ) -> Result;
}
extern "C" {
    /// These return the state associated with the currently active audio input device.
    pub fn audinGetSampleRate() -> u32;
}
extern "C" {
    pub fn audinGetChannelCount() -> u32;
}
extern "C" {
    pub fn audinGetPcmFormat() -> PcmFormat;
}
extern "C" {
    pub fn audinGetDeviceState() -> AudioInState;
}
pub const AudioOutState_AudioOutState_Started: AudioOutState = 0;
pub const AudioOutState_AudioOutState_Stopped: AudioOutState = 1;
pub type AudioOutState = u32;
#[repr(C)]
pub struct AudioOutBuffer {
    /// < Next buffer. (Unused)
    pub next: *mut AudioOutBuffer,
    /// < Sample buffer (aligned to 0x1000 bytes).
    pub buffer: *mut ctypes::c_void,
    /// < Sample buffer size (aligned to 0x1000 bytes).
    pub buffer_size: u64,
    /// < Size of data inside the buffer.
    pub data_size: u64,
    /// < Offset of data inside the buffer. (Unused?)
    pub data_offset: u64,
}
#[test]
fn bindgen_test_layout_AudioOutBuffer() {
    assert_eq!(
        ::core::mem::size_of::<AudioOutBuffer>(),
        40usize,
        concat!("Size of: ", stringify!(AudioOutBuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioOutBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioOutBuffer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioOutBuffer>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioOutBuffer),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioOutBuffer>())).buffer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioOutBuffer),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioOutBuffer>())).buffer_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioOutBuffer),
            "::",
            stringify!(buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioOutBuffer>())).data_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioOutBuffer),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioOutBuffer>())).data_offset as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioOutBuffer),
            "::",
            stringify!(data_offset)
        )
    );
}
extern "C" {
    pub fn audoutInitialize() -> Result;
}
extern "C" {
    pub fn audoutExit();
}
extern "C" {
    pub fn audoutListAudioOuts(
        DeviceNames: *mut ctypes::c_char,
        DeviceNamesCount: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn audoutOpenAudioOut(
        DeviceNameIn: *const ctypes::c_char,
        DeviceNameOut: *mut ctypes::c_char,
        SampleRateIn: u32,
        ChannelCountIn: u32,
        SampleRateOut: *mut u32,
        ChannelCountOut: *mut u32,
        Format: *mut PcmFormat,
        State: *mut AudioOutState,
    ) -> Result;
}
extern "C" {
    pub fn audoutGetAudioOutState(State: *mut AudioOutState) -> Result;
}
extern "C" {
    pub fn audoutStartAudioOut() -> Result;
}
extern "C" {
    pub fn audoutStopAudioOut() -> Result;
}
extern "C" {
    /// Submits an \ref AudioOutBuffer for playing.
    pub fn audoutAppendAudioOutBuffer(Buffer: *mut AudioOutBuffer) -> Result;
}
extern "C" {
    pub fn audoutGetReleasedAudioOutBuffer(
        Buffer: *mut *mut AudioOutBuffer,
        ReleasedBuffersCount: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn audoutContainsAudioOutBuffer(
        Buffer: *mut AudioOutBuffer,
        ContainsBuffer: *mut bool,
    ) -> Result;
}
extern "C" {
    /// @brief Submits an audio sample data buffer for playing and waits for it to finish playing.
    /// @brief Uses \ref audoutAppendAudioOutBuffer and \ref audoutWaitPlayFinish internally.
    /// @param source AudioOutBuffer containing the source sample data to be played.
    /// @param released AudioOutBuffer to receive the played buffer after being released.
    pub fn audoutPlayBuffer(
        source: *mut AudioOutBuffer,
        released: *mut *mut AudioOutBuffer,
    ) -> Result;
}
extern "C" {
    /// @brief Waits for audio playback to finish.
    /// @param released AudioOutBuffer to receive the first played buffer after being released.
    /// @param released_count Pointer to receive the number of played buffers.
    /// @param timeout Timeout value, use U64_MAX to wait until all finished.
    pub fn audoutWaitPlayFinish(
        released: *mut *mut AudioOutBuffer,
        released_count: *mut u32,
        timeout: u64,
    ) -> Result;
}
extern "C" {
    /// These return the state associated with the currently active audio output device.
    pub fn audoutGetSampleRate() -> u32;
}
extern "C" {
    pub fn audoutGetChannelCount() -> u32;
}
extern "C" {
    pub fn audoutGetPcmFormat() -> PcmFormat;
}
extern "C" {
    pub fn audoutGetDeviceState() -> AudioOutState;
}
pub const AudioRendererOutputRate_AudioRendererOutputRate_32kHz: AudioRendererOutputRate = 0;
pub const AudioRendererOutputRate_AudioRendererOutputRate_48kHz: AudioRendererOutputRate = 1;
pub type AudioRendererOutputRate = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AudioRendererConfig {
    pub output_rate: AudioRendererOutputRate,
    pub num_voices: ctypes::c_int,
    pub num_effects: ctypes::c_int,
    pub num_sinks: ctypes::c_int,
    pub num_mix_objs: ctypes::c_int,
    pub num_mix_buffers: ctypes::c_int,
}
#[test]
fn bindgen_test_layout_AudioRendererConfig() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererConfig>(),
        24usize,
        concat!("Size of: ", stringify!(AudioRendererConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioRendererConfig))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererConfig>())).output_rate as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererConfig),
            "::",
            stringify!(output_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererConfig>())).num_voices as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererConfig),
            "::",
            stringify!(num_voices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererConfig>())).num_effects as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererConfig),
            "::",
            stringify!(num_effects)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererConfig>())).num_sinks as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererConfig),
            "::",
            stringify!(num_sinks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererConfig>())).num_mix_objs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererConfig),
            "::",
            stringify!(num_mix_objs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererConfig>())).num_mix_buffers as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererConfig),
            "::",
            stringify!(num_mix_buffers)
        )
    );
}
#[repr(C)]
pub struct AudioRendererUpdateDataHeader {
    pub revision: u32,
    pub behavior_sz: u32,
    pub mempools_sz: u32,
    pub voices_sz: u32,
    pub channels_sz: u32,
    pub effects_sz: u32,
    pub mixes_sz: u32,
    pub sinks_sz: u32,
    pub perfmgr_sz: u32,
    pub _padding: [u32; 6usize],
    pub total_sz: u32,
}
#[test]
fn bindgen_test_layout_AudioRendererUpdateDataHeader() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererUpdateDataHeader>(),
        64usize,
        concat!("Size of: ", stringify!(AudioRendererUpdateDataHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererUpdateDataHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioRendererUpdateDataHeader))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererUpdateDataHeader>())).revision as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererUpdateDataHeader),
            "::",
            stringify!(revision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererUpdateDataHeader>())).behavior_sz as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererUpdateDataHeader),
            "::",
            stringify!(behavior_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererUpdateDataHeader>())).mempools_sz as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererUpdateDataHeader),
            "::",
            stringify!(mempools_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererUpdateDataHeader>())).voices_sz as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererUpdateDataHeader),
            "::",
            stringify!(voices_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererUpdateDataHeader>())).channels_sz as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererUpdateDataHeader),
            "::",
            stringify!(channels_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererUpdateDataHeader>())).effects_sz as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererUpdateDataHeader),
            "::",
            stringify!(effects_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererUpdateDataHeader>())).mixes_sz as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererUpdateDataHeader),
            "::",
            stringify!(mixes_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererUpdateDataHeader>())).sinks_sz as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererUpdateDataHeader),
            "::",
            stringify!(sinks_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererUpdateDataHeader>())).perfmgr_sz as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererUpdateDataHeader),
            "::",
            stringify!(perfmgr_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererUpdateDataHeader>()))._padding as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererUpdateDataHeader),
            "::",
            stringify!(_padding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererUpdateDataHeader>())).total_sz as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererUpdateDataHeader),
            "::",
            stringify!(total_sz)
        )
    );
}
#[repr(C)]
pub struct AudioRendererBehaviorInfoIn {
    pub revision: u32,
    pub _padding1: u32,
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_AudioRendererBehaviorInfoIn() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererBehaviorInfoIn>(),
        16usize,
        concat!("Size of: ", stringify!(AudioRendererBehaviorInfoIn))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererBehaviorInfoIn>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioRendererBehaviorInfoIn))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererBehaviorInfoIn>())).revision as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererBehaviorInfoIn),
            "::",
            stringify!(revision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererBehaviorInfoIn>()))._padding1 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererBehaviorInfoIn),
            "::",
            stringify!(_padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererBehaviorInfoIn>())).flags as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererBehaviorInfoIn),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
pub struct AudioRendererBehaviorInfoOut {
    pub unknown: [u64; 20usize],
    pub _padding1: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_AudioRendererBehaviorInfoOut() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererBehaviorInfoOut>(),
        176usize,
        concat!("Size of: ", stringify!(AudioRendererBehaviorInfoOut))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererBehaviorInfoOut>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioRendererBehaviorInfoOut))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererBehaviorInfoOut>())).unknown as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererBehaviorInfoOut),
            "::",
            stringify!(unknown)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererBehaviorInfoOut>()))._padding1 as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererBehaviorInfoOut),
            "::",
            stringify!(_padding1)
        )
    );
}
pub const AudioRendererMemPoolState_AudioRendererMemPoolState_Invalid: AudioRendererMemPoolState =
    0;
pub const AudioRendererMemPoolState_AudioRendererMemPoolState_New: AudioRendererMemPoolState = 1;
pub const AudioRendererMemPoolState_AudioRendererMemPoolState_RequestDetach:
    AudioRendererMemPoolState = 2;
pub const AudioRendererMemPoolState_AudioRendererMemPoolState_Detached: AudioRendererMemPoolState =
    3;
pub const AudioRendererMemPoolState_AudioRendererMemPoolState_RequestAttach:
    AudioRendererMemPoolState = 4;
pub const AudioRendererMemPoolState_AudioRendererMemPoolState_Attached: AudioRendererMemPoolState =
    5;
pub const AudioRendererMemPoolState_AudioRendererMemPoolState_Released: AudioRendererMemPoolState =
    6;
pub type AudioRendererMemPoolState = u32;
#[repr(C)]
pub struct AudioRendererMemPoolInfoIn {
    pub address: *const ctypes::c_void,
    pub size: u64,
    pub state: AudioRendererMemPoolState,
    pub _padding2: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_AudioRendererMemPoolInfoIn() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererMemPoolInfoIn>(),
        32usize,
        concat!("Size of: ", stringify!(AudioRendererMemPoolInfoIn))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererMemPoolInfoIn>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioRendererMemPoolInfoIn))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMemPoolInfoIn>())).address as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMemPoolInfoIn),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMemPoolInfoIn>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMemPoolInfoIn),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMemPoolInfoIn>())).state as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMemPoolInfoIn),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMemPoolInfoIn>()))._padding2 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMemPoolInfoIn),
            "::",
            stringify!(_padding2)
        )
    );
}
#[repr(C)]
pub struct AudioRendererMemPoolInfoOut {
    pub new_state: AudioRendererMemPoolState,
    pub _padding2: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_AudioRendererMemPoolInfoOut() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererMemPoolInfoOut>(),
        16usize,
        concat!("Size of: ", stringify!(AudioRendererMemPoolInfoOut))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererMemPoolInfoOut>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioRendererMemPoolInfoOut))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMemPoolInfoOut>())).new_state as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMemPoolInfoOut),
            "::",
            stringify!(new_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMemPoolInfoOut>()))._padding2 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMemPoolInfoOut),
            "::",
            stringify!(_padding2)
        )
    );
}
#[repr(C)]
pub struct AudioRendererChannelInfoIn {
    pub id: u32,
    pub mix: [f32; 24usize],
    pub is_used: bool,
    pub _padding1: [u8; 11usize],
}
#[test]
fn bindgen_test_layout_AudioRendererChannelInfoIn() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererChannelInfoIn>(),
        112usize,
        concat!("Size of: ", stringify!(AudioRendererChannelInfoIn))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererChannelInfoIn>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioRendererChannelInfoIn))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererChannelInfoIn>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererChannelInfoIn),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererChannelInfoIn>())).mix as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererChannelInfoIn),
            "::",
            stringify!(mix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererChannelInfoIn>())).is_used as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererChannelInfoIn),
            "::",
            stringify!(is_used)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererChannelInfoIn>()))._padding1 as *const _ as usize
        },
        101usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererChannelInfoIn),
            "::",
            stringify!(_padding1)
        )
    );
}
#[repr(C)]
pub struct AudioRendererBiquadFilter {
    pub enable: bool,
    pub _padding: u8,
    pub numerator: [s16; 3usize],
    pub denominator: [s16; 2usize],
}
#[test]
fn bindgen_test_layout_AudioRendererBiquadFilter() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererBiquadFilter>(),
        12usize,
        concat!("Size of: ", stringify!(AudioRendererBiquadFilter))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererBiquadFilter>(),
        2usize,
        concat!("Alignment of ", stringify!(AudioRendererBiquadFilter))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererBiquadFilter>())).enable as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererBiquadFilter),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererBiquadFilter>()))._padding as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererBiquadFilter),
            "::",
            stringify!(_padding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererBiquadFilter>())).numerator as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererBiquadFilter),
            "::",
            stringify!(numerator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererBiquadFilter>())).denominator as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererBiquadFilter),
            "::",
            stringify!(denominator)
        )
    );
}
#[repr(C)]
pub struct AudioRendererAdpcmParameters {
    pub coefficients: [u16; 16usize],
}
#[test]
fn bindgen_test_layout_AudioRendererAdpcmParameters() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererAdpcmParameters>(),
        32usize,
        concat!("Size of: ", stringify!(AudioRendererAdpcmParameters))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererAdpcmParameters>(),
        2usize,
        concat!("Alignment of ", stringify!(AudioRendererAdpcmParameters))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererAdpcmParameters>())).coefficients as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererAdpcmParameters),
            "::",
            stringify!(coefficients)
        )
    );
}
#[repr(C)]
pub struct AudioRendererAdpcmContext {
    pub index: u16,
    pub history0: s16,
    pub history1: s16,
}
#[test]
fn bindgen_test_layout_AudioRendererAdpcmContext() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererAdpcmContext>(),
        6usize,
        concat!("Size of: ", stringify!(AudioRendererAdpcmContext))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererAdpcmContext>(),
        2usize,
        concat!("Alignment of ", stringify!(AudioRendererAdpcmContext))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererAdpcmContext>())).index as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererAdpcmContext),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererAdpcmContext>())).history0 as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererAdpcmContext),
            "::",
            stringify!(history0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererAdpcmContext>())).history1 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererAdpcmContext),
            "::",
            stringify!(history1)
        )
    );
}
#[repr(C)]
pub struct AudioRendererWaveBuf {
    pub address: *const ctypes::c_void,
    pub size: u64,
    pub start_sample_offset: s32,
    pub end_sample_offset: s32,
    pub is_looping: bool,
    pub end_of_stream: bool,
    pub sent_to_server: bool,
    pub _padding1: [u8; 5usize],
    pub context_addr: *const ctypes::c_void,
    pub context_sz: u64,
    pub _padding2: u64,
}
#[test]
fn bindgen_test_layout_AudioRendererWaveBuf() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererWaveBuf>(),
        56usize,
        concat!("Size of: ", stringify!(AudioRendererWaveBuf))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererWaveBuf>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioRendererWaveBuf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererWaveBuf>())).address as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererWaveBuf),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererWaveBuf>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererWaveBuf),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererWaveBuf>())).start_sample_offset as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererWaveBuf),
            "::",
            stringify!(start_sample_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererWaveBuf>())).end_sample_offset as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererWaveBuf),
            "::",
            stringify!(end_sample_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererWaveBuf>())).is_looping as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererWaveBuf),
            "::",
            stringify!(is_looping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererWaveBuf>())).end_of_stream as *const _ as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererWaveBuf),
            "::",
            stringify!(end_of_stream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererWaveBuf>())).sent_to_server as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererWaveBuf),
            "::",
            stringify!(sent_to_server)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererWaveBuf>()))._padding1 as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererWaveBuf),
            "::",
            stringify!(_padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererWaveBuf>())).context_addr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererWaveBuf),
            "::",
            stringify!(context_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererWaveBuf>())).context_sz as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererWaveBuf),
            "::",
            stringify!(context_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererWaveBuf>()))._padding2 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererWaveBuf),
            "::",
            stringify!(_padding2)
        )
    );
}
pub const AudioRendererVoicePlayState_AudioRendererVoicePlayState_Started:
    AudioRendererVoicePlayState = 0;
pub const AudioRendererVoicePlayState_AudioRendererVoicePlayState_Stopped:
    AudioRendererVoicePlayState = 1;
pub const AudioRendererVoicePlayState_AudioRendererVoicePlayState_Paused:
    AudioRendererVoicePlayState = 2;
pub type AudioRendererVoicePlayState = u32;
#[repr(C)]
pub struct AudioRendererVoiceInfoIn {
    pub id: u32,
    pub node_id: u32,
    pub is_new: bool,
    pub is_used: bool,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub sample_rate: u32,
    pub priority: u32,
    pub sorting_order: u32,
    pub channel_count: u32,
    pub pitch: f32,
    pub volume: f32,
    pub biquads: [AudioRendererBiquadFilter; 2usize],
    pub wavebuf_count: u32,
    pub wavebuf_head: s16,
    pub _padding1: u16,
    pub _padding2: u32,
    pub extra_params_ptr: *const ctypes::c_void,
    pub extra_params_sz: u64,
    pub dest_mix_id: u32,
    pub dest_splitter_id: u32,
    pub wavebufs: [AudioRendererWaveBuf; 4usize],
    pub channel_ids: [u32; 6usize],
    pub _padding3: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_AudioRendererVoiceInfoIn() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererVoiceInfoIn>(),
        368usize,
        concat!("Size of: ", stringify!(AudioRendererVoiceInfoIn))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererVoiceInfoIn>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioRendererVoiceInfoIn))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).node_id as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(node_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).is_new as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(is_new)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).is_used as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(is_used)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).sample_rate as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).priority as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).sorting_order as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(sorting_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).channel_count as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(channel_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).pitch as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).volume as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(volume)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).biquads as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(biquads)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).wavebuf_count as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(wavebuf_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).wavebuf_head as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(wavebuf_head)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>()))._padding1 as *const _ as usize
        },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(_padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>()))._padding2 as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(_padding2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).extra_params_ptr as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(extra_params_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).extra_params_sz as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(extra_params_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).dest_mix_id as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(dest_mix_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).dest_splitter_id as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(dest_splitter_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).wavebufs as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(wavebufs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).channel_ids as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(channel_ids)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>()))._padding3 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(_padding3)
        )
    );
}
impl AudioRendererVoiceInfoIn {
    #[inline]
    pub fn state(&self) -> AudioRendererVoicePlayState {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: AudioRendererVoicePlayState) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sample_format(&self) -> PcmFormat {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sample_format(&mut self, val: PcmFormat) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state: AudioRendererVoicePlayState,
        sample_format: PcmFormat,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let state: u32 = unsafe { ::core::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let sample_format: u32 = unsafe { ::core::mem::transmute(sample_format) };
            sample_format as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct AudioRendererVoiceInfoOut {
    pub played_sample_count: u64,
    pub num_wavebufs_consumed: u32,
    pub voice_drops_count: u32,
}
#[test]
fn bindgen_test_layout_AudioRendererVoiceInfoOut() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererVoiceInfoOut>(),
        16usize,
        concat!("Size of: ", stringify!(AudioRendererVoiceInfoOut))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererVoiceInfoOut>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioRendererVoiceInfoOut))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoOut>())).played_sample_count as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoOut),
            "::",
            stringify!(played_sample_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoOut>())).num_wavebufs_consumed as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoOut),
            "::",
            stringify!(num_wavebufs_consumed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoOut>())).voice_drops_count as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoOut),
            "::",
            stringify!(voice_drops_count)
        )
    );
}
#[repr(C)]
pub struct AudioRendererMixInfoIn {
    pub volume: f32,
    pub sample_rate: u32,
    pub buffer_count: u32,
    pub is_used: bool,
    pub _padding1: [u8; 3usize],
    pub mix_id: u32,
    pub _padding2: u32,
    pub node_id: u32,
    pub _padding3: [u32; 2usize],
    pub mix: [[f32; 24usize]; 24usize],
    pub dest_mix_id: u32,
    pub dest_splitter_id: u32,
    pub _padding4: u32,
}
#[test]
fn bindgen_test_layout_AudioRendererMixInfoIn() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererMixInfoIn>(),
        2352usize,
        concat!("Size of: ", stringify!(AudioRendererMixInfoIn))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererMixInfoIn>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioRendererMixInfoIn))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererMixInfoIn>())).volume as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(volume)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMixInfoIn>())).sample_rate as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMixInfoIn>())).buffer_count as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(buffer_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererMixInfoIn>())).is_used as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(is_used)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMixInfoIn>()))._padding1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(_padding1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererMixInfoIn>())).mix_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(mix_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMixInfoIn>()))._padding2 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(_padding2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererMixInfoIn>())).node_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(node_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMixInfoIn>()))._padding3 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(_padding3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererMixInfoIn>())).mix as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(mix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMixInfoIn>())).dest_mix_id as *const _ as usize
        },
        2340usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(dest_mix_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMixInfoIn>())).dest_splitter_id as *const _
                as usize
        },
        2344usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(dest_splitter_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMixInfoIn>()))._padding4 as *const _ as usize
        },
        2348usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(_padding4)
        )
    );
}
#[repr(C)]
pub struct AudioRendererDownMixParameters {
    pub coefficients: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_AudioRendererDownMixParameters() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererDownMixParameters>(),
        16usize,
        concat!("Size of: ", stringify!(AudioRendererDownMixParameters))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererDownMixParameters>(),
        1usize,
        concat!("Alignment of ", stringify!(AudioRendererDownMixParameters))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererDownMixParameters>())).coefficients as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererDownMixParameters),
            "::",
            stringify!(coefficients)
        )
    );
}
pub const AudioRendererSinkType_AudioRendererSinkType_Invalid: AudioRendererSinkType = 0;
pub const AudioRendererSinkType_AudioRendererSinkType_Device: AudioRendererSinkType = 1;
pub const AudioRendererSinkType_AudioRendererSinkType_CircularBuffer: AudioRendererSinkType = 2;
pub type AudioRendererSinkType = u32;
#[repr(C)]
pub struct AudioRendererDeviceSinkInfoIn {
    pub name: [ctypes::c_char; 255usize],
    pub _padding1: u8,
    pub input_count: u32,
    pub inputs: [u8; 6usize],
    pub _padding2: u8,
    pub downmix_params_enabled: bool,
    pub downmix_params: AudioRendererDownMixParameters,
}
#[test]
fn bindgen_test_layout_AudioRendererDeviceSinkInfoIn() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererDeviceSinkInfoIn>(),
        284usize,
        concat!("Size of: ", stringify!(AudioRendererDeviceSinkInfoIn))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererDeviceSinkInfoIn>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioRendererDeviceSinkInfoIn))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererDeviceSinkInfoIn>())).name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererDeviceSinkInfoIn),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererDeviceSinkInfoIn>()))._padding1 as *const _
                as usize
        },
        255usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererDeviceSinkInfoIn),
            "::",
            stringify!(_padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererDeviceSinkInfoIn>())).input_count as *const _
                as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererDeviceSinkInfoIn),
            "::",
            stringify!(input_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererDeviceSinkInfoIn>())).inputs as *const _ as usize
        },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererDeviceSinkInfoIn),
            "::",
            stringify!(inputs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererDeviceSinkInfoIn>()))._padding2 as *const _
                as usize
        },
        266usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererDeviceSinkInfoIn),
            "::",
            stringify!(_padding2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererDeviceSinkInfoIn>())).downmix_params_enabled
                as *const _ as usize
        },
        267usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererDeviceSinkInfoIn),
            "::",
            stringify!(downmix_params_enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererDeviceSinkInfoIn>())).downmix_params as *const _
                as usize
        },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererDeviceSinkInfoIn),
            "::",
            stringify!(downmix_params)
        )
    );
}
#[repr(C)]
pub struct AudioRendererCircularBufferSinkInfoIn {
    pub buffer_ptr: *mut ctypes::c_void,
    pub buffer_sz: u32,
    pub input_count: u32,
    pub sample_count: u32,
    pub last_read_offset: u32,
    pub sample_format: PcmFormat,
    pub inputs: [u8; 6usize],
    pub _padding2: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_AudioRendererCircularBufferSinkInfoIn() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererCircularBufferSinkInfoIn>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(AudioRendererCircularBufferSinkInfoIn)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererCircularBufferSinkInfoIn>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(AudioRendererCircularBufferSinkInfoIn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererCircularBufferSinkInfoIn>())).buffer_ptr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererCircularBufferSinkInfoIn),
            "::",
            stringify!(buffer_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererCircularBufferSinkInfoIn>())).buffer_sz as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererCircularBufferSinkInfoIn),
            "::",
            stringify!(buffer_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererCircularBufferSinkInfoIn>())).input_count
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererCircularBufferSinkInfoIn),
            "::",
            stringify!(input_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererCircularBufferSinkInfoIn>())).sample_count
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererCircularBufferSinkInfoIn),
            "::",
            stringify!(sample_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererCircularBufferSinkInfoIn>())).last_read_offset
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererCircularBufferSinkInfoIn),
            "::",
            stringify!(last_read_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererCircularBufferSinkInfoIn>())).sample_format
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererCircularBufferSinkInfoIn),
            "::",
            stringify!(sample_format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererCircularBufferSinkInfoIn>())).inputs as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererCircularBufferSinkInfoIn),
            "::",
            stringify!(inputs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererCircularBufferSinkInfoIn>()))._padding2 as *const _
                as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererCircularBufferSinkInfoIn),
            "::",
            stringify!(_padding2)
        )
    );
}
#[repr(C)]
pub struct AudioRendererSinkInfoIn {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub is_used: bool,
    pub _padding1: [u8; 2usize],
    pub node_id: u32,
    pub _padding2: [u64; 3usize],
    pub __bindgen_anon_1: AudioRendererSinkInfoIn__bindgen_ty_1,
}
#[repr(C)]
pub struct AudioRendererSinkInfoIn__bindgen_ty_1 {
    pub device_sink: __BindgenUnionField<AudioRendererDeviceSinkInfoIn>,
    pub circular_buffer_sink: __BindgenUnionField<AudioRendererCircularBufferSinkInfoIn>,
    pub bindgen_union_field: [u64; 36usize],
}
#[test]
fn bindgen_test_layout_AudioRendererSinkInfoIn__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererSinkInfoIn__bindgen_ty_1>(),
        288usize,
        concat!(
            "Size of: ",
            stringify!(AudioRendererSinkInfoIn__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererSinkInfoIn__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(AudioRendererSinkInfoIn__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererSinkInfoIn__bindgen_ty_1>())).device_sink
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererSinkInfoIn__bindgen_ty_1),
            "::",
            stringify!(device_sink)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererSinkInfoIn__bindgen_ty_1>())).circular_buffer_sink
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererSinkInfoIn__bindgen_ty_1),
            "::",
            stringify!(circular_buffer_sink)
        )
    );
}
#[test]
fn bindgen_test_layout_AudioRendererSinkInfoIn() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererSinkInfoIn>(),
        320usize,
        concat!("Size of: ", stringify!(AudioRendererSinkInfoIn))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererSinkInfoIn>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioRendererSinkInfoIn))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererSinkInfoIn>())).is_used as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererSinkInfoIn),
            "::",
            stringify!(is_used)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererSinkInfoIn>()))._padding1 as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererSinkInfoIn),
            "::",
            stringify!(_padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererSinkInfoIn>())).node_id as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererSinkInfoIn),
            "::",
            stringify!(node_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererSinkInfoIn>()))._padding2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererSinkInfoIn),
            "::",
            stringify!(_padding2)
        )
    );
}
impl AudioRendererSinkInfoIn {
    #[inline]
    pub fn type_(&self) -> AudioRendererSinkType {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: AudioRendererSinkType) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(type_: AudioRendererSinkType) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct AudioRendererSinkInfoOut {
    pub last_written_offset: u32,
    pub unk1: u32,
    pub unk2: u64,
    pub _padding1: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_AudioRendererSinkInfoOut() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererSinkInfoOut>(),
        32usize,
        concat!("Size of: ", stringify!(AudioRendererSinkInfoOut))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererSinkInfoOut>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioRendererSinkInfoOut))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererSinkInfoOut>())).last_written_offset as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererSinkInfoOut),
            "::",
            stringify!(last_written_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererSinkInfoOut>())).unk1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererSinkInfoOut),
            "::",
            stringify!(unk1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererSinkInfoOut>())).unk2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererSinkInfoOut),
            "::",
            stringify!(unk2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererSinkInfoOut>()))._padding1 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererSinkInfoOut),
            "::",
            stringify!(_padding1)
        )
    );
}
#[repr(C)]
pub struct AudioRendererPerformanceBufferInfoIn {
    pub detail_target: u32,
    pub _padding1: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_AudioRendererPerformanceBufferInfoIn() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererPerformanceBufferInfoIn>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(AudioRendererPerformanceBufferInfoIn)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererPerformanceBufferInfoIn>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(AudioRendererPerformanceBufferInfoIn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererPerformanceBufferInfoIn>())).detail_target
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererPerformanceBufferInfoIn),
            "::",
            stringify!(detail_target)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererPerformanceBufferInfoIn>()))._padding1 as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererPerformanceBufferInfoIn),
            "::",
            stringify!(_padding1)
        )
    );
}
#[repr(C)]
pub struct AudioRendererPerformanceBufferInfoOut {
    pub written_sz: u32,
    pub _padding1: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_AudioRendererPerformanceBufferInfoOut() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererPerformanceBufferInfoOut>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(AudioRendererPerformanceBufferInfoOut)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererPerformanceBufferInfoOut>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(AudioRendererPerformanceBufferInfoOut)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererPerformanceBufferInfoOut>())).written_sz
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererPerformanceBufferInfoOut),
            "::",
            stringify!(written_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererPerformanceBufferInfoOut>()))._padding1 as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererPerformanceBufferInfoOut),
            "::",
            stringify!(_padding1)
        )
    );
}
extern "C" {
    pub fn audrenInitialize(config: *const AudioRendererConfig) -> Result;
}
extern "C" {
    pub fn audrenExit();
}
extern "C" {
    pub fn audrenWaitFrame();
}
extern "C" {
    pub fn audrenGetState(out_state: *mut u32) -> Result;
}
extern "C" {
    pub fn audrenRequestUpdateAudioRenderer(
        in_param_buf: *const ctypes::c_void,
        in_param_buf_size: usize,
        out_param_buf: *mut ctypes::c_void,
        out_param_buf_size: usize,
        perf_buf: *mut ctypes::c_void,
        perf_buf_size: usize,
    ) -> Result;
}
extern "C" {
    pub fn audrenStartAudioRenderer() -> Result;
}
extern "C" {
    pub fn audrenStopAudioRenderer() -> Result;
}
extern "C" {
    pub fn audrenSetAudioRendererRenderingTimeLimit(percent: ctypes::c_int) -> Result;
}
extern "C" {
    pub fn auddevInitialize() -> Result;
}
extern "C" {
    pub fn auddevExit();
}
extern "C" {
    pub fn auddevListAudioDeviceName(
        DeviceNames: *mut AudioDeviceName,
        max_names: s32,
        total_names: *mut s32,
    ) -> Result;
}
extern "C" {
    pub fn auddevSetAudioDeviceOutputVolume(
        DeviceName: *const AudioDeviceName,
        volume: f32,
    ) -> Result;
}
extern "C" {
    pub fn auddevGetAudioDeviceOutputVolume(
        DeviceName: *const AudioDeviceName,
        volume: *mut f32,
    ) -> Result;
}
#[repr(C)]
pub struct HwopusDecoder {
    pub s: Service,
    pub tmem: TransferMemory,
    pub multistream: bool,
}
#[test]
fn bindgen_test_layout_HwopusDecoder() {
    assert_eq!(
        ::core::mem::size_of::<HwopusDecoder>(),
        64usize,
        concat!("Size of: ", stringify!(HwopusDecoder))
    );
    assert_eq!(
        ::core::mem::align_of::<HwopusDecoder>(),
        8usize,
        concat!("Alignment of ", stringify!(HwopusDecoder))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HwopusDecoder>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HwopusDecoder),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HwopusDecoder>())).tmem as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HwopusDecoder),
            "::",
            stringify!(tmem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HwopusDecoder>())).multistream as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(HwopusDecoder),
            "::",
            stringify!(multistream)
        )
    );
}
/// This structure is the start of opusin for \ref hwopusDecodeInterleaved, with the actual opus packet following this.
/// These fields are big-endian.
#[repr(C)]
pub struct HwopusHeader {
    /// < Size of the packet following this header.
    pub size: u32,
    /// < Indicates the final range of the codec encoder's entropy coder. This can be left at zero.
    pub final_range: u32,
}
#[test]
fn bindgen_test_layout_HwopusHeader() {
    assert_eq!(
        ::core::mem::size_of::<HwopusHeader>(),
        8usize,
        concat!("Size of: ", stringify!(HwopusHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<HwopusHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(HwopusHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HwopusHeader>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HwopusHeader),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HwopusHeader>())).final_range as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HwopusHeader),
            "::",
            stringify!(final_range)
        )
    );
}
/// Used internally.
#[repr(C)]
pub struct HwopusMultistreamState {
    pub SampleRate: s32,
    pub ChannelCount: s32,
    pub TotalStreamCount: s32,
    pub StereoStreamCount: s32,
    pub channel_mapping: [u8; 256usize],
}
#[test]
fn bindgen_test_layout_HwopusMultistreamState() {
    assert_eq!(
        ::core::mem::size_of::<HwopusMultistreamState>(),
        272usize,
        concat!("Size of: ", stringify!(HwopusMultistreamState))
    );
    assert_eq!(
        ::core::mem::align_of::<HwopusMultistreamState>(),
        4usize,
        concat!("Alignment of ", stringify!(HwopusMultistreamState))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HwopusMultistreamState>())).SampleRate as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HwopusMultistreamState),
            "::",
            stringify!(SampleRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HwopusMultistreamState>())).ChannelCount as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HwopusMultistreamState),
            "::",
            stringify!(ChannelCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HwopusMultistreamState>())).TotalStreamCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HwopusMultistreamState),
            "::",
            stringify!(TotalStreamCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HwopusMultistreamState>())).StereoStreamCount as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HwopusMultistreamState),
            "::",
            stringify!(StereoStreamCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HwopusMultistreamState>())).channel_mapping as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HwopusMultistreamState),
            "::",
            stringify!(channel_mapping)
        )
    );
}
extern "C" {
    pub fn hwopusDecoderInitialize(
        decoder: *mut HwopusDecoder,
        SampleRate: s32,
        ChannelCount: s32,
    ) -> Result;
}
extern "C" {
    pub fn hwopusDecoderExit(decoder: *mut HwopusDecoder);
}
extern "C" {
    /// Only available on 3.0.0+.
    /// See libopus multistream docs.
    pub fn hwopusDecoderMultistreamInitialize(
        decoder: *mut HwopusDecoder,
        SampleRate: s32,
        ChannelCount: s32,
        TotalStreamCount: s32,
        StereoStreamCount: s32,
        channel_mapping: *mut u8,
    ) -> Result;
}
extern "C" {
    /// Decodes opus data.
    pub fn hwopusDecodeInterleaved(
        decoder: *mut HwopusDecoder,
        DecodedDataSize: *mut s32,
        DecodedSampleCount: *mut s32,
        opusin: *const ctypes::c_void,
        opusin_size: usize,
        pcmbuf: *mut s16,
        pcmbuf_size: usize,
    ) -> Result;
}
extern "C" {
    pub fn csrngInitialize() -> Result;
}
extern "C" {
    pub fn csrngExit();
}
extern "C" {
    pub fn csrngGetRandomBytes(out: *mut ctypes::c_void, out_size: usize) -> Result;
}
extern "C" {
    pub fn lblInitialize() -> Result;
}
extern "C" {
    pub fn lblExit();
}
extern "C" {
    pub fn lblSwitchBacklightOn(fade_time: u64) -> Result;
}
extern "C" {
    pub fn lblSwitchBacklightOff(fade_time: u64) -> Result;
}
extern "C" {
    /// @note The brightness goes from 0 to 1.0.
    pub fn lblSetCurrentBrightnessSetting(brightness: f32) -> Result;
}
extern "C" {
    pub fn lblGetCurrentBrightnessSetting(out_value: *mut f32) -> Result;
}
extern "C" {
    pub fn lblEnableAutoBrightnessControl() -> Result;
}
extern "C" {
    pub fn lblDisableAutoBrightnessControl() -> Result;
}
extern "C" {
    pub fn lblIsAutoBrightnessControlEnabled(out_value: *mut bool) -> Result;
}
pub const I2cDevice_I2cDevice_AudioCodec: I2cDevice = 4;
pub type I2cDevice = u32;
#[repr(C)]
pub struct I2cSession {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_I2cSession() {
    assert_eq!(
        ::core::mem::size_of::<I2cSession>(),
        12usize,
        concat!("Size of: ", stringify!(I2cSession))
    );
    assert_eq!(
        ::core::mem::align_of::<I2cSession>(),
        4usize,
        concat!("Alignment of ", stringify!(I2cSession))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2cSession>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2cSession),
            "::",
            stringify!(s)
        )
    );
}
pub const I2cTransactionOption_I2cTransactionOption_Start: I2cTransactionOption = 1;
pub const I2cTransactionOption_I2cTransactionOption_Stop: I2cTransactionOption = 2;
pub const I2cTransactionOption_I2cTransactionOption_All: I2cTransactionOption = 3;
pub type I2cTransactionOption = u32;
extern "C" {
    pub fn i2cInitialize() -> Result;
}
extern "C" {
    pub fn i2cExit();
}
extern "C" {
    pub fn i2cOpenSession(out: *mut I2cSession, dev: I2cDevice) -> Result;
}
extern "C" {
    pub fn i2csessionSendAuto(
        s: *mut I2cSession,
        buf: *mut ctypes::c_void,
        size: usize,
        option: I2cTransactionOption,
    ) -> Result;
}
extern "C" {
    pub fn i2csessionClose(s: *mut I2cSession);
}
pub const GpioPadName_GpioPadName_AudioCodec: GpioPadName = 1;
pub const GpioPadName_GpioPadName_ButtonVolUp: GpioPadName = 25;
pub const GpioPadName_GpioPadName_ButtonVolDown: GpioPadName = 26;
pub type GpioPadName = u32;
#[repr(C)]
pub struct GpioPadSession {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_GpioPadSession() {
    assert_eq!(
        ::core::mem::size_of::<GpioPadSession>(),
        12usize,
        concat!("Size of: ", stringify!(GpioPadSession))
    );
    assert_eq!(
        ::core::mem::align_of::<GpioPadSession>(),
        4usize,
        concat!("Alignment of ", stringify!(GpioPadSession))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GpioPadSession>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GpioPadSession),
            "::",
            stringify!(s)
        )
    );
}
pub const GpioDirection_GpioDirection_Input: GpioDirection = 0;
pub const GpioDirection_GpioDirection_Output: GpioDirection = 1;
pub type GpioDirection = u32;
pub const GpioValue_GpioValue_Low: GpioValue = 0;
pub const GpioValue_GpioValue_High: GpioValue = 1;
pub type GpioValue = u32;
extern "C" {
    pub fn gpioInitialize() -> Result;
}
extern "C" {
    pub fn gpioExit();
}
extern "C" {
    pub fn gpioOpenSession(out: *mut GpioPadSession, name: GpioPadName) -> Result;
}
extern "C" {
    pub fn gpioPadSetDirection(p: *mut GpioPadSession, dir: GpioDirection) -> Result;
}
extern "C" {
    pub fn gpioPadGetDirection(p: *mut GpioPadSession, out: *mut GpioDirection) -> Result;
}
extern "C" {
    pub fn gpioPadSetValue(p: *mut GpioPadSession, val: GpioValue) -> Result;
}
extern "C" {
    pub fn gpioPadGetValue(p: *mut GpioPadSession, out: *mut GpioValue) -> Result;
}
extern "C" {
    pub fn gpioPadClose(p: *mut GpioPadSession);
}
pub const BpcSleepButtonState_BpcSleepButtonState_Held: BpcSleepButtonState = 0;
pub const BpcSleepButtonState_BpcSleepButtonState_Released: BpcSleepButtonState = 1;
pub type BpcSleepButtonState = u32;
extern "C" {
    pub fn bpcInitialize() -> Result;
}
extern "C" {
    pub fn bpcExit();
}
extern "C" {
    pub fn bpcShutdownSystem() -> Result;
}
extern "C" {
    pub fn bpcRebootSystem() -> Result;
}
extern "C" {
    pub fn bpcGetSleepButtonState(out: *mut BpcSleepButtonState) -> Result;
}
pub const PcvModule_PcvModule_Cpu: PcvModule = 0;
pub const PcvModule_PcvModule_Gpu: PcvModule = 1;
pub const PcvModule_PcvModule_Emc: PcvModule = 56;
pub type PcvModule = u32;
extern "C" {
    pub fn pcvInitialize() -> Result;
}
extern "C" {
    pub fn pcvExit();
}
extern "C" {
    pub fn pcvGetClockRate(module: PcvModule, out_hz: *mut u32) -> Result;
}
extern "C" {
    pub fn pcvSetClockRate(module: PcvModule, hz: u32) -> Result;
}
extern "C" {
    pub fn pcvSetVoltageEnabled(state: bool, voltage: u32) -> Result;
}
extern "C" {
    pub fn pcvGetVoltageEnabled(isEnabled: *mut bool, voltage: u32) -> Result;
}
/// < No charger
pub const ChargerType_ChargerType_None: ChargerType = 0;
/// < Official charger or dock
pub const ChargerType_ChargerType_Charger: ChargerType = 1;
/// < Other USB-C chargers
pub const ChargerType_ChargerType_Usb: ChargerType = 2;
pub type ChargerType = u32;
/// < Power state should transition to shutdown
pub const PsmBatteryVoltageState_PsmBatteryVoltageState_NeedsShutdown: PsmBatteryVoltageState = 0;
/// < Power state should transition to sleep
pub const PsmBatteryVoltageState_PsmBatteryVoltageState_NeedsSleep: PsmBatteryVoltageState = 1;
/// < Performance boost modes cannot be entered
pub const PsmBatteryVoltageState_PsmBatteryVoltageState_NoPerformanceBoost: PsmBatteryVoltageState =
    2;
/// < Everything is normal
pub const PsmBatteryVoltageState_PsmBatteryVoltageState_Normal: PsmBatteryVoltageState = 3;
pub type PsmBatteryVoltageState = u32;
/// IPsmSession
#[repr(C)]
pub struct PsmSession {
    pub s: Service,
    /// < autoclear=false
    pub StateChangeEvent: Event,
}
#[test]
fn bindgen_test_layout_PsmSession() {
    assert_eq!(
        ::core::mem::size_of::<PsmSession>(),
        24usize,
        concat!("Size of: ", stringify!(PsmSession))
    );
    assert_eq!(
        ::core::mem::align_of::<PsmSession>(),
        4usize,
        concat!("Alignment of ", stringify!(PsmSession))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PsmSession>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PsmSession),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PsmSession>())).StateChangeEvent as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PsmSession),
            "::",
            stringify!(StateChangeEvent)
        )
    );
}
extern "C" {
    pub fn psmInitialize() -> Result;
}
extern "C" {
    pub fn psmExit();
}
extern "C" {
    pub fn psmGetBatteryChargePercentage(out: *mut u32) -> Result;
}
extern "C" {
    pub fn psmGetChargerType(out: *mut ChargerType) -> Result;
}
extern "C" {
    pub fn psmGetBatteryVoltageState(out: *mut PsmBatteryVoltageState) -> Result;
}
extern "C" {
    /// @brief Wrapper func which opens a PsmSession and handles event setup.
    /// @note Uses the actual BindStateChangeEvent cmd internally.
    /// @note The event is not signalled on BatteryChargePercentage changes.
    /// @param[out] s PsmSession object.
    /// @param[in] ChargerType Passed to SetChargerTypeChangeEventEnabled.
    /// @param[in] PowerSupply Passed to SetPowerSupplyChangeEventEnabled.
    /// @param[in] BatteryVoltage Passed to SetBatteryVoltageStateChangeEventEnabled.
    pub fn psmBindStateChangeEvent(
        s: *mut PsmSession,
        ChargerType: bool,
        PowerSupply: bool,
        BatteryVoltage: bool,
    ) -> Result;
}
extern "C" {
    /// Wait on the Event setup by \ref psmBindStateChangeEvent.
    pub fn psmWaitStateChangeEvent(s: *mut PsmSession, timeout: u64) -> Result;
}
extern "C" {
    /// Cleanup version of \ref psmBindStateChangeEvent. Must be called by the user once the PsmSession is done being used.
    pub fn psmUnbindStateChangeEvent(s: *mut PsmSession) -> Result;
}
extern "C" {
    pub fn spsmInitialize() -> Result;
}
extern "C" {
    pub fn spsmExit();
}
extern "C" {
    pub fn spsmShutdown(reboot: bool) -> Result;
}
extern "C" {
    pub fn spsmPutErrorState() -> Result;
}
pub const FatalType_FatalType_ErrorReportAndErrorScreen: FatalType = 0;
pub const FatalType_FatalType_ErrorReport: FatalType = 1;
/// < Only available with 3.0.0+. If specified, FatalType_ErrorReportAndErrorScreen will be used instead on pre-3.0.0.
pub const FatalType_FatalType_ErrorScreen: FatalType = 2;
/// Type of thrown fatal error.
pub type FatalType = u32;
/// Struct for fatal Cpu context, 64-bit.
#[repr(C)]
pub struct FatalAarch64Context {
    pub __bindgen_anon_1: FatalAarch64Context__bindgen_ty_1,
    pub pstate: u64,
    pub afsr0: u64,
    pub afsr1: u64,
    pub esr: u64,
    pub far: u64,
    pub stack_trace: [u64; 32usize],
    /// < Address of first NSO loaded (generally, process entrypoint).
    pub start_address: u64,
    /// < Bitmask, bit i indicates GPR i has a value.
    pub register_set_flags: u64,
    pub stack_trace_size: u32,
}
#[repr(C)]
pub struct FatalAarch64Context__bindgen_ty_1 {
    pub x: __BindgenUnionField<[u64; 32usize]>,
    pub __bindgen_anon_1: __BindgenUnionField<FatalAarch64Context__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 33usize],
}
#[repr(C)]
pub struct FatalAarch64Context__bindgen_ty_1__bindgen_ty_1 {
    pub _x: [u64; 29usize],
    pub fp: u64,
    pub lr: u64,
    pub sp: u64,
    pub pc: u64,
}
#[test]
fn bindgen_test_layout_FatalAarch64Context__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<FatalAarch64Context__bindgen_ty_1__bindgen_ty_1>(),
        264usize,
        concat!(
            "Size of: ",
            stringify!(FatalAarch64Context__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<FatalAarch64Context__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FatalAarch64Context__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch64Context__bindgen_ty_1__bindgen_ty_1>()))._x
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch64Context__bindgen_ty_1__bindgen_ty_1>())).fp
                as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch64Context__bindgen_ty_1__bindgen_ty_1>())).lr
                as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(lr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch64Context__bindgen_ty_1__bindgen_ty_1>())).sp
                as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch64Context__bindgen_ty_1__bindgen_ty_1>())).pc
                as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pc)
        )
    );
}
#[test]
fn bindgen_test_layout_FatalAarch64Context__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<FatalAarch64Context__bindgen_ty_1>(),
        264usize,
        concat!("Size of: ", stringify!(FatalAarch64Context__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<FatalAarch64Context__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FatalAarch64Context__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch64Context__bindgen_ty_1>())).x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
}
#[test]
fn bindgen_test_layout_FatalAarch64Context() {
    assert_eq!(
        ::core::mem::size_of::<FatalAarch64Context>(),
        584usize,
        concat!("Size of: ", stringify!(FatalAarch64Context))
    );
    assert_eq!(
        ::core::mem::align_of::<FatalAarch64Context>(),
        8usize,
        concat!("Alignment of ", stringify!(FatalAarch64Context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FatalAarch64Context>())).pstate as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context),
            "::",
            stringify!(pstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FatalAarch64Context>())).afsr0 as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context),
            "::",
            stringify!(afsr0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FatalAarch64Context>())).afsr1 as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context),
            "::",
            stringify!(afsr1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FatalAarch64Context>())).esr as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context),
            "::",
            stringify!(esr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FatalAarch64Context>())).far as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context),
            "::",
            stringify!(far)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch64Context>())).stack_trace as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context),
            "::",
            stringify!(stack_trace)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch64Context>())).start_address as *const _ as usize
        },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context),
            "::",
            stringify!(start_address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch64Context>())).register_set_flags as *const _ as usize
        },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context),
            "::",
            stringify!(register_set_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch64Context>())).stack_trace_size as *const _ as usize
        },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context),
            "::",
            stringify!(stack_trace_size)
        )
    );
}
/// Struct for fatal Cpu context, 32-bit.
#[repr(C)]
pub struct FatalAarch32Context {
    pub __bindgen_anon_1: FatalAarch32Context__bindgen_ty_1,
    pub pstate: u32,
    pub afsr0: u32,
    pub afsr1: u32,
    pub esr: u32,
    pub far: u32,
    pub stack_trace: [u32; 32usize],
    pub stack_trace_size: u32,
    /// < Address of first NSO loaded (generally, process entrypoint).
    pub start_address: u32,
    /// < Bitmask, bit i indicates GPR i has a value.
    pub register_set_flags: u32,
}
#[repr(C)]
pub struct FatalAarch32Context__bindgen_ty_1 {
    pub r: __BindgenUnionField<[u32; 16usize]>,
    pub __bindgen_anon_1: __BindgenUnionField<FatalAarch32Context__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u32; 16usize],
}
#[repr(C)]
pub struct FatalAarch32Context__bindgen_ty_1__bindgen_ty_1 {
    pub _r: [u32; 11usize],
    pub fp: u32,
    pub ip: u32,
    pub sp: u32,
    pub lr: u32,
    pub pc: u32,
}
#[test]
fn bindgen_test_layout_FatalAarch32Context__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<FatalAarch32Context__bindgen_ty_1__bindgen_ty_1>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(FatalAarch32Context__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<FatalAarch32Context__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(FatalAarch32Context__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch32Context__bindgen_ty_1__bindgen_ty_1>()))._r
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch32Context__bindgen_ty_1__bindgen_ty_1>())).fp
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch32Context__bindgen_ty_1__bindgen_ty_1>())).ip
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch32Context__bindgen_ty_1__bindgen_ty_1>())).sp
                as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch32Context__bindgen_ty_1__bindgen_ty_1>())).lr
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(lr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch32Context__bindgen_ty_1__bindgen_ty_1>())).pc
                as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pc)
        )
    );
}
#[test]
fn bindgen_test_layout_FatalAarch32Context__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<FatalAarch32Context__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(FatalAarch32Context__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<FatalAarch32Context__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(FatalAarch32Context__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch32Context__bindgen_ty_1>())).r as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context__bindgen_ty_1),
            "::",
            stringify!(r)
        )
    );
}
#[test]
fn bindgen_test_layout_FatalAarch32Context() {
    assert_eq!(
        ::core::mem::size_of::<FatalAarch32Context>(),
        224usize,
        concat!("Size of: ", stringify!(FatalAarch32Context))
    );
    assert_eq!(
        ::core::mem::align_of::<FatalAarch32Context>(),
        4usize,
        concat!("Alignment of ", stringify!(FatalAarch32Context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FatalAarch32Context>())).pstate as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context),
            "::",
            stringify!(pstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FatalAarch32Context>())).afsr0 as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context),
            "::",
            stringify!(afsr0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FatalAarch32Context>())).afsr1 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context),
            "::",
            stringify!(afsr1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FatalAarch32Context>())).esr as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context),
            "::",
            stringify!(esr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FatalAarch32Context>())).far as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context),
            "::",
            stringify!(far)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch32Context>())).stack_trace as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context),
            "::",
            stringify!(stack_trace)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch32Context>())).stack_trace_size as *const _ as usize
        },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context),
            "::",
            stringify!(stack_trace_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch32Context>())).start_address as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context),
            "::",
            stringify!(start_address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch32Context>())).register_set_flags as *const _ as usize
        },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context),
            "::",
            stringify!(register_set_flags)
        )
    );
}
#[repr(C)]
pub struct FatalContext {
    pub __bindgen_anon_1: FatalContext__bindgen_ty_1,
    pub is_aarch32: bool,
    pub type_: u32,
}
#[repr(C)]
pub struct FatalContext__bindgen_ty_1 {
    pub aarch64_ctx: __BindgenUnionField<FatalAarch64Context>,
    pub aarch32_ctx: __BindgenUnionField<FatalAarch32Context>,
    pub bindgen_union_field: [u64; 73usize],
}
#[test]
fn bindgen_test_layout_FatalContext__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<FatalContext__bindgen_ty_1>(),
        584usize,
        concat!("Size of: ", stringify!(FatalContext__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<FatalContext__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(FatalContext__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalContext__bindgen_ty_1>())).aarch64_ctx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalContext__bindgen_ty_1),
            "::",
            stringify!(aarch64_ctx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalContext__bindgen_ty_1>())).aarch32_ctx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalContext__bindgen_ty_1),
            "::",
            stringify!(aarch32_ctx)
        )
    );
}
#[test]
fn bindgen_test_layout_FatalContext() {
    assert_eq!(
        ::core::mem::size_of::<FatalContext>(),
        592usize,
        concat!("Size of: ", stringify!(FatalContext))
    );
    assert_eq!(
        ::core::mem::align_of::<FatalContext>(),
        8usize,
        concat!("Alignment of ", stringify!(FatalContext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FatalContext>())).is_aarch32 as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalContext),
            "::",
            stringify!(is_aarch32)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FatalContext>())).type_ as *const _ as usize },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalContext),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    /// @brief Triggers a system fatal error.
    /// @param[in] err Result code to throw.
    /// @note This function does not return.
    /// @note This uses \ref fatalWithType with \ref FatalType_ErrorScreen internally.
    pub fn fatalSimple(err: Result);
}
extern "C" {
    /// @brief Triggers a system fatal error with a custom \ref FatalType.
    /// @param[in] err Result code to throw.
    /// @param[in] type Type of fatal error to throw.
    /// @note This function may not return, depending on \ref FatalType.
    pub fn fatalWithType(err: Result, type_: FatalType);
}
extern "C" {
    /// @brief Triggers a system fatal error with a custom \ref FatalType and \ref FatalContext.
    /// @param[in] err  Result code to throw.
    /// @param[in] type Type of fatal error to throw.
    /// @param[in] ctx  Cpu context for fatal error to throw.
    /// @note This function may not return, depending on \ref FatalType.
    pub fn fatalWithContext(err: Result, type_: FatalType, ctx: *mut FatalContext);
}
pub const TimeType_TimeType_UserSystemClock: TimeType = 0;
pub const TimeType_TimeType_NetworkSystemClock: TimeType = 1;
pub const TimeType_TimeType_LocalSystemClock: TimeType = 2;
pub const TimeType_TimeType_Default: TimeType = 0;
/// Time clock type.
pub type TimeType = u32;
#[repr(C)]
pub struct TimeCalendarTime {
    pub year: u16,
    pub month: u8,
    pub day: u8,
    pub hour: u8,
    pub minute: u8,
    pub second: u8,
    pub pad: u8,
}
#[test]
fn bindgen_test_layout_TimeCalendarTime() {
    assert_eq!(
        ::core::mem::size_of::<TimeCalendarTime>(),
        8usize,
        concat!("Size of: ", stringify!(TimeCalendarTime))
    );
    assert_eq!(
        ::core::mem::align_of::<TimeCalendarTime>(),
        2usize,
        concat!("Alignment of ", stringify!(TimeCalendarTime))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TimeCalendarTime>())).year as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeCalendarTime),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TimeCalendarTime>())).month as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeCalendarTime),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TimeCalendarTime>())).day as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeCalendarTime),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TimeCalendarTime>())).hour as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeCalendarTime),
            "::",
            stringify!(hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TimeCalendarTime>())).minute as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeCalendarTime),
            "::",
            stringify!(minute)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TimeCalendarTime>())).second as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeCalendarTime),
            "::",
            stringify!(second)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TimeCalendarTime>())).pad as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeCalendarTime),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
pub struct TimeCalendarAdditionalInfo {
    /// < 0-based day-of-week.
    pub wday: u32,
    /// < 0-based day-of-year.
    pub yday: u32,
    /// < Timezone name string.
    pub timezoneName: [ctypes::c_char; 8usize],
    /// < 0 = no DST, 1 = DST.
    pub DST: u32,
    /// < Seconds relative to UTC for this timezone.
    pub offset: s32,
}
#[test]
fn bindgen_test_layout_TimeCalendarAdditionalInfo() {
    assert_eq!(
        ::core::mem::size_of::<TimeCalendarAdditionalInfo>(),
        24usize,
        concat!("Size of: ", stringify!(TimeCalendarAdditionalInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<TimeCalendarAdditionalInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(TimeCalendarAdditionalInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TimeCalendarAdditionalInfo>())).wday as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeCalendarAdditionalInfo),
            "::",
            stringify!(wday)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TimeCalendarAdditionalInfo>())).yday as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeCalendarAdditionalInfo),
            "::",
            stringify!(yday)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TimeCalendarAdditionalInfo>())).timezoneName as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeCalendarAdditionalInfo),
            "::",
            stringify!(timezoneName)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TimeCalendarAdditionalInfo>())).DST as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeCalendarAdditionalInfo),
            "::",
            stringify!(DST)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TimeCalendarAdditionalInfo>())).offset as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeCalendarAdditionalInfo),
            "::",
            stringify!(offset)
        )
    );
}
extern "C" {
    pub fn timeInitialize() -> Result;
}
extern "C" {
    pub fn timeExit();
}
extern "C" {
    pub fn timeGetSessionService() -> *mut Service;
}
extern "C" {
    pub fn timeGetCurrentTime(type_: TimeType, timestamp: *mut u64) -> Result;
}
extern "C" {
    /// @brief Sets the time for the specified clock.
    /// @param[in] type Clock to use.
    /// @param[in] timestamp POSIX UTC timestamp.
    /// @return Result code.
    pub fn timeSetCurrentTime(type_: TimeType, timestamp: u64) -> Result;
}
extern "C" {
    pub fn timeToCalendarTimeWithMyRule(
        timestamp: u64,
        caltime: *mut TimeCalendarTime,
        info: *mut TimeCalendarAdditionalInfo,
    ) -> Result;
}
/// Imported from libusb, with some adjustments.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_endpoint_descriptor {
    pub bLength: u8,
    /// < Must match USB_DT_ENDPOINT.
    pub bDescriptorType: u8,
    /// < Should be one of the usb_endpoint_direction values, the endpoint-number is automatically allocated.
    pub bEndpointAddress: u8,
    pub bmAttributes: u8,
    pub wMaxPacketSize: u16,
    pub bInterval: u8,
}
#[test]
fn bindgen_test_layout_usb_endpoint_descriptor() {
    assert_eq!(
        ::core::mem::size_of::<usb_endpoint_descriptor>(),
        7usize,
        concat!("Size of: ", stringify!(usb_endpoint_descriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_endpoint_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_endpoint_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_endpoint_descriptor>())).bLength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_endpoint_descriptor>())).bDescriptorType as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_endpoint_descriptor>())).bEndpointAddress as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor),
            "::",
            stringify!(bEndpointAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_endpoint_descriptor>())).bmAttributes as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor),
            "::",
            stringify!(bmAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_endpoint_descriptor>())).wMaxPacketSize as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor),
            "::",
            stringify!(wMaxPacketSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_endpoint_descriptor>())).bInterval as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor),
            "::",
            stringify!(bInterval)
        )
    );
}
/// Imported from libusb, with some adjustments.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_interface_descriptor {
    pub bLength: u8,
    /// < Must match USB_DT_INTERFACE.
    pub bDescriptorType: u8,
    /// < See also USBDS_DEFAULT_InterfaceNumber.
    pub bInterfaceNumber: u8,
    /// < Must match 0.
    pub bAlternateSetting: u8,
    pub bNumEndpoints: u8,
    pub bInterfaceClass: u8,
    pub bInterfaceSubClass: u8,
    pub bInterfaceProtocol: u8,
    /// < Ignored.
    pub iInterface: u8,
}
#[test]
fn bindgen_test_layout_usb_interface_descriptor() {
    assert_eq!(
        ::core::mem::size_of::<usb_interface_descriptor>(),
        9usize,
        concat!("Size of: ", stringify!(usb_interface_descriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_interface_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_interface_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_interface_descriptor>())).bLength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_interface_descriptor>())).bDescriptorType as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_interface_descriptor>())).bInterfaceNumber as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(bInterfaceNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_interface_descriptor>())).bAlternateSetting as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(bAlternateSetting)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_interface_descriptor>())).bNumEndpoints as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(bNumEndpoints)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_interface_descriptor>())).bInterfaceClass as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(bInterfaceClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_interface_descriptor>())).bInterfaceSubClass as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(bInterfaceSubClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_interface_descriptor>())).bInterfaceProtocol as *const _
                as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(bInterfaceProtocol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_interface_descriptor>())).iInterface as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(iInterface)
        )
    );
}
/// Imported from libusb, with some adjustments.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_device_descriptor {
    pub bLength: u8,
    /// < Must match USB_DT_Device.
    pub bDescriptorType: u8,
    pub bcdUSB: u16,
    pub bDeviceClass: u8,
    pub bDeviceSubClass: u8,
    pub bDeviceProtocol: u8,
    pub bMaxPacketSize0: u8,
    pub idVendor: u16,
    pub idProduct: u16,
    pub bcdDevice: u16,
    pub iManufacturer: u8,
    pub iProduct: u8,
    pub iSerialNumber: u8,
    pub bNumConfigurations: u8,
}
#[test]
fn bindgen_test_layout_usb_device_descriptor() {
    assert_eq!(
        ::core::mem::size_of::<usb_device_descriptor>(),
        18usize,
        concat!("Size of: ", stringify!(usb_device_descriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_device_descriptor>(),
        2usize,
        concat!("Alignment of ", stringify!(usb_device_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_device_descriptor>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_device_descriptor>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_device_descriptor>())).bcdUSB as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bcdUSB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_device_descriptor>())).bDeviceClass as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bDeviceClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_device_descriptor>())).bDeviceSubClass as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bDeviceSubClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_device_descriptor>())).bDeviceProtocol as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bDeviceProtocol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_device_descriptor>())).bMaxPacketSize0 as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bMaxPacketSize0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_device_descriptor>())).idVendor as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(idVendor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_device_descriptor>())).idProduct as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(idProduct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_device_descriptor>())).bcdDevice as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bcdDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_device_descriptor>())).iManufacturer as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(iManufacturer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_device_descriptor>())).iProduct as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(iProduct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_device_descriptor>())).iSerialNumber as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(iSerialNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_device_descriptor>())).bNumConfigurations as *const _
                as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bNumConfigurations)
        )
    );
}
/// Imported from libusb, with some adjustments.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_config_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub wTotalLength: u16,
    pub bNumInterfaces: u8,
    pub bConfigurationValue: u8,
    pub iConfiguration: u8,
    pub bmAttributes: u8,
    pub MaxPower: u8,
}
#[test]
fn bindgen_test_layout_usb_config_descriptor() {
    assert_eq!(
        ::core::mem::size_of::<usb_config_descriptor>(),
        9usize,
        concat!("Size of: ", stringify!(usb_config_descriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_config_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_config_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_config_descriptor>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_config_descriptor>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_config_descriptor>())).wTotalLength as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_descriptor),
            "::",
            stringify!(wTotalLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_config_descriptor>())).bNumInterfaces as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_descriptor),
            "::",
            stringify!(bNumInterfaces)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_config_descriptor>())).bConfigurationValue as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_descriptor),
            "::",
            stringify!(bConfigurationValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_config_descriptor>())).iConfiguration as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_descriptor),
            "::",
            stringify!(iConfiguration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_config_descriptor>())).bmAttributes as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_descriptor),
            "::",
            stringify!(bmAttributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_config_descriptor>())).MaxPower as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_descriptor),
            "::",
            stringify!(MaxPower)
        )
    );
}
/// Imported from libusb, with some adjustments.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_ss_endpoint_companion_descriptor {
    pub bLength: u8,
    /// < Must match USB_DT_SS_ENDPOINT_COMPANION.
    pub bDescriptorType: u8,
    pub bMaxBurst: u8,
    pub bmAttributes: u8,
    pub wBytesPerInterval: u16,
}
#[test]
fn bindgen_test_layout_usb_ss_endpoint_companion_descriptor() {
    assert_eq!(
        ::core::mem::size_of::<usb_ss_endpoint_companion_descriptor>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(usb_ss_endpoint_companion_descriptor)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<usb_ss_endpoint_companion_descriptor>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(usb_ss_endpoint_companion_descriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_ss_endpoint_companion_descriptor>())).bLength as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_endpoint_companion_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_ss_endpoint_companion_descriptor>())).bDescriptorType
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_endpoint_companion_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_ss_endpoint_companion_descriptor>())).bMaxBurst as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_endpoint_companion_descriptor),
            "::",
            stringify!(bMaxBurst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_ss_endpoint_companion_descriptor>())).bmAttributes
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_endpoint_companion_descriptor),
            "::",
            stringify!(bmAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_ss_endpoint_companion_descriptor>())).wBytesPerInterval
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_endpoint_companion_descriptor),
            "::",
            stringify!(wBytesPerInterval)
        )
    );
}
/// Imported from libusb, with some adjustments.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct usb_string_descriptor {
    pub bLength: u8,
    /// < Must match USB_DT_STRING.
    pub bDescriptorType: u8,
    pub wData: [u16; 64usize],
}
#[test]
fn bindgen_test_layout_usb_string_descriptor() {
    assert_eq!(
        ::core::mem::size_of::<usb_string_descriptor>(),
        130usize,
        concat!("Size of: ", stringify!(usb_string_descriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_string_descriptor>(),
        2usize,
        concat!("Alignment of ", stringify!(usb_string_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_string_descriptor>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_string_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_string_descriptor>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_string_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_string_descriptor>())).wData as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_string_descriptor),
            "::",
            stringify!(wData)
        )
    );
}
pub const usb_class_code_USB_CLASS_PER_INTERFACE: usb_class_code = 0;
pub const usb_class_code_USB_CLASS_AUDIO: usb_class_code = 1;
pub const usb_class_code_USB_CLASS_COMM: usb_class_code = 2;
pub const usb_class_code_USB_CLASS_HID: usb_class_code = 3;
pub const usb_class_code_USB_CLASS_PHYSICAL: usb_class_code = 5;
pub const usb_class_code_USB_CLASS_PRINTER: usb_class_code = 7;
pub const usb_class_code_USB_CLASS_PTP: usb_class_code = 6;
pub const usb_class_code_USB_CLASS_IMAGE: usb_class_code = 6;
pub const usb_class_code_USB_CLASS_MASS_STORAGE: usb_class_code = 8;
pub const usb_class_code_USB_CLASS_HUB: usb_class_code = 9;
pub const usb_class_code_USB_CLASS_DATA: usb_class_code = 10;
pub const usb_class_code_USB_CLASS_SMART_CARD: usb_class_code = 11;
pub const usb_class_code_USB_CLASS_CONTENT_SECURITY: usb_class_code = 13;
pub const usb_class_code_USB_CLASS_VIDEO: usb_class_code = 14;
pub const usb_class_code_USB_CLASS_PERSONAL_HEALTHCARE: usb_class_code = 15;
pub const usb_class_code_USB_CLASS_DIAGNOSTIC_DEVICE: usb_class_code = 220;
pub const usb_class_code_USB_CLASS_WIRELESS: usb_class_code = 224;
pub const usb_class_code_USB_CLASS_APPLICATION: usb_class_code = 254;
pub const usb_class_code_USB_CLASS_VENDOR_SPEC: usb_class_code = 255;
/// Imported from libusb, with changed names.
pub type usb_class_code = u32;
pub const usb_descriptor_type_USB_DT_DEVICE: usb_descriptor_type = 1;
pub const usb_descriptor_type_USB_DT_CONFIG: usb_descriptor_type = 2;
pub const usb_descriptor_type_USB_DT_STRING: usb_descriptor_type = 3;
pub const usb_descriptor_type_USB_DT_INTERFACE: usb_descriptor_type = 4;
pub const usb_descriptor_type_USB_DT_ENDPOINT: usb_descriptor_type = 5;
pub const usb_descriptor_type_USB_DT_BOS: usb_descriptor_type = 15;
pub const usb_descriptor_type_USB_DT_DEVICE_CAPABILITY: usb_descriptor_type = 16;
pub const usb_descriptor_type_USB_DT_HID: usb_descriptor_type = 33;
pub const usb_descriptor_type_USB_DT_REPORT: usb_descriptor_type = 34;
pub const usb_descriptor_type_USB_DT_PHYSICAL: usb_descriptor_type = 35;
pub const usb_descriptor_type_USB_DT_HUB: usb_descriptor_type = 41;
pub const usb_descriptor_type_USB_DT_SUPERSPEED_HUB: usb_descriptor_type = 42;
pub const usb_descriptor_type_USB_DT_SS_ENDPOINT_COMPANION: usb_descriptor_type = 48;
/// Imported from libusb, with changed names.
pub type usb_descriptor_type = u32;
pub const usb_endpoint_direction_USB_ENDPOINT_IN: usb_endpoint_direction = 128;
pub const usb_endpoint_direction_USB_ENDPOINT_OUT: usb_endpoint_direction = 0;
/// Imported from libusb, with changed names.
pub type usb_endpoint_direction = u32;
pub const usb_transfer_type_USB_TRANSFER_TYPE_CONTROL: usb_transfer_type = 0;
pub const usb_transfer_type_USB_TRANSFER_TYPE_ISOCHRONOUS: usb_transfer_type = 1;
pub const usb_transfer_type_USB_TRANSFER_TYPE_BULK: usb_transfer_type = 2;
pub const usb_transfer_type_USB_TRANSFER_TYPE_INTERRUPT: usb_transfer_type = 3;
pub const usb_transfer_type_USB_TRANSFER_TYPE_BULK_STREAM: usb_transfer_type = 4;
/// Imported from libusb, with changed names.
pub type usb_transfer_type = u32;
/// Request status of the specific recipient
pub const usb_standard_request_USB_REQUEST_GET_STATUS: usb_standard_request = 0;
/// Clear or disable a specific feature
pub const usb_standard_request_USB_REQUEST_CLEAR_FEATURE: usb_standard_request = 1;
/// Set or enable a specific feature
pub const usb_standard_request_USB_REQUEST_SET_FEATURE: usb_standard_request = 3;
/// Set device address for all future accesses
pub const usb_standard_request_USB_REQUEST_SET_ADDRESS: usb_standard_request = 5;
/// Get the specified descriptor
pub const usb_standard_request_USB_REQUEST_GET_DESCRIPTOR: usb_standard_request = 6;
/// Used to update existing descriptors or add new descriptors
pub const usb_standard_request_USB_REQUEST_SET_DESCRIPTOR: usb_standard_request = 7;
/// Get the current device configuration value
pub const usb_standard_request_USB_REQUEST_GET_CONFIGURATION: usb_standard_request = 8;
/// Set device configuration
pub const usb_standard_request_USB_REQUEST_SET_CONFIGURATION: usb_standard_request = 9;
/// Return the selected alternate setting for the specified interface
pub const usb_standard_request_USB_REQUEST_GET_INTERFACE: usb_standard_request = 10;
/// Select an alternate interface for the specified interface
pub const usb_standard_request_USB_REQUEST_SET_INTERFACE: usb_standard_request = 11;
/// Set then report an endpoint's synchronization frame
pub const usb_standard_request_USB_REQUEST_SYNCH_FRAME: usb_standard_request = 12;
/// Sets both the U1 and U2 Exit Latency
pub const usb_standard_request_USB_REQUEST_SET_SEL: usb_standard_request = 48;
/// Delay from the time a host transmits a packet to the time it is
/// received by the device.
pub const usb_standard_request_USB_SET_ISOCH_DELAY: usb_standard_request = 49;
/// Imported from libusb, with changed names.
pub type usb_standard_request = u32;
pub const usb_iso_sync_type_USB_ISO_SYNC_TYPE_NONE: usb_iso_sync_type = 0;
pub const usb_iso_sync_type_USB_ISO_SYNC_TYPE_ASYNC: usb_iso_sync_type = 1;
pub const usb_iso_sync_type_USB_ISO_SYNC_TYPE_ADAPTIVE: usb_iso_sync_type = 2;
pub const usb_iso_sync_type_USB_ISO_SYNC_TYPE_SYNC: usb_iso_sync_type = 3;
/// Imported from libusb, with changed names.
pub type usb_iso_sync_type = u32;
pub const usb_iso_usage_type_USB_ISO_USAGE_TYPE_DATA: usb_iso_usage_type = 0;
pub const usb_iso_usage_type_USB_ISO_USAGE_TYPE_FEEDBACK: usb_iso_usage_type = 1;
pub const usb_iso_usage_type_USB_ISO_USAGE_TYPE_IMPLICIT: usb_iso_usage_type = 2;
/// Imported from libusb, with changed names.
pub type usb_iso_usage_type = u32;
/// Value for usb_interface_descriptor bInterfaceNumber for automatically allocating the actual bInterfaceNumber.
#[repr(C)]
pub struct UsbDsDeviceInfo {
    /// < VID
    pub idVendor: u16,
    /// < PID
    pub idProduct: u16,
    pub bcdDevice: u16,
    pub Manufacturer: [ctypes::c_char; 32usize],
    pub Product: [ctypes::c_char; 32usize],
    pub SerialNumber: [ctypes::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_UsbDsDeviceInfo() {
    assert_eq!(
        ::core::mem::size_of::<UsbDsDeviceInfo>(),
        102usize,
        concat!("Size of: ", stringify!(UsbDsDeviceInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbDsDeviceInfo>(),
        2usize,
        concat!("Alignment of ", stringify!(UsbDsDeviceInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsDeviceInfo>())).idVendor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsDeviceInfo),
            "::",
            stringify!(idVendor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsDeviceInfo>())).idProduct as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsDeviceInfo),
            "::",
            stringify!(idProduct)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsDeviceInfo>())).bcdDevice as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsDeviceInfo),
            "::",
            stringify!(bcdDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsDeviceInfo>())).Manufacturer as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsDeviceInfo),
            "::",
            stringify!(Manufacturer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsDeviceInfo>())).Product as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsDeviceInfo),
            "::",
            stringify!(Product)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsDeviceInfo>())).SerialNumber as *const _ as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsDeviceInfo),
            "::",
            stringify!(SerialNumber)
        )
    );
}
#[repr(C)]
pub struct UsbDsReportEntry {
    /// < urbId from post-buffer cmds
    pub id: u32,
    pub requestedSize: u32,
    pub transferredSize: u32,
    pub urb_status: u32,
}
#[test]
fn bindgen_test_layout_UsbDsReportEntry() {
    assert_eq!(
        ::core::mem::size_of::<UsbDsReportEntry>(),
        16usize,
        concat!("Size of: ", stringify!(UsbDsReportEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbDsReportEntry>(),
        4usize,
        concat!("Alignment of ", stringify!(UsbDsReportEntry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsReportEntry>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsReportEntry),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsReportEntry>())).requestedSize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsReportEntry),
            "::",
            stringify!(requestedSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbDsReportEntry>())).transferredSize as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsReportEntry),
            "::",
            stringify!(transferredSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsReportEntry>())).urb_status as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsReportEntry),
            "::",
            stringify!(urb_status)
        )
    );
}
#[repr(C)]
pub struct UsbDsReportData {
    pub report: [UsbDsReportEntry; 8usize],
    pub report_count: u32,
}
#[test]
fn bindgen_test_layout_UsbDsReportData() {
    assert_eq!(
        ::core::mem::size_of::<UsbDsReportData>(),
        132usize,
        concat!("Size of: ", stringify!(UsbDsReportData))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbDsReportData>(),
        4usize,
        concat!("Alignment of ", stringify!(UsbDsReportData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsReportData>())).report as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsReportData),
            "::",
            stringify!(report)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsReportData>())).report_count as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsReportData),
            "::",
            stringify!(report_count)
        )
    );
}
#[repr(C)]
pub struct UsbDsInterface {
    pub initialized: bool,
    pub interface_index: u32,
    pub h: Service,
    pub SetupEvent: Event,
    pub CtrlInCompletionEvent: Event,
    pub CtrlOutCompletionEvent: Event,
}
#[test]
fn bindgen_test_layout_UsbDsInterface() {
    assert_eq!(
        ::core::mem::size_of::<UsbDsInterface>(),
        56usize,
        concat!("Size of: ", stringify!(UsbDsInterface))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbDsInterface>(),
        4usize,
        concat!("Alignment of ", stringify!(UsbDsInterface))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsInterface>())).initialized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsInterface),
            "::",
            stringify!(initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsInterface>())).interface_index as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsInterface),
            "::",
            stringify!(interface_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsInterface>())).h as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsInterface),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsInterface>())).SetupEvent as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsInterface),
            "::",
            stringify!(SetupEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbDsInterface>())).CtrlInCompletionEvent as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsInterface),
            "::",
            stringify!(CtrlInCompletionEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbDsInterface>())).CtrlOutCompletionEvent as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsInterface),
            "::",
            stringify!(CtrlOutCompletionEvent)
        )
    );
}
#[repr(C)]
pub struct UsbDsEndpoint {
    pub initialized: bool,
    pub h: Service,
    pub CompletionEvent: Event,
}
#[test]
fn bindgen_test_layout_UsbDsEndpoint() {
    assert_eq!(
        ::core::mem::size_of::<UsbDsEndpoint>(),
        28usize,
        concat!("Size of: ", stringify!(UsbDsEndpoint))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbDsEndpoint>(),
        4usize,
        concat!("Alignment of ", stringify!(UsbDsEndpoint))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsEndpoint>())).initialized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsEndpoint),
            "::",
            stringify!(initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsEndpoint>())).h as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsEndpoint),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsEndpoint>())).CompletionEvent as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsEndpoint),
            "::",
            stringify!(CompletionEvent)
        )
    );
}
pub const UsbComplexId_UsbComplexId_Default: UsbComplexId = 2;
pub type UsbComplexId = u32;
/// < USB 1.1 Full Speed
pub const UsbDeviceSpeed_UsbDeviceSpeed_Full: UsbDeviceSpeed = 2;
/// < USB 2.0 High Speed
pub const UsbDeviceSpeed_UsbDeviceSpeed_High: UsbDeviceSpeed = 3;
/// < USB 3.0 Super Speed
pub const UsbDeviceSpeed_UsbDeviceSpeed_Super: UsbDeviceSpeed = 4;
pub type UsbDeviceSpeed = u32;
extern "C" {
    /// Opens a session with usb:ds.
    pub fn usbDsInitialize() -> Result;
}
extern "C" {
    /// Closes the usb:ds session. Any interfaces/endpoints which are left open are automatically closed, since otherwise usb-sysmodule won't fully reset usb:ds to defaults.
    pub fn usbDsExit();
}
extern "C" {
    /// Helpers
    pub fn usbDsWaitReady(timeout: u64) -> Result;
}
extern "C" {
    pub fn usbDsParseReportData(
        reportdata: *mut UsbDsReportData,
        urbId: u32,
        requestedSize: *mut u32,
        transferredSize: *mut u32,
    ) -> Result;
}
extern "C" {
    /// IDsService
    pub fn usbDsGetStateChangeEvent() -> *mut Event;
}
extern "C" {
    pub fn usbDsGetState(out: *mut u32) -> Result;
}
extern "C" {
    /// Removed in 5.0.0
    pub fn usbDsGetDsInterface(
        out: *mut *mut UsbDsInterface,
        descriptor: *mut usb_interface_descriptor,
        interface_name: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    pub fn usbDsSetVidPidBcd(deviceinfo: *const UsbDsDeviceInfo) -> Result;
}
extern "C" {
    /// Added in 5.0.0
    pub fn usbDsRegisterInterface(out: *mut *mut UsbDsInterface) -> Result;
}
extern "C" {
    pub fn usbDsRegisterInterfaceEx(out: *mut *mut UsbDsInterface, intf_num: u32) -> Result;
}
extern "C" {
    pub fn usbDsClearDeviceData() -> Result;
}
extern "C" {
    pub fn usbDsAddUsbStringDescriptor(out_index: *mut u8, string: *const ctypes::c_char)
        -> Result;
}
extern "C" {
    pub fn usbDsAddUsbLanguageStringDescriptor(
        out_index: *mut u8,
        lang_ids: *const u16,
        num_langs: u16,
    ) -> Result;
}
extern "C" {
    pub fn usbDsDeleteUsbStringDescriptor(index: u8) -> Result;
}
extern "C" {
    pub fn usbDsSetUsbDeviceDescriptor(
        speed: UsbDeviceSpeed,
        descriptor: *mut usb_device_descriptor,
    ) -> Result;
}
extern "C" {
    pub fn usbDsSetBinaryObjectStore(bos: *const ctypes::c_void, bos_size: usize) -> Result;
}
extern "C" {
    pub fn usbDsEnable() -> Result;
}
extern "C" {
    pub fn usbDsDisable() -> Result;
}
extern "C" {
    /// IDsInterface
    pub fn usbDsInterface_Close(interface: *mut UsbDsInterface);
}
extern "C" {
    pub fn usbDsInterface_GetSetupPacket(
        interface: *mut UsbDsInterface,
        buffer: *mut ctypes::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    pub fn usbDsInterface_EnableInterface(interface: *mut UsbDsInterface) -> Result;
}
extern "C" {
    pub fn usbDsInterface_DisableInterface(interface: *mut UsbDsInterface) -> Result;
}
extern "C" {
    pub fn usbDsInterface_CtrlInPostBufferAsync(
        interface: *mut UsbDsInterface,
        buffer: *mut ctypes::c_void,
        size: usize,
        urbId: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn usbDsInterface_CtrlOutPostBufferAsync(
        interface: *mut UsbDsInterface,
        buffer: *mut ctypes::c_void,
        size: usize,
        urbId: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn usbDsInterface_GetCtrlInReportData(
        interface: *mut UsbDsInterface,
        out: *mut UsbDsReportData,
    ) -> Result;
}
extern "C" {
    pub fn usbDsInterface_GetCtrlOutReportData(
        interface: *mut UsbDsInterface,
        out: *mut UsbDsReportData,
    ) -> Result;
}
extern "C" {
    pub fn usbDsInterface_StallCtrl(interface: *mut UsbDsInterface) -> Result;
}
extern "C" {
    /// Removed in 5.0.0
    pub fn usbDsInterface_GetDsEndpoint(
        interface: *mut UsbDsInterface,
        endpoint: *mut *mut UsbDsEndpoint,
        descriptor: *mut usb_endpoint_descriptor,
    ) -> Result;
}
extern "C" {
    /// Added in 5.0.0
    pub fn usbDsInterface_RegisterEndpoint(
        interface: *mut UsbDsInterface,
        endpoint: *mut *mut UsbDsEndpoint,
        endpoint_address: u8,
    ) -> Result;
}
extern "C" {
    pub fn usbDsInterface_AppendConfigurationData(
        interface: *mut UsbDsInterface,
        speed: UsbDeviceSpeed,
        buffer: *const ctypes::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    /// IDsEndpoint
    pub fn usbDsEndpoint_Close(endpoint: *mut UsbDsEndpoint);
}
extern "C" {
    pub fn usbDsEndpoint_Cancel(endpoint: *mut UsbDsEndpoint) -> Result;
}
extern "C" {
    pub fn usbDsEndpoint_PostBufferAsync(
        endpoint: *mut UsbDsEndpoint,
        buffer: *mut ctypes::c_void,
        size: usize,
        urbId: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn usbDsEndpoint_GetReportData(
        endpoint: *mut UsbDsEndpoint,
        out: *mut UsbDsReportData,
    ) -> Result;
}
extern "C" {
    pub fn usbDsEndpoint_Stall(endpoint: *mut UsbDsEndpoint) -> Result;
}
extern "C" {
    pub fn usbDsEndpoint_SetZlt(endpoint: *mut UsbDsEndpoint, zlt: bool) -> Result;
}
pub const UsbHsInterfaceFilterFlags_UsbHsInterfaceFilterFlags_idVendor: UsbHsInterfaceFilterFlags =
    1;
pub const UsbHsInterfaceFilterFlags_UsbHsInterfaceFilterFlags_idProduct: UsbHsInterfaceFilterFlags =
    2;
pub const UsbHsInterfaceFilterFlags_UsbHsInterfaceFilterFlags_bcdDevice_Min:
    UsbHsInterfaceFilterFlags = 4;
pub const UsbHsInterfaceFilterFlags_UsbHsInterfaceFilterFlags_bcdDevice_Max:
    UsbHsInterfaceFilterFlags = 8;
pub const UsbHsInterfaceFilterFlags_UsbHsInterfaceFilterFlags_bDeviceClass:
    UsbHsInterfaceFilterFlags = 16;
pub const UsbHsInterfaceFilterFlags_UsbHsInterfaceFilterFlags_bDeviceSubClass:
    UsbHsInterfaceFilterFlags = 32;
pub const UsbHsInterfaceFilterFlags_UsbHsInterfaceFilterFlags_bDeviceProtocol:
    UsbHsInterfaceFilterFlags = 64;
pub const UsbHsInterfaceFilterFlags_UsbHsInterfaceFilterFlags_bInterfaceClass:
    UsbHsInterfaceFilterFlags = 128;
pub const UsbHsInterfaceFilterFlags_UsbHsInterfaceFilterFlags_bInterfaceSubClass:
    UsbHsInterfaceFilterFlags = 256;
pub const UsbHsInterfaceFilterFlags_UsbHsInterfaceFilterFlags_bInterfaceProtocol:
    UsbHsInterfaceFilterFlags = 512;
pub type UsbHsInterfaceFilterFlags = u32;
/// Interface filtering struct. When the associated flag bit is set, the associated descriptor field and struct field are compared, on mismatch the interface is filtered out.
/// [7.0.0+]: The filter struct has to be unique, it can't be used by anything else (including other processes). Hence, Flags has to be non-zero. When initialized with usb:hs:a and VID and/or PID filtering is enabled, the VID/PID will be checked against a blacklist.
#[repr(C)]
pub struct UsbHsInterfaceFilter {
    /// < See \ref UsbHsInterfaceFilterFlags. Setting this to 0 is equivalent to disabling filtering.
    pub Flags: u16,
    pub idVendor: u16,
    pub idProduct: u16,
    /// < Descriptor value must be >= bcdDevice_Min.
    pub bcdDevice_Min: u16,
    /// < Descriptor value must be <= bcdDevice_Max.
    pub bcdDevice_Max: u16,
    pub bDeviceClass: u8,
    pub bDeviceSubClass: u8,
    pub bDeviceProtocol: u8,
    pub bInterfaceClass: u8,
    pub bInterfaceSubClass: u8,
    pub bInterfaceProtocol: u8,
}
#[test]
fn bindgen_test_layout_UsbHsInterfaceFilter() {
    assert_eq!(
        ::core::mem::size_of::<UsbHsInterfaceFilter>(),
        16usize,
        concat!("Size of: ", stringify!(UsbHsInterfaceFilter))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbHsInterfaceFilter>(),
        2usize,
        concat!("Alignment of ", stringify!(UsbHsInterfaceFilter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterfaceFilter>())).Flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceFilter),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterfaceFilter>())).idVendor as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceFilter),
            "::",
            stringify!(idVendor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterfaceFilter>())).idProduct as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceFilter),
            "::",
            stringify!(idProduct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceFilter>())).bcdDevice_Min as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceFilter),
            "::",
            stringify!(bcdDevice_Min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceFilter>())).bcdDevice_Max as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceFilter),
            "::",
            stringify!(bcdDevice_Max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceFilter>())).bDeviceClass as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceFilter),
            "::",
            stringify!(bDeviceClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceFilter>())).bDeviceSubClass as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceFilter),
            "::",
            stringify!(bDeviceSubClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceFilter>())).bDeviceProtocol as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceFilter),
            "::",
            stringify!(bDeviceProtocol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceFilter>())).bInterfaceClass as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceFilter),
            "::",
            stringify!(bInterfaceClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceFilter>())).bInterfaceSubClass as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceFilter),
            "::",
            stringify!(bInterfaceSubClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceFilter>())).bInterfaceProtocol as *const _
                as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceFilter),
            "::",
            stringify!(bInterfaceProtocol)
        )
    );
}
/// Descriptors which are not available are set to all-zero.
#[repr(C, packed)]
pub struct UsbHsInterfaceInfo {
    pub ID: s32,
    pub deviceID_2: u32,
    pub unk_x8: u32,
    pub interface_desc: usb_interface_descriptor,
    pub pad_x15: [u8; 7usize],
    pub output_endpoint_descs: [usb_endpoint_descriptor; 15usize],
    pub pad_x85: [u8; 7usize],
    pub input_endpoint_descs: [usb_endpoint_descriptor; 15usize],
    pub pad_xf5: [u8; 6usize],
    /// < ?
    pub output_ss_endpoint_companion_descs: [usb_ss_endpoint_companion_descriptor; 15usize],
    pub pad_x155: [u8; 6usize],
    /// < ?
    pub input_ss_endpoint_companion_descs: [usb_ss_endpoint_companion_descriptor; 15usize],
    pub pad_x1b5: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_UsbHsInterfaceInfo() {
    assert_eq!(
        ::core::mem::size_of::<UsbHsInterfaceInfo>(),
        440usize,
        concat!("Size of: ", stringify!(UsbHsInterfaceInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbHsInterfaceInfo>(),
        1usize,
        concat!("Alignment of ", stringify!(UsbHsInterfaceInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).ID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(ID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).deviceID_2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(deviceID_2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).unk_x8 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(unk_x8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).interface_desc as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(interface_desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).pad_x15 as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(pad_x15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).output_endpoint_descs as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(output_endpoint_descs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).pad_x85 as *const _ as usize },
        133usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(pad_x85)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).input_endpoint_descs as *const _
                as usize
        },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(input_endpoint_descs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).pad_xf5 as *const _ as usize },
        245usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(pad_xf5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).output_ss_endpoint_companion_descs
                as *const _ as usize
        },
        251usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(output_ss_endpoint_companion_descs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).pad_x155 as *const _ as usize },
        341usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(pad_x155)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).input_ss_endpoint_companion_descs
                as *const _ as usize
        },
        347usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(input_ss_endpoint_companion_descs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).pad_x1b5 as *const _ as usize },
        437usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(pad_x1b5)
        )
    );
}
/// Interface struct. Note that devices have a seperate \ref UsbHsInterface for each interface.
#[repr(C, packed)]
pub struct UsbHsInterface {
    pub inf: UsbHsInterfaceInfo,
    pub pathstr: [ctypes::c_char; 64usize],
    pub busID: u32,
    pub deviceID: u32,
    pub device_desc: usb_device_descriptor,
    pub config_desc: usb_config_descriptor,
    pub pad_x21b: [u8; 5usize],
    /// < Unknown u64 timestamp for when the device was inserted?
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_UsbHsInterface() {
    assert_eq!(
        ::core::mem::size_of::<UsbHsInterface>(),
        552usize,
        concat!("Size of: ", stringify!(UsbHsInterface))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbHsInterface>(),
        1usize,
        concat!("Alignment of ", stringify!(UsbHsInterface))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterface>())).inf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterface),
            "::",
            stringify!(inf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterface>())).pathstr as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterface),
            "::",
            stringify!(pathstr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterface>())).busID as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterface),
            "::",
            stringify!(busID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterface>())).deviceID as *const _ as usize },
        508usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterface),
            "::",
            stringify!(deviceID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterface>())).device_desc as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterface),
            "::",
            stringify!(device_desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterface>())).config_desc as *const _ as usize },
        530usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterface),
            "::",
            stringify!(config_desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterface>())).pad_x21b as *const _ as usize },
        539usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterface),
            "::",
            stringify!(pad_x21b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterface>())).timestamp as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterface),
            "::",
            stringify!(timestamp)
        )
    );
}
#[repr(C)]
pub struct UsbHsXferReport {
    pub xferId: u32,
    pub res: Result,
    pub requestedSize: u32,
    pub transferredSize: u32,
    pub unk_x10: u64,
}
#[test]
fn bindgen_test_layout_UsbHsXferReport() {
    assert_eq!(
        ::core::mem::size_of::<UsbHsXferReport>(),
        24usize,
        concat!("Size of: ", stringify!(UsbHsXferReport))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbHsXferReport>(),
        8usize,
        concat!("Alignment of ", stringify!(UsbHsXferReport))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsXferReport>())).xferId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsXferReport),
            "::",
            stringify!(xferId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsXferReport>())).res as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsXferReport),
            "::",
            stringify!(res)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsXferReport>())).requestedSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsXferReport),
            "::",
            stringify!(requestedSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsXferReport>())).transferredSize as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsXferReport),
            "::",
            stringify!(transferredSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsXferReport>())).unk_x10 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsXferReport),
            "::",
            stringify!(unk_x10)
        )
    );
}
/// The interface service object. These Events have autoclear=false.
#[repr(C)]
pub struct UsbHsClientIfSession {
    pub s: Service,
    /// < Unknown.
    pub event0: Event,
    /// < [2.0.0+] Signaled when CtrlXferAsync finishes.
    pub eventCtrlXfer: Event,
    pub ID: s32,
    /// < Initialized with the input interface from \ref usbHsAcquireUsbIf, then overwritten with the cmd output. Pre-3.0.0 this only overwrites the first 0x1B8-bytes (data before pathstr).
    pub inf: UsbHsInterface,
}
#[test]
fn bindgen_test_layout_UsbHsClientIfSession() {
    assert_eq!(
        ::core::mem::size_of::<UsbHsClientIfSession>(),
        592usize,
        concat!("Size of: ", stringify!(UsbHsClientIfSession))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbHsClientIfSession>(),
        4usize,
        concat!("Alignment of ", stringify!(UsbHsClientIfSession))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsClientIfSession>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsClientIfSession),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsClientIfSession>())).event0 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsClientIfSession),
            "::",
            stringify!(event0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsClientIfSession>())).eventCtrlXfer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsClientIfSession),
            "::",
            stringify!(eventCtrlXfer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsClientIfSession>())).ID as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsClientIfSession),
            "::",
            stringify!(ID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsClientIfSession>())).inf as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsClientIfSession),
            "::",
            stringify!(inf)
        )
    );
}
#[repr(C)]
pub struct UsbHsClientEpSession {
    pub s: Service,
    /// < [2.0.0+] Signaled when PostBufferAsync finishes.
    pub eventXfer: Event,
    pub desc: usb_endpoint_descriptor,
}
#[test]
fn bindgen_test_layout_UsbHsClientEpSession() {
    assert_eq!(
        ::core::mem::size_of::<UsbHsClientEpSession>(),
        32usize,
        concat!("Size of: ", stringify!(UsbHsClientEpSession))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbHsClientEpSession>(),
        4usize,
        concat!("Alignment of ", stringify!(UsbHsClientEpSession))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsClientEpSession>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsClientEpSession),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsClientEpSession>())).eventXfer as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsClientEpSession),
            "::",
            stringify!(eventXfer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsClientEpSession>())).desc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsClientEpSession),
            "::",
            stringify!(desc)
        )
    );
}
extern "C" {
    /// Initialize/exit usb:hs.
    pub fn usbHsInitialize() -> Result;
}
extern "C" {
    pub fn usbHsExit();
}
extern "C" {
    /// Returns the Event loaded during init with autoclear=false.
    /// Signaled when a device was removed.
    /// When signaled, the user should use \ref usbHsQueryAcquiredInterfaces and cleanup state for all interfaces which are not listed in the output interfaces (none of the IDs match \ref usbHsIfGetID output).
    pub fn usbHsGetInterfaceStateChangeEvent() -> *mut Event;
}
extern "C" {
    /// @brief Returns an array of all \ref UsbHsInterface. Internally this loads the same interfaces as \ref usbHsQueryAvailableInterfaces, followed by \ref usbHsQueryAcquiredInterfaces. However, ID in \ref UsbHsInterface is set to -1, hence the output from this should not be used with \ref usbHsAcquireUsbIf.
    /// @param[in] filter \ref UsbHsInterfaceFilter.
    /// @param[out] interfaces Array of output interfaces.
    /// @param[in] interfaces_maxsize Max byte-size of the interfaces buffer.
    /// @param[out] total_entries Total number of output interfaces.
    pub fn usbHsQueryAllInterfaces(
        filter: *const UsbHsInterfaceFilter,
        interfaces: *mut UsbHsInterface,
        interfaces_maxsize: usize,
        total_entries: *mut s32,
    ) -> Result;
}
extern "C" {
    /// @brief Returns an array of \ref UsbHsInterface which are available.
    /// @param[in] filter \ref UsbHsInterfaceFilter.
    /// @param[out] interfaces Array of output interfaces.
    /// @param[in] interfaces_maxsize Max byte-size of the interfaces buffer.
    /// @param[out] total_entries Total number of output interfaces.
    pub fn usbHsQueryAvailableInterfaces(
        filter: *const UsbHsInterfaceFilter,
        interfaces: *mut UsbHsInterface,
        interfaces_maxsize: usize,
        total_entries: *mut s32,
    ) -> Result;
}
extern "C" {
    /// @brief Returns an array of \ref UsbHsInterface which were previously acquired.
    /// @param[out] interfaces Array of output interfaces.
    /// @param[in] interfaces_maxsize Max byte-size of the interfaces buffer.
    /// @param[out] total_entries Total number of output interfaces.
    pub fn usbHsQueryAcquiredInterfaces(
        interfaces: *mut UsbHsInterface,
        interfaces_maxsize: usize,
        total_entries: *mut s32,
    ) -> Result;
}
extern "C" {
    /// @brief Creates an event which is signaled when an interface is available which passes the filtering checks.
    /// @param[out] event Event object.
    /// @param[in] autoclear Event autoclear.
    /// @param[in] index Event index, must be 0..2.
    /// @param[in] filter \ref UsbHsInterfaceFilter.
    pub fn usbHsCreateInterfaceAvailableEvent(
        event: *mut Event,
        autoclear: bool,
        index: u8,
        filter: *const UsbHsInterfaceFilter,
    ) -> Result;
}
extern "C" {
    /// @brief Destroys an event setup by \ref usbHsCreateInterfaceAvailableEvent. This *must* be used at some point during cleanup.
    /// @param[in] event Event object to close.
    /// @param[in] index Event index, must be 0..2.
    pub fn usbHsDestroyInterfaceAvailableEvent(event: *mut Event, index: u8) -> Result;
}
extern "C" {
    /// @brief Acquires/opens the specified interface. This returns an error if the interface was already acquired by another process.
    /// @param[in] s The service object.
    /// @param[in] interface Interface to use.
    pub fn usbHsAcquireUsbIf(
        s: *mut UsbHsClientIfSession,
        interface: *mut UsbHsInterface,
    ) -> Result;
}
extern "C" {
    /// Closes the specified interface session.
    pub fn usbHsIfClose(s: *mut UsbHsClientIfSession);
}
extern "C" {
    /// @brief Selects an interface.
    /// @param[in] s The service object.
    /// @param[out] inf The output interface info. If NULL, the output is stored within s instead.
    /// @param[in] id ID
    pub fn usbHsIfSetInterface(
        s: *mut UsbHsClientIfSession,
        inf: *mut UsbHsInterfaceInfo,
        id: u8,
    ) -> Result;
}
extern "C" {
    /// @brief Gets an interface.
    /// @param[in] s The service object.
    /// @param[out] inf The output interface info. If NULL, the output is stored within s instead.
    pub fn usbHsIfGetInterface(
        s: *mut UsbHsClientIfSession,
        inf: *mut UsbHsInterfaceInfo,
    ) -> Result;
}
extern "C" {
    /// @brief Gets an alternate interface.
    /// @param[in] s The service object.
    /// @param[out] inf The output interface info. If NULL, the output is stored within s instead.
    /// @param[in] id ID
    pub fn usbHsIfGetAlternateInterface(
        s: *mut UsbHsClientIfSession,
        inf: *mut UsbHsInterfaceInfo,
        id: u8,
    ) -> Result;
}
extern "C" {
    /// On 1.0.0 this is stubbed, just returns 0 with out=0.
    pub fn usbHsIfGetCurrentFrame(s: *mut UsbHsClientIfSession, out: *mut u32) -> Result;
}
extern "C" {
    /// Uses a control transfer, this will block until the transfer finishes. The buffer address and size should be aligned to 0x1000-bytes, where wLength is the original size.
    pub fn usbHsIfCtrlXfer(
        s: *mut UsbHsClientIfSession,
        bmRequestType: u8,
        bRequest: u8,
        wValue: u16,
        wIndex: u16,
        wLength: u16,
        buffer: *mut ctypes::c_void,
        transferredSize: *mut u32,
    ) -> Result;
}
extern "C" {
    /// @brief Opens an endpoint. maxUrbCount*maxXferSize must be non-zero.
    /// @param[in] s The interface object.
    /// @param[out] ep The endpoint object.
    /// @param[in] maxUrbCount maxUrbCount, must be <0x11.
    /// @param[in] maxXferSize Max transfer size for a packet. This can be desc->wMaxPacketSize. Must be <=0xFF0000.
    /// @param[in] desc Endpoint descriptor.
    pub fn usbHsIfOpenUsbEp(
        s: *mut UsbHsClientIfSession,
        ep: *mut UsbHsClientEpSession,
        maxUrbCount: u16,
        maxXferSize: u32,
        desc: *mut usb_endpoint_descriptor,
    ) -> Result;
}
extern "C" {
    /// Resets the device: has the same affect as unplugging the device and plugging it back in.
    pub fn usbHsIfResetDevice(s: *mut UsbHsClientIfSession) -> Result;
}
extern "C" {
    /// Closes the specified endpoint session.
    pub fn usbHsEpClose(s: *mut UsbHsClientEpSession);
}
extern "C" {
    /// Uses a data transfer with the specified endpoint, this will block until the transfer finishes. The buffer address and size should be aligned to 0x1000-bytes, where the input size is the original size.
    pub fn usbHsEpPostBuffer(
        s: *mut UsbHsClientEpSession,
        buffer: *mut ctypes::c_void,
        size: u32,
        transferredSize: *mut u32,
    ) -> Result;
}
pub const HidMouseButton_MOUSE_LEFT: HidMouseButton = 1;
pub const HidMouseButton_MOUSE_RIGHT: HidMouseButton = 2;
pub const HidMouseButton_MOUSE_MIDDLE: HidMouseButton = 4;
pub const HidMouseButton_MOUSE_FORWARD: HidMouseButton = 8;
pub const HidMouseButton_MOUSE_BACK: HidMouseButton = 16;
pub type HidMouseButton = u32;
pub const HidKeyboardModifier_KBD_MOD_LCTRL: HidKeyboardModifier = 1;
pub const HidKeyboardModifier_KBD_MOD_LSHIFT: HidKeyboardModifier = 2;
pub const HidKeyboardModifier_KBD_MOD_LALT: HidKeyboardModifier = 4;
pub const HidKeyboardModifier_KBD_MOD_LMETA: HidKeyboardModifier = 8;
pub const HidKeyboardModifier_KBD_MOD_RCTRL: HidKeyboardModifier = 16;
pub const HidKeyboardModifier_KBD_MOD_RSHIFT: HidKeyboardModifier = 32;
pub const HidKeyboardModifier_KBD_MOD_RALT: HidKeyboardModifier = 64;
pub const HidKeyboardModifier_KBD_MOD_RMETA: HidKeyboardModifier = 128;
pub const HidKeyboardModifier_KBD_MOD_CAPSLOCK: HidKeyboardModifier = 256;
pub const HidKeyboardModifier_KBD_MOD_SCROLLLOCK: HidKeyboardModifier = 512;
pub const HidKeyboardModifier_KBD_MOD_NUMLOCK: HidKeyboardModifier = 1024;
pub type HidKeyboardModifier = u32;
pub const HidKeyboardScancode_KBD_NONE: HidKeyboardScancode = 0;
pub const HidKeyboardScancode_KBD_ERR_OVF: HidKeyboardScancode = 1;
pub const HidKeyboardScancode_KBD_A: HidKeyboardScancode = 4;
pub const HidKeyboardScancode_KBD_B: HidKeyboardScancode = 5;
pub const HidKeyboardScancode_KBD_C: HidKeyboardScancode = 6;
pub const HidKeyboardScancode_KBD_D: HidKeyboardScancode = 7;
pub const HidKeyboardScancode_KBD_E: HidKeyboardScancode = 8;
pub const HidKeyboardScancode_KBD_F: HidKeyboardScancode = 9;
pub const HidKeyboardScancode_KBD_G: HidKeyboardScancode = 10;
pub const HidKeyboardScancode_KBD_H: HidKeyboardScancode = 11;
pub const HidKeyboardScancode_KBD_I: HidKeyboardScancode = 12;
pub const HidKeyboardScancode_KBD_J: HidKeyboardScancode = 13;
pub const HidKeyboardScancode_KBD_K: HidKeyboardScancode = 14;
pub const HidKeyboardScancode_KBD_L: HidKeyboardScancode = 15;
pub const HidKeyboardScancode_KBD_M: HidKeyboardScancode = 16;
pub const HidKeyboardScancode_KBD_N: HidKeyboardScancode = 17;
pub const HidKeyboardScancode_KBD_O: HidKeyboardScancode = 18;
pub const HidKeyboardScancode_KBD_P: HidKeyboardScancode = 19;
pub const HidKeyboardScancode_KBD_Q: HidKeyboardScancode = 20;
pub const HidKeyboardScancode_KBD_R: HidKeyboardScancode = 21;
pub const HidKeyboardScancode_KBD_S: HidKeyboardScancode = 22;
pub const HidKeyboardScancode_KBD_T: HidKeyboardScancode = 23;
pub const HidKeyboardScancode_KBD_U: HidKeyboardScancode = 24;
pub const HidKeyboardScancode_KBD_V: HidKeyboardScancode = 25;
pub const HidKeyboardScancode_KBD_W: HidKeyboardScancode = 26;
pub const HidKeyboardScancode_KBD_X: HidKeyboardScancode = 27;
pub const HidKeyboardScancode_KBD_Y: HidKeyboardScancode = 28;
pub const HidKeyboardScancode_KBD_Z: HidKeyboardScancode = 29;
pub const HidKeyboardScancode_KBD_1: HidKeyboardScancode = 30;
pub const HidKeyboardScancode_KBD_2: HidKeyboardScancode = 31;
pub const HidKeyboardScancode_KBD_3: HidKeyboardScancode = 32;
pub const HidKeyboardScancode_KBD_4: HidKeyboardScancode = 33;
pub const HidKeyboardScancode_KBD_5: HidKeyboardScancode = 34;
pub const HidKeyboardScancode_KBD_6: HidKeyboardScancode = 35;
pub const HidKeyboardScancode_KBD_7: HidKeyboardScancode = 36;
pub const HidKeyboardScancode_KBD_8: HidKeyboardScancode = 37;
pub const HidKeyboardScancode_KBD_9: HidKeyboardScancode = 38;
pub const HidKeyboardScancode_KBD_0: HidKeyboardScancode = 39;
pub const HidKeyboardScancode_KBD_ENTER: HidKeyboardScancode = 40;
pub const HidKeyboardScancode_KBD_ESC: HidKeyboardScancode = 41;
pub const HidKeyboardScancode_KBD_BACKSPACE: HidKeyboardScancode = 42;
pub const HidKeyboardScancode_KBD_TAB: HidKeyboardScancode = 43;
pub const HidKeyboardScancode_KBD_SPACE: HidKeyboardScancode = 44;
pub const HidKeyboardScancode_KBD_MINUS: HidKeyboardScancode = 45;
pub const HidKeyboardScancode_KBD_EQUAL: HidKeyboardScancode = 46;
pub const HidKeyboardScancode_KBD_LEFTBRACE: HidKeyboardScancode = 47;
pub const HidKeyboardScancode_KBD_RIGHTBRACE: HidKeyboardScancode = 48;
pub const HidKeyboardScancode_KBD_BACKSLASH: HidKeyboardScancode = 49;
pub const HidKeyboardScancode_KBD_HASHTILDE: HidKeyboardScancode = 50;
pub const HidKeyboardScancode_KBD_SEMICOLON: HidKeyboardScancode = 51;
pub const HidKeyboardScancode_KBD_APOSTROPHE: HidKeyboardScancode = 52;
pub const HidKeyboardScancode_KBD_GRAVE: HidKeyboardScancode = 53;
pub const HidKeyboardScancode_KBD_COMMA: HidKeyboardScancode = 54;
pub const HidKeyboardScancode_KBD_DOT: HidKeyboardScancode = 55;
pub const HidKeyboardScancode_KBD_SLASH: HidKeyboardScancode = 56;
pub const HidKeyboardScancode_KBD_CAPSLOCK: HidKeyboardScancode = 57;
pub const HidKeyboardScancode_KBD_F1: HidKeyboardScancode = 58;
pub const HidKeyboardScancode_KBD_F2: HidKeyboardScancode = 59;
pub const HidKeyboardScancode_KBD_F3: HidKeyboardScancode = 60;
pub const HidKeyboardScancode_KBD_F4: HidKeyboardScancode = 61;
pub const HidKeyboardScancode_KBD_F5: HidKeyboardScancode = 62;
pub const HidKeyboardScancode_KBD_F6: HidKeyboardScancode = 63;
pub const HidKeyboardScancode_KBD_F7: HidKeyboardScancode = 64;
pub const HidKeyboardScancode_KBD_F8: HidKeyboardScancode = 65;
pub const HidKeyboardScancode_KBD_F9: HidKeyboardScancode = 66;
pub const HidKeyboardScancode_KBD_F10: HidKeyboardScancode = 67;
pub const HidKeyboardScancode_KBD_F11: HidKeyboardScancode = 68;
pub const HidKeyboardScancode_KBD_F12: HidKeyboardScancode = 69;
pub const HidKeyboardScancode_KBD_SYSRQ: HidKeyboardScancode = 70;
pub const HidKeyboardScancode_KBD_SCROLLLOCK: HidKeyboardScancode = 71;
pub const HidKeyboardScancode_KBD_PAUSE: HidKeyboardScancode = 72;
pub const HidKeyboardScancode_KBD_INSERT: HidKeyboardScancode = 73;
pub const HidKeyboardScancode_KBD_HOME: HidKeyboardScancode = 74;
pub const HidKeyboardScancode_KBD_PAGEUP: HidKeyboardScancode = 75;
pub const HidKeyboardScancode_KBD_DELETE: HidKeyboardScancode = 76;
pub const HidKeyboardScancode_KBD_END: HidKeyboardScancode = 77;
pub const HidKeyboardScancode_KBD_PAGEDOWN: HidKeyboardScancode = 78;
pub const HidKeyboardScancode_KBD_RIGHT: HidKeyboardScancode = 79;
pub const HidKeyboardScancode_KBD_LEFT: HidKeyboardScancode = 80;
pub const HidKeyboardScancode_KBD_DOWN: HidKeyboardScancode = 81;
pub const HidKeyboardScancode_KBD_UP: HidKeyboardScancode = 82;
pub const HidKeyboardScancode_KBD_NUMLOCK: HidKeyboardScancode = 83;
pub const HidKeyboardScancode_KBD_KPSLASH: HidKeyboardScancode = 84;
pub const HidKeyboardScancode_KBD_KPASTERISK: HidKeyboardScancode = 85;
pub const HidKeyboardScancode_KBD_KPMINUS: HidKeyboardScancode = 86;
pub const HidKeyboardScancode_KBD_KPPLUS: HidKeyboardScancode = 87;
pub const HidKeyboardScancode_KBD_KPENTER: HidKeyboardScancode = 88;
pub const HidKeyboardScancode_KBD_KP1: HidKeyboardScancode = 89;
pub const HidKeyboardScancode_KBD_KP2: HidKeyboardScancode = 90;
pub const HidKeyboardScancode_KBD_KP3: HidKeyboardScancode = 91;
pub const HidKeyboardScancode_KBD_KP4: HidKeyboardScancode = 92;
pub const HidKeyboardScancode_KBD_KP5: HidKeyboardScancode = 93;
pub const HidKeyboardScancode_KBD_KP6: HidKeyboardScancode = 94;
pub const HidKeyboardScancode_KBD_KP7: HidKeyboardScancode = 95;
pub const HidKeyboardScancode_KBD_KP8: HidKeyboardScancode = 96;
pub const HidKeyboardScancode_KBD_KP9: HidKeyboardScancode = 97;
pub const HidKeyboardScancode_KBD_KP0: HidKeyboardScancode = 98;
pub const HidKeyboardScancode_KBD_KPDOT: HidKeyboardScancode = 99;
pub const HidKeyboardScancode_KBD_102ND: HidKeyboardScancode = 100;
pub const HidKeyboardScancode_KBD_COMPOSE: HidKeyboardScancode = 101;
pub const HidKeyboardScancode_KBD_POWER: HidKeyboardScancode = 102;
pub const HidKeyboardScancode_KBD_KPEQUAL: HidKeyboardScancode = 103;
pub const HidKeyboardScancode_KBD_F13: HidKeyboardScancode = 104;
pub const HidKeyboardScancode_KBD_F14: HidKeyboardScancode = 105;
pub const HidKeyboardScancode_KBD_F15: HidKeyboardScancode = 106;
pub const HidKeyboardScancode_KBD_F16: HidKeyboardScancode = 107;
pub const HidKeyboardScancode_KBD_F17: HidKeyboardScancode = 108;
pub const HidKeyboardScancode_KBD_F18: HidKeyboardScancode = 109;
pub const HidKeyboardScancode_KBD_F19: HidKeyboardScancode = 110;
pub const HidKeyboardScancode_KBD_F20: HidKeyboardScancode = 111;
pub const HidKeyboardScancode_KBD_F21: HidKeyboardScancode = 112;
pub const HidKeyboardScancode_KBD_F22: HidKeyboardScancode = 113;
pub const HidKeyboardScancode_KBD_F23: HidKeyboardScancode = 114;
pub const HidKeyboardScancode_KBD_F24: HidKeyboardScancode = 115;
pub const HidKeyboardScancode_KBD_OPEN: HidKeyboardScancode = 116;
pub const HidKeyboardScancode_KBD_HELP: HidKeyboardScancode = 117;
pub const HidKeyboardScancode_KBD_PROPS: HidKeyboardScancode = 118;
pub const HidKeyboardScancode_KBD_FRONT: HidKeyboardScancode = 119;
pub const HidKeyboardScancode_KBD_STOP: HidKeyboardScancode = 120;
pub const HidKeyboardScancode_KBD_AGAIN: HidKeyboardScancode = 121;
pub const HidKeyboardScancode_KBD_UNDO: HidKeyboardScancode = 122;
pub const HidKeyboardScancode_KBD_CUT: HidKeyboardScancode = 123;
pub const HidKeyboardScancode_KBD_COPY: HidKeyboardScancode = 124;
pub const HidKeyboardScancode_KBD_PASTE: HidKeyboardScancode = 125;
pub const HidKeyboardScancode_KBD_FIND: HidKeyboardScancode = 126;
pub const HidKeyboardScancode_KBD_MUTE: HidKeyboardScancode = 127;
pub const HidKeyboardScancode_KBD_VOLUMEUP: HidKeyboardScancode = 128;
pub const HidKeyboardScancode_KBD_VOLUMEDOWN: HidKeyboardScancode = 129;
pub const HidKeyboardScancode_KBD_CAPSLOCK_ACTIVE: HidKeyboardScancode = 130;
pub const HidKeyboardScancode_KBD_NUMLOCK_ACTIVE: HidKeyboardScancode = 131;
pub const HidKeyboardScancode_KBD_SCROLLLOCK_ACTIVE: HidKeyboardScancode = 132;
pub const HidKeyboardScancode_KBD_KPCOMMA: HidKeyboardScancode = 133;
pub const HidKeyboardScancode_KBD_KPLEFTPAREN: HidKeyboardScancode = 182;
pub const HidKeyboardScancode_KBD_KPRIGHTPAREN: HidKeyboardScancode = 183;
pub const HidKeyboardScancode_KBD_LEFTCTRL: HidKeyboardScancode = 224;
pub const HidKeyboardScancode_KBD_LEFTSHIFT: HidKeyboardScancode = 225;
pub const HidKeyboardScancode_KBD_LEFTALT: HidKeyboardScancode = 226;
pub const HidKeyboardScancode_KBD_LEFTMETA: HidKeyboardScancode = 227;
pub const HidKeyboardScancode_KBD_RIGHTCTRL: HidKeyboardScancode = 228;
pub const HidKeyboardScancode_KBD_RIGHTSHIFT: HidKeyboardScancode = 229;
pub const HidKeyboardScancode_KBD_RIGHTALT: HidKeyboardScancode = 230;
pub const HidKeyboardScancode_KBD_RIGHTMETA: HidKeyboardScancode = 231;
pub const HidKeyboardScancode_KBD_MEDIA_PLAYPAUSE: HidKeyboardScancode = 232;
pub const HidKeyboardScancode_KBD_MEDIA_STOPCD: HidKeyboardScancode = 233;
pub const HidKeyboardScancode_KBD_MEDIA_PREVIOUSSONG: HidKeyboardScancode = 234;
pub const HidKeyboardScancode_KBD_MEDIA_NEXTSONG: HidKeyboardScancode = 235;
pub const HidKeyboardScancode_KBD_MEDIA_EJECTCD: HidKeyboardScancode = 236;
pub const HidKeyboardScancode_KBD_MEDIA_VOLUMEUP: HidKeyboardScancode = 237;
pub const HidKeyboardScancode_KBD_MEDIA_VOLUMEDOWN: HidKeyboardScancode = 238;
pub const HidKeyboardScancode_KBD_MEDIA_MUTE: HidKeyboardScancode = 239;
pub const HidKeyboardScancode_KBD_MEDIA_WWW: HidKeyboardScancode = 240;
pub const HidKeyboardScancode_KBD_MEDIA_BACK: HidKeyboardScancode = 241;
pub const HidKeyboardScancode_KBD_MEDIA_FORWARD: HidKeyboardScancode = 242;
pub const HidKeyboardScancode_KBD_MEDIA_STOP: HidKeyboardScancode = 243;
pub const HidKeyboardScancode_KBD_MEDIA_FIND: HidKeyboardScancode = 244;
pub const HidKeyboardScancode_KBD_MEDIA_SCROLLUP: HidKeyboardScancode = 245;
pub const HidKeyboardScancode_KBD_MEDIA_SCROLLDOWN: HidKeyboardScancode = 246;
pub const HidKeyboardScancode_KBD_MEDIA_EDIT: HidKeyboardScancode = 247;
pub const HidKeyboardScancode_KBD_MEDIA_SLEEP: HidKeyboardScancode = 248;
pub const HidKeyboardScancode_KBD_MEDIA_COFFEE: HidKeyboardScancode = 249;
pub const HidKeyboardScancode_KBD_MEDIA_REFRESH: HidKeyboardScancode = 250;
pub const HidKeyboardScancode_KBD_MEDIA_CALC: HidKeyboardScancode = 251;
pub type HidKeyboardScancode = u32;
pub const HidControllerType_TYPE_PROCONTROLLER: HidControllerType = 1;
pub const HidControllerType_TYPE_HANDHELD: HidControllerType = 2;
pub const HidControllerType_TYPE_JOYCON_PAIR: HidControllerType = 4;
pub const HidControllerType_TYPE_JOYCON_LEFT: HidControllerType = 8;
pub const HidControllerType_TYPE_JOYCON_RIGHT: HidControllerType = 16;
/// HID controller type
pub type HidControllerType = u32;
/// < Pro Controller or Hid gamepad.
pub const HidControllerLayoutType_LAYOUT_PROCONTROLLER: HidControllerLayoutType = 0;
/// < Two Joy-Con docked to rails.
pub const HidControllerLayoutType_LAYOUT_HANDHELD: HidControllerLayoutType = 1;
/// < Single Joy-Con or pair of Joy-Con, only available in dual-mode with no orientation adjustment.
pub const HidControllerLayoutType_LAYOUT_SINGLE: HidControllerLayoutType = 2;
/// < Only single-mode raw left Joy-Con state, no orientation adjustment.
pub const HidControllerLayoutType_LAYOUT_LEFT: HidControllerLayoutType = 3;
/// < Only single-mode raw right Joy-Con state, no orientation adjustment.
pub const HidControllerLayoutType_LAYOUT_RIGHT: HidControllerLayoutType = 4;
/// < Same as next, but sticks have 8-direction values only.
pub const HidControllerLayoutType_LAYOUT_DEFAULT_DIGITAL: HidControllerLayoutType = 5;
/// < Safe default. Single-mode and ::HidJoyHoldType_Horizontal: Joy-Con have buttons/sticks rotated for orientation, where physical Z(L/R) are unavailable and S(L/R) are mapped to L/R (with physical L/R unavailable).
pub const HidControllerLayoutType_LAYOUT_DEFAULT: HidControllerLayoutType = 6;
pub type HidControllerLayoutType = u32;
pub const HidControllerColorDescription_COLORS_NONEXISTENT: HidControllerColorDescription = 2;
pub type HidControllerColorDescription = u32;
/// < A
pub const HidControllerKeys_KEY_A: HidControllerKeys = 1;
/// < B
pub const HidControllerKeys_KEY_B: HidControllerKeys = 2;
/// < X
pub const HidControllerKeys_KEY_X: HidControllerKeys = 4;
/// < Y
pub const HidControllerKeys_KEY_Y: HidControllerKeys = 8;
/// < Left Stick Button
pub const HidControllerKeys_KEY_LSTICK: HidControllerKeys = 16;
/// < Right Stick Button
pub const HidControllerKeys_KEY_RSTICK: HidControllerKeys = 32;
/// < L
pub const HidControllerKeys_KEY_L: HidControllerKeys = 64;
/// < R
pub const HidControllerKeys_KEY_R: HidControllerKeys = 128;
/// < ZL
pub const HidControllerKeys_KEY_ZL: HidControllerKeys = 256;
/// < ZR
pub const HidControllerKeys_KEY_ZR: HidControllerKeys = 512;
/// < Plus
pub const HidControllerKeys_KEY_PLUS: HidControllerKeys = 1024;
/// < Minus
pub const HidControllerKeys_KEY_MINUS: HidControllerKeys = 2048;
/// < D-Pad Left
pub const HidControllerKeys_KEY_DLEFT: HidControllerKeys = 4096;
/// < D-Pad Up
pub const HidControllerKeys_KEY_DUP: HidControllerKeys = 8192;
/// < D-Pad Right
pub const HidControllerKeys_KEY_DRIGHT: HidControllerKeys = 16384;
/// < D-Pad Down
pub const HidControllerKeys_KEY_DDOWN: HidControllerKeys = 32768;
/// < Left Stick Left
pub const HidControllerKeys_KEY_LSTICK_LEFT: HidControllerKeys = 65536;
/// < Left Stick Up
pub const HidControllerKeys_KEY_LSTICK_UP: HidControllerKeys = 131072;
/// < Left Stick Right
pub const HidControllerKeys_KEY_LSTICK_RIGHT: HidControllerKeys = 262144;
/// < Left Stick Down
pub const HidControllerKeys_KEY_LSTICK_DOWN: HidControllerKeys = 524288;
/// < Right Stick Left
pub const HidControllerKeys_KEY_RSTICK_LEFT: HidControllerKeys = 1048576;
/// < Right Stick Up
pub const HidControllerKeys_KEY_RSTICK_UP: HidControllerKeys = 2097152;
/// < Right Stick Right
pub const HidControllerKeys_KEY_RSTICK_RIGHT: HidControllerKeys = 4194304;
/// < Right Stick Down
pub const HidControllerKeys_KEY_RSTICK_DOWN: HidControllerKeys = 8388608;
/// < SL on Left Joy-Con
pub const HidControllerKeys_KEY_SL_LEFT: HidControllerKeys = 16777216;
/// < SR on Left Joy-Con
pub const HidControllerKeys_KEY_SR_LEFT: HidControllerKeys = 33554432;
/// < SL on Right Joy-Con
pub const HidControllerKeys_KEY_SL_RIGHT: HidControllerKeys = 67108864;
/// < SR on Right Joy-Con
pub const HidControllerKeys_KEY_SR_RIGHT: HidControllerKeys = 134217728;
pub const HidControllerKeys_KEY_TOUCH: HidControllerKeys = 268435456;
pub const HidControllerKeys_KEY_JOYCON_RIGHT: HidControllerKeys = 1;
pub const HidControllerKeys_KEY_JOYCON_DOWN: HidControllerKeys = 2;
pub const HidControllerKeys_KEY_JOYCON_UP: HidControllerKeys = 4;
pub const HidControllerKeys_KEY_JOYCON_LEFT: HidControllerKeys = 8;
/// < D-Pad Up or Sticks Up
pub const HidControllerKeys_KEY_UP: HidControllerKeys = 2236416;
/// < D-Pad Down or Sticks Down
pub const HidControllerKeys_KEY_DOWN: HidControllerKeys = 8945664;
/// < D-Pad Left or Sticks Left
pub const HidControllerKeys_KEY_LEFT: HidControllerKeys = 1118208;
/// < D-Pad Right or Sticks Right
pub const HidControllerKeys_KEY_RIGHT: HidControllerKeys = 4472832;
/// < SL on Left or Right Joy-Con
pub const HidControllerKeys_KEY_SL: HidControllerKeys = 83886080;
/// < SR on Left or Right Joy-Con
pub const HidControllerKeys_KEY_SR: HidControllerKeys = 167772160;
pub type HidControllerKeys = u32;
pub const HidControllerJoystick_JOYSTICK_LEFT: HidControllerJoystick = 0;
pub const HidControllerJoystick_JOYSTICK_RIGHT: HidControllerJoystick = 1;
pub const HidControllerJoystick_JOYSTICK_NUM_STICKS: HidControllerJoystick = 2;
pub type HidControllerJoystick = u32;
pub const HidControllerConnectionState_CONTROLLER_STATE_CONNECTED: HidControllerConnectionState = 1;
pub const HidControllerConnectionState_CONTROLLER_STATE_WIRED: HidControllerConnectionState = 2;
pub type HidControllerConnectionState = u32;
pub const HidControllerID_CONTROLLER_PLAYER_1: HidControllerID = 0;
pub const HidControllerID_CONTROLLER_PLAYER_2: HidControllerID = 1;
pub const HidControllerID_CONTROLLER_PLAYER_3: HidControllerID = 2;
pub const HidControllerID_CONTROLLER_PLAYER_4: HidControllerID = 3;
pub const HidControllerID_CONTROLLER_PLAYER_5: HidControllerID = 4;
pub const HidControllerID_CONTROLLER_PLAYER_6: HidControllerID = 5;
pub const HidControllerID_CONTROLLER_PLAYER_7: HidControllerID = 6;
pub const HidControllerID_CONTROLLER_PLAYER_8: HidControllerID = 7;
pub const HidControllerID_CONTROLLER_HANDHELD: HidControllerID = 8;
pub const HidControllerID_CONTROLLER_UNKNOWN: HidControllerID = 9;
/// < Not an actual HID-sysmodule ID. Only for hidKeys*()/hidJoystickRead()/hidSixAxisSensorValuesRead()/hidGetControllerType()/hidGetControllerColors()/hidIsControllerConnected(). Automatically uses CONTROLLER_PLAYER_1 when connected, otherwise uses CONTROLLER_HANDHELD.
pub const HidControllerID_CONTROLLER_P1_AUTO: HidControllerID = 10;
pub type HidControllerID = u32;
/// < Default / Joy-Con held vertically.
pub const HidJoyHoldType_HidJoyHoldType_Default: HidJoyHoldType = 0;
/// < Joy-Con held horizontally with HID state orientation adjustment, see \ref HidControllerLayoutType.
pub const HidJoyHoldType_HidJoyHoldType_Horizontal: HidJoyHoldType = 1;
pub type HidJoyHoldType = u32;
#[repr(C)]
pub struct touchPosition {
    pub id: u32,
    pub px: u32,
    pub py: u32,
    pub dx: u32,
    pub dy: u32,
    pub angle: u32,
}
#[test]
fn bindgen_test_layout_touchPosition() {
    assert_eq!(
        ::core::mem::size_of::<touchPosition>(),
        24usize,
        concat!("Size of: ", stringify!(touchPosition))
    );
    assert_eq!(
        ::core::mem::align_of::<touchPosition>(),
        4usize,
        concat!("Alignment of ", stringify!(touchPosition))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<touchPosition>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(touchPosition),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<touchPosition>())).px as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(touchPosition),
            "::",
            stringify!(px)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<touchPosition>())).py as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(touchPosition),
            "::",
            stringify!(py)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<touchPosition>())).dx as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(touchPosition),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<touchPosition>())).dy as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(touchPosition),
            "::",
            stringify!(dy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<touchPosition>())).angle as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(touchPosition),
            "::",
            stringify!(angle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JoystickPosition {
    pub dx: s32,
    pub dy: s32,
}
#[test]
fn bindgen_test_layout_JoystickPosition() {
    assert_eq!(
        ::core::mem::size_of::<JoystickPosition>(),
        8usize,
        concat!("Size of: ", stringify!(JoystickPosition))
    );
    assert_eq!(
        ::core::mem::align_of::<JoystickPosition>(),
        4usize,
        concat!("Alignment of ", stringify!(JoystickPosition))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<JoystickPosition>())).dx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JoystickPosition),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<JoystickPosition>())).dy as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JoystickPosition),
            "::",
            stringify!(dy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MousePosition {
    pub x: s32,
    pub y: s32,
    pub velocityX: s32,
    pub velocityY: s32,
    pub scrollVelocityX: s32,
    pub scrollVelocityY: s32,
}
#[test]
fn bindgen_test_layout_MousePosition() {
    assert_eq!(
        ::core::mem::size_of::<MousePosition>(),
        24usize,
        concat!("Size of: ", stringify!(MousePosition))
    );
    assert_eq!(
        ::core::mem::align_of::<MousePosition>(),
        4usize,
        concat!("Alignment of ", stringify!(MousePosition))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MousePosition>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MousePosition),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MousePosition>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MousePosition),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MousePosition>())).velocityX as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MousePosition),
            "::",
            stringify!(velocityX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MousePosition>())).velocityY as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MousePosition),
            "::",
            stringify!(velocityY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MousePosition>())).scrollVelocityX as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MousePosition),
            "::",
            stringify!(scrollVelocityX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MousePosition>())).scrollVelocityY as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MousePosition),
            "::",
            stringify!(scrollVelocityY)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HidVector {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_HidVector() {
    assert_eq!(
        ::core::mem::size_of::<HidVector>(),
        12usize,
        concat!("Size of: ", stringify!(HidVector))
    );
    assert_eq!(
        ::core::mem::align_of::<HidVector>(),
        4usize,
        concat!("Alignment of ", stringify!(HidVector))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidVector>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidVector),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidVector>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HidVector),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidVector>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidVector),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SixAxisSensorValues {
    pub accelerometer: HidVector,
    pub gyroscope: HidVector,
    pub unk: HidVector,
    pub orientation: [HidVector; 3usize],
}
#[test]
fn bindgen_test_layout_SixAxisSensorValues() {
    assert_eq!(
        ::core::mem::size_of::<SixAxisSensorValues>(),
        72usize,
        concat!("Size of: ", stringify!(SixAxisSensorValues))
    );
    assert_eq!(
        ::core::mem::align_of::<SixAxisSensorValues>(),
        4usize,
        concat!("Alignment of ", stringify!(SixAxisSensorValues))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SixAxisSensorValues>())).accelerometer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SixAxisSensorValues),
            "::",
            stringify!(accelerometer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SixAxisSensorValues>())).gyroscope as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SixAxisSensorValues),
            "::",
            stringify!(gyroscope)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SixAxisSensorValues>())).unk as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SixAxisSensorValues),
            "::",
            stringify!(unk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SixAxisSensorValues>())).orientation as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SixAxisSensorValues),
            "::",
            stringify!(orientation)
        )
    );
}
#[repr(C)]
pub struct HidTouchScreenHeader {
    pub timestampTicks: u64,
    pub numEntries: u64,
    pub latestEntry: u64,
    pub maxEntryIndex: u64,
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_HidTouchScreenHeader() {
    assert_eq!(
        ::core::mem::size_of::<HidTouchScreenHeader>(),
        40usize,
        concat!("Size of: ", stringify!(HidTouchScreenHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<HidTouchScreenHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(HidTouchScreenHeader))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidTouchScreenHeader>())).timestampTicks as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenHeader),
            "::",
            stringify!(timestampTicks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidTouchScreenHeader>())).numEntries as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenHeader),
            "::",
            stringify!(numEntries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidTouchScreenHeader>())).latestEntry as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenHeader),
            "::",
            stringify!(latestEntry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidTouchScreenHeader>())).maxEntryIndex as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenHeader),
            "::",
            stringify!(maxEntryIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidTouchScreenHeader>())).timestamp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenHeader),
            "::",
            stringify!(timestamp)
        )
    );
}
#[repr(C)]
pub struct HidTouchScreenEntryHeader {
    pub timestamp: u64,
    pub numTouches: u64,
}
#[test]
fn bindgen_test_layout_HidTouchScreenEntryHeader() {
    assert_eq!(
        ::core::mem::size_of::<HidTouchScreenEntryHeader>(),
        16usize,
        concat!("Size of: ", stringify!(HidTouchScreenEntryHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<HidTouchScreenEntryHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(HidTouchScreenEntryHeader))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidTouchScreenEntryHeader>())).timestamp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntryHeader),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidTouchScreenEntryHeader>())).numTouches as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntryHeader),
            "::",
            stringify!(numTouches)
        )
    );
}
#[repr(C)]
pub struct HidTouchScreenEntryTouch {
    pub timestamp: u64,
    pub padding: u32,
    pub touchIndex: u32,
    pub x: u32,
    pub y: u32,
    pub diameterX: u32,
    pub diameterY: u32,
    pub angle: u32,
    pub padding_2: u32,
}
#[test]
fn bindgen_test_layout_HidTouchScreenEntryTouch() {
    assert_eq!(
        ::core::mem::size_of::<HidTouchScreenEntryTouch>(),
        40usize,
        concat!("Size of: ", stringify!(HidTouchScreenEntryTouch))
    );
    assert_eq!(
        ::core::mem::align_of::<HidTouchScreenEntryTouch>(),
        8usize,
        concat!("Alignment of ", stringify!(HidTouchScreenEntryTouch))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidTouchScreenEntryTouch>())).timestamp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntryTouch),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidTouchScreenEntryTouch>())).padding as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntryTouch),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidTouchScreenEntryTouch>())).touchIndex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntryTouch),
            "::",
            stringify!(touchIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidTouchScreenEntryTouch>())).x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntryTouch),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidTouchScreenEntryTouch>())).y as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntryTouch),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidTouchScreenEntryTouch>())).diameterX as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntryTouch),
            "::",
            stringify!(diameterX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidTouchScreenEntryTouch>())).diameterY as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntryTouch),
            "::",
            stringify!(diameterY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidTouchScreenEntryTouch>())).angle as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntryTouch),
            "::",
            stringify!(angle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidTouchScreenEntryTouch>())).padding_2 as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntryTouch),
            "::",
            stringify!(padding_2)
        )
    );
}
#[repr(C)]
pub struct HidTouchScreenEntry {
    pub header: HidTouchScreenEntryHeader,
    pub touches: [HidTouchScreenEntryTouch; 16usize],
    pub unk: u64,
}
#[test]
fn bindgen_test_layout_HidTouchScreenEntry() {
    assert_eq!(
        ::core::mem::size_of::<HidTouchScreenEntry>(),
        664usize,
        concat!("Size of: ", stringify!(HidTouchScreenEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<HidTouchScreenEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(HidTouchScreenEntry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidTouchScreenEntry>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntry),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidTouchScreenEntry>())).touches as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntry),
            "::",
            stringify!(touches)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidTouchScreenEntry>())).unk as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntry),
            "::",
            stringify!(unk)
        )
    );
}
#[repr(C)]
pub struct HidTouchScreen {
    pub header: HidTouchScreenHeader,
    pub entries: [HidTouchScreenEntry; 17usize],
    pub padding: [u8; 960usize],
}
#[test]
fn bindgen_test_layout_HidTouchScreen() {
    assert_eq!(
        ::core::mem::size_of::<HidTouchScreen>(),
        12288usize,
        concat!("Size of: ", stringify!(HidTouchScreen))
    );
    assert_eq!(
        ::core::mem::align_of::<HidTouchScreen>(),
        8usize,
        concat!("Alignment of ", stringify!(HidTouchScreen))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidTouchScreen>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreen),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidTouchScreen>())).entries as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreen),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidTouchScreen>())).padding as *const _ as usize },
        11328usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreen),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
pub struct HidMouseHeader {
    pub timestampTicks: u64,
    pub numEntries: u64,
    pub latestEntry: u64,
    pub maxEntryIndex: u64,
}
#[test]
fn bindgen_test_layout_HidMouseHeader() {
    assert_eq!(
        ::core::mem::size_of::<HidMouseHeader>(),
        32usize,
        concat!("Size of: ", stringify!(HidMouseHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<HidMouseHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(HidMouseHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidMouseHeader>())).timestampTicks as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidMouseHeader),
            "::",
            stringify!(timestampTicks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidMouseHeader>())).numEntries as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidMouseHeader),
            "::",
            stringify!(numEntries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidMouseHeader>())).latestEntry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidMouseHeader),
            "::",
            stringify!(latestEntry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidMouseHeader>())).maxEntryIndex as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HidMouseHeader),
            "::",
            stringify!(maxEntryIndex)
        )
    );
}
#[repr(C)]
pub struct HidMouseEntry {
    pub timestamp: u64,
    pub timestamp_2: u64,
    pub position: MousePosition,
    pub buttons: u64,
}
#[test]
fn bindgen_test_layout_HidMouseEntry() {
    assert_eq!(
        ::core::mem::size_of::<HidMouseEntry>(),
        48usize,
        concat!("Size of: ", stringify!(HidMouseEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<HidMouseEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(HidMouseEntry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidMouseEntry>())).timestamp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidMouseEntry),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidMouseEntry>())).timestamp_2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidMouseEntry),
            "::",
            stringify!(timestamp_2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidMouseEntry>())).position as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidMouseEntry),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidMouseEntry>())).buttons as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HidMouseEntry),
            "::",
            stringify!(buttons)
        )
    );
}
#[repr(C)]
pub struct HidMouse {
    pub header: HidMouseHeader,
    pub entries: [HidMouseEntry; 17usize],
    pub padding: [u8; 176usize],
}
#[test]
fn bindgen_test_layout_HidMouse() {
    assert_eq!(
        ::core::mem::size_of::<HidMouse>(),
        1024usize,
        concat!("Size of: ", stringify!(HidMouse))
    );
    assert_eq!(
        ::core::mem::align_of::<HidMouse>(),
        8usize,
        concat!("Alignment of ", stringify!(HidMouse))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidMouse>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidMouse),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidMouse>())).entries as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HidMouse),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidMouse>())).padding as *const _ as usize },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(HidMouse),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
pub struct HidKeyboardHeader {
    pub timestampTicks: u64,
    pub numEntries: u64,
    pub latestEntry: u64,
    pub maxEntryIndex: u64,
}
#[test]
fn bindgen_test_layout_HidKeyboardHeader() {
    assert_eq!(
        ::core::mem::size_of::<HidKeyboardHeader>(),
        32usize,
        concat!("Size of: ", stringify!(HidKeyboardHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<HidKeyboardHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(HidKeyboardHeader))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidKeyboardHeader>())).timestampTicks as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidKeyboardHeader),
            "::",
            stringify!(timestampTicks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidKeyboardHeader>())).numEntries as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidKeyboardHeader),
            "::",
            stringify!(numEntries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidKeyboardHeader>())).latestEntry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidKeyboardHeader),
            "::",
            stringify!(latestEntry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidKeyboardHeader>())).maxEntryIndex as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HidKeyboardHeader),
            "::",
            stringify!(maxEntryIndex)
        )
    );
}
#[repr(C)]
pub struct HidKeyboardEntry {
    pub timestamp: u64,
    pub timestamp_2: u64,
    pub modifier: u64,
    pub keys: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_HidKeyboardEntry() {
    assert_eq!(
        ::core::mem::size_of::<HidKeyboardEntry>(),
        56usize,
        concat!("Size of: ", stringify!(HidKeyboardEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<HidKeyboardEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(HidKeyboardEntry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidKeyboardEntry>())).timestamp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidKeyboardEntry),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidKeyboardEntry>())).timestamp_2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidKeyboardEntry),
            "::",
            stringify!(timestamp_2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidKeyboardEntry>())).modifier as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidKeyboardEntry),
            "::",
            stringify!(modifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidKeyboardEntry>())).keys as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HidKeyboardEntry),
            "::",
            stringify!(keys)
        )
    );
}
#[repr(C)]
pub struct HidKeyboard {
    pub header: HidKeyboardHeader,
    pub entries: [HidKeyboardEntry; 17usize],
    pub padding: [u8; 40usize],
}
#[test]
fn bindgen_test_layout_HidKeyboard() {
    assert_eq!(
        ::core::mem::size_of::<HidKeyboard>(),
        1024usize,
        concat!("Size of: ", stringify!(HidKeyboard))
    );
    assert_eq!(
        ::core::mem::align_of::<HidKeyboard>(),
        8usize,
        concat!("Alignment of ", stringify!(HidKeyboard))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidKeyboard>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidKeyboard),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidKeyboard>())).entries as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HidKeyboard),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidKeyboard>())).padding as *const _ as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(HidKeyboard),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
pub struct HidControllerMAC {
    pub timestamp: u64,
    pub mac: [u8; 8usize],
    pub unk: u64,
    pub timestamp_2: u64,
}
#[test]
fn bindgen_test_layout_HidControllerMAC() {
    assert_eq!(
        ::core::mem::size_of::<HidControllerMAC>(),
        32usize,
        concat!("Size of: ", stringify!(HidControllerMAC))
    );
    assert_eq!(
        ::core::mem::align_of::<HidControllerMAC>(),
        8usize,
        concat!("Alignment of ", stringify!(HidControllerMAC))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidControllerMAC>())).timestamp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerMAC),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidControllerMAC>())).mac as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerMAC),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidControllerMAC>())).unk as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerMAC),
            "::",
            stringify!(unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidControllerMAC>())).timestamp_2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerMAC),
            "::",
            stringify!(timestamp_2)
        )
    );
}
#[repr(C)]
pub struct HidControllerHeader {
    pub type_: u32,
    pub isHalf: u32,
    pub singleColorsDescriptor: u32,
    pub singleColorBody: u32,
    pub singleColorButtons: u32,
    pub splitColorsDescriptor: u32,
    pub leftColorBody: u32,
    pub leftColorButtons: u32,
    pub rightColorBody: u32,
    pub rightColorButtons: u32,
}
#[test]
fn bindgen_test_layout_HidControllerHeader() {
    assert_eq!(
        ::core::mem::size_of::<HidControllerHeader>(),
        40usize,
        concat!("Size of: ", stringify!(HidControllerHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<HidControllerHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(HidControllerHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidControllerHeader>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerHeader),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidControllerHeader>())).isHalf as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerHeader),
            "::",
            stringify!(isHalf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerHeader>())).singleColorsDescriptor as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerHeader),
            "::",
            stringify!(singleColorsDescriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerHeader>())).singleColorBody as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerHeader),
            "::",
            stringify!(singleColorBody)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerHeader>())).singleColorButtons as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerHeader),
            "::",
            stringify!(singleColorButtons)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerHeader>())).splitColorsDescriptor as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerHeader),
            "::",
            stringify!(splitColorsDescriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerHeader>())).leftColorBody as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerHeader),
            "::",
            stringify!(leftColorBody)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerHeader>())).leftColorButtons as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerHeader),
            "::",
            stringify!(leftColorButtons)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerHeader>())).rightColorBody as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerHeader),
            "::",
            stringify!(rightColorBody)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerHeader>())).rightColorButtons as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerHeader),
            "::",
            stringify!(rightColorButtons)
        )
    );
}
/// Info struct extracted from HidControllerHeader.
/// Color fields are zero when not set. This can happen even when the *Set fields are set to true.
#[repr(C)]
pub struct HidControllerColors {
    /// < Set to true when the below fields are valid.
    pub singleSet: bool,
    /// < RGBA Single Body Color
    pub singleColorBody: u32,
    /// < RGBA Single Buttons Color
    pub singleColorButtons: u32,
    /// < Set to true when the below fields are valid.
    pub splitSet: bool,
    /// < RGBA Left Body Color
    pub leftColorBody: u32,
    /// < RGBA Left Buttons Color
    pub leftColorButtons: u32,
    /// < RGBA Right Body Color
    pub rightColorBody: u32,
    /// < RGBA Right Buttons Color
    pub rightColorButtons: u32,
}
#[test]
fn bindgen_test_layout_HidControllerColors() {
    assert_eq!(
        ::core::mem::size_of::<HidControllerColors>(),
        32usize,
        concat!("Size of: ", stringify!(HidControllerColors))
    );
    assert_eq!(
        ::core::mem::align_of::<HidControllerColors>(),
        4usize,
        concat!("Alignment of ", stringify!(HidControllerColors))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidControllerColors>())).singleSet as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerColors),
            "::",
            stringify!(singleSet)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerColors>())).singleColorBody as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerColors),
            "::",
            stringify!(singleColorBody)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerColors>())).singleColorButtons as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerColors),
            "::",
            stringify!(singleColorButtons)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidControllerColors>())).splitSet as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerColors),
            "::",
            stringify!(splitSet)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerColors>())).leftColorBody as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerColors),
            "::",
            stringify!(leftColorBody)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerColors>())).leftColorButtons as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerColors),
            "::",
            stringify!(leftColorButtons)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerColors>())).rightColorBody as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerColors),
            "::",
            stringify!(rightColorBody)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerColors>())).rightColorButtons as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerColors),
            "::",
            stringify!(rightColorButtons)
        )
    );
}
#[repr(C)]
pub struct HidControllerLayoutHeader {
    pub timestampTicks: u64,
    pub numEntries: u64,
    pub latestEntry: u64,
    pub maxEntryIndex: u64,
}
#[test]
fn bindgen_test_layout_HidControllerLayoutHeader() {
    assert_eq!(
        ::core::mem::size_of::<HidControllerLayoutHeader>(),
        32usize,
        concat!("Size of: ", stringify!(HidControllerLayoutHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<HidControllerLayoutHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(HidControllerLayoutHeader))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerLayoutHeader>())).timestampTicks as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerLayoutHeader),
            "::",
            stringify!(timestampTicks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerLayoutHeader>())).numEntries as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerLayoutHeader),
            "::",
            stringify!(numEntries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerLayoutHeader>())).latestEntry as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerLayoutHeader),
            "::",
            stringify!(latestEntry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerLayoutHeader>())).maxEntryIndex as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerLayoutHeader),
            "::",
            stringify!(maxEntryIndex)
        )
    );
}
#[repr(C)]
pub struct HidControllerInputEntry {
    pub timestamp: u64,
    pub timestamp_2: u64,
    pub buttons: u64,
    pub joysticks: [JoystickPosition; 2usize],
    pub connectionState: u64,
}
#[test]
fn bindgen_test_layout_HidControllerInputEntry() {
    assert_eq!(
        ::core::mem::size_of::<HidControllerInputEntry>(),
        48usize,
        concat!("Size of: ", stringify!(HidControllerInputEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<HidControllerInputEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(HidControllerInputEntry))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerInputEntry>())).timestamp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerInputEntry),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerInputEntry>())).timestamp_2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerInputEntry),
            "::",
            stringify!(timestamp_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerInputEntry>())).buttons as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerInputEntry),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerInputEntry>())).joysticks as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerInputEntry),
            "::",
            stringify!(joysticks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerInputEntry>())).connectionState as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerInputEntry),
            "::",
            stringify!(connectionState)
        )
    );
}
#[repr(C)]
pub struct HidControllerLayout {
    pub header: HidControllerLayoutHeader,
    pub entries: [HidControllerInputEntry; 17usize],
}
#[test]
fn bindgen_test_layout_HidControllerLayout() {
    assert_eq!(
        ::core::mem::size_of::<HidControllerLayout>(),
        848usize,
        concat!("Size of: ", stringify!(HidControllerLayout))
    );
    assert_eq!(
        ::core::mem::align_of::<HidControllerLayout>(),
        8usize,
        concat!("Alignment of ", stringify!(HidControllerLayout))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidControllerLayout>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerLayout),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidControllerLayout>())).entries as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerLayout),
            "::",
            stringify!(entries)
        )
    );
}
#[repr(C)]
pub struct HidControllerSixAxisHeader {
    pub timestamp: u64,
    pub numEntries: u64,
    pub latestEntry: u64,
    pub maxEntryIndex: u64,
}
#[test]
fn bindgen_test_layout_HidControllerSixAxisHeader() {
    assert_eq!(
        ::core::mem::size_of::<HidControllerSixAxisHeader>(),
        32usize,
        concat!("Size of: ", stringify!(HidControllerSixAxisHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<HidControllerSixAxisHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(HidControllerSixAxisHeader))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerSixAxisHeader>())).timestamp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerSixAxisHeader),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerSixAxisHeader>())).numEntries as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerSixAxisHeader),
            "::",
            stringify!(numEntries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerSixAxisHeader>())).latestEntry as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerSixAxisHeader),
            "::",
            stringify!(latestEntry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerSixAxisHeader>())).maxEntryIndex as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerSixAxisHeader),
            "::",
            stringify!(maxEntryIndex)
        )
    );
}
#[repr(C)]
pub struct HidControllerSixAxisEntry {
    pub timestamp: u64,
    pub unk_1: u64,
    pub timestamp_2: u64,
    pub values: SixAxisSensorValues,
    pub unk_3: u64,
}
#[test]
fn bindgen_test_layout_HidControllerSixAxisEntry() {
    assert_eq!(
        ::core::mem::size_of::<HidControllerSixAxisEntry>(),
        104usize,
        concat!("Size of: ", stringify!(HidControllerSixAxisEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<HidControllerSixAxisEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(HidControllerSixAxisEntry))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerSixAxisEntry>())).timestamp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerSixAxisEntry),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerSixAxisEntry>())).unk_1 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerSixAxisEntry),
            "::",
            stringify!(unk_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerSixAxisEntry>())).timestamp_2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerSixAxisEntry),
            "::",
            stringify!(timestamp_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerSixAxisEntry>())).values as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerSixAxisEntry),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerSixAxisEntry>())).unk_3 as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerSixAxisEntry),
            "::",
            stringify!(unk_3)
        )
    );
}
#[repr(C)]
pub struct HidControllerSixAxisLayout {
    pub header: HidControllerSixAxisHeader,
    pub entries: [HidControllerSixAxisEntry; 17usize],
}
#[test]
fn bindgen_test_layout_HidControllerSixAxisLayout() {
    assert_eq!(
        ::core::mem::size_of::<HidControllerSixAxisLayout>(),
        1800usize,
        concat!("Size of: ", stringify!(HidControllerSixAxisLayout))
    );
    assert_eq!(
        ::core::mem::align_of::<HidControllerSixAxisLayout>(),
        8usize,
        concat!("Alignment of ", stringify!(HidControllerSixAxisLayout))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerSixAxisLayout>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerSixAxisLayout),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerSixAxisLayout>())).entries as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerSixAxisLayout),
            "::",
            stringify!(entries)
        )
    );
}
#[repr(C)]
pub struct HidController {
    pub header: HidControllerHeader,
    pub layouts: [HidControllerLayout; 7usize],
    pub sixaxis: [HidControllerSixAxisLayout; 6usize],
    pub unk_1: [u8; 64usize],
    pub macLeft: HidControllerMAC,
    pub macRight: HidControllerMAC,
    pub unk_2: [u8; 3576usize],
}
#[test]
fn bindgen_test_layout_HidController() {
    assert_eq!(
        ::core::mem::size_of::<HidController>(),
        20480usize,
        concat!("Size of: ", stringify!(HidController))
    );
    assert_eq!(
        ::core::mem::align_of::<HidController>(),
        8usize,
        concat!("Alignment of ", stringify!(HidController))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidController>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidController),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidController>())).layouts as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HidController),
            "::",
            stringify!(layouts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidController>())).sixaxis as *const _ as usize },
        5976usize,
        concat!(
            "Offset of field: ",
            stringify!(HidController),
            "::",
            stringify!(sixaxis)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidController>())).unk_1 as *const _ as usize },
        16776usize,
        concat!(
            "Offset of field: ",
            stringify!(HidController),
            "::",
            stringify!(unk_1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidController>())).macLeft as *const _ as usize },
        16840usize,
        concat!(
            "Offset of field: ",
            stringify!(HidController),
            "::",
            stringify!(macLeft)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidController>())).macRight as *const _ as usize },
        16872usize,
        concat!(
            "Offset of field: ",
            stringify!(HidController),
            "::",
            stringify!(macRight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidController>())).unk_2 as *const _ as usize },
        16904usize,
        concat!(
            "Offset of field: ",
            stringify!(HidController),
            "::",
            stringify!(unk_2)
        )
    );
}
#[repr(C)]
pub struct HidSharedMemory {
    pub header: [u8; 1024usize],
    pub touchscreen: HidTouchScreen,
    pub mouse: HidMouse,
    pub keyboard: HidKeyboard,
    pub unkSection1: [u8; 1024usize],
    pub unkSection2: [u8; 1024usize],
    pub unkSection3: [u8; 1024usize],
    pub unkSection4: [u8; 1024usize],
    pub unkSection5: [u8; 512usize],
    pub unkSection6: [u8; 512usize],
    pub unkSection7: [u8; 512usize],
    pub unkSection8: [u8; 2048usize],
    pub controllerSerials: [u8; 16384usize],
    pub controllers: [HidController; 10usize],
    pub unkSection9: [u8; 17920usize],
}
#[test]
fn bindgen_test_layout_HidSharedMemory() {
    assert_eq!(
        ::core::mem::size_of::<HidSharedMemory>(),
        262144usize,
        concat!("Size of: ", stringify!(HidSharedMemory))
    );
    assert_eq!(
        ::core::mem::align_of::<HidSharedMemory>(),
        8usize,
        concat!("Alignment of ", stringify!(HidSharedMemory))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).touchscreen as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(touchscreen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).mouse as *const _ as usize },
        13312usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(mouse)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).keyboard as *const _ as usize },
        14336usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(keyboard)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).unkSection1 as *const _ as usize },
        15360usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(unkSection1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).unkSection2 as *const _ as usize },
        16384usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(unkSection2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).unkSection3 as *const _ as usize },
        17408usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(unkSection3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).unkSection4 as *const _ as usize },
        18432usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(unkSection4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).unkSection5 as *const _ as usize },
        19456usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(unkSection5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).unkSection6 as *const _ as usize },
        19968usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(unkSection6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).unkSection7 as *const _ as usize },
        20480usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(unkSection7)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).unkSection8 as *const _ as usize },
        20992usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(unkSection8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidSharedMemory>())).controllerSerials as *const _ as usize
        },
        23040usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(controllerSerials)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).controllers as *const _ as usize },
        39424usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(controllers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).unkSection9 as *const _ as usize },
        244224usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(unkSection9)
        )
    );
}
#[repr(C)]
pub struct HidVibrationDeviceInfo {
    pub unk_x0: u32,
    /// < 0x1 for left-joycon, 0x2 for right-joycon.
    pub unk_x4: u32,
}
#[test]
fn bindgen_test_layout_HidVibrationDeviceInfo() {
    assert_eq!(
        ::core::mem::size_of::<HidVibrationDeviceInfo>(),
        8usize,
        concat!("Size of: ", stringify!(HidVibrationDeviceInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<HidVibrationDeviceInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(HidVibrationDeviceInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidVibrationDeviceInfo>())).unk_x0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidVibrationDeviceInfo),
            "::",
            stringify!(unk_x0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidVibrationDeviceInfo>())).unk_x4 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HidVibrationDeviceInfo),
            "::",
            stringify!(unk_x4)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HidVibrationValue {
    /// < Low Band amplitude. 1.0f: Max amplitude.
    pub amp_low: f32,
    /// < Low Band frequency in Hz.
    pub freq_low: f32,
    /// < High Band amplitude. 1.0f: Max amplitude.
    pub amp_high: f32,
    /// < High Band frequency in Hz.
    pub freq_high: f32,
}
#[test]
fn bindgen_test_layout_HidVibrationValue() {
    assert_eq!(
        ::core::mem::size_of::<HidVibrationValue>(),
        16usize,
        concat!("Size of: ", stringify!(HidVibrationValue))
    );
    assert_eq!(
        ::core::mem::align_of::<HidVibrationValue>(),
        4usize,
        concat!("Alignment of ", stringify!(HidVibrationValue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidVibrationValue>())).amp_low as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidVibrationValue),
            "::",
            stringify!(amp_low)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidVibrationValue>())).freq_low as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HidVibrationValue),
            "::",
            stringify!(freq_low)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidVibrationValue>())).amp_high as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidVibrationValue),
            "::",
            stringify!(amp_high)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidVibrationValue>())).freq_high as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HidVibrationValue),
            "::",
            stringify!(freq_high)
        )
    );
}
extern "C" {
    /// Initializes hid, called automatically during app startup.
    pub fn hidInitialize() -> Result;
}
extern "C" {
    pub fn hidExit();
}
extern "C" {
    pub fn hidReset();
}
extern "C" {
    pub fn hidGetSessionService() -> *mut Service;
}
extern "C" {
    pub fn hidGetSharedmemAddr() -> *mut ctypes::c_void;
}
extern "C" {
    pub fn hidSetControllerLayout(id: HidControllerID, layoutType: HidControllerLayoutType);
}
extern "C" {
    pub fn hidGetControllerLayout(id: HidControllerID) -> HidControllerLayoutType;
}
extern "C" {
    /// Gets the \ref HidControllerType for the specified controller.
    pub fn hidGetControllerType(id: HidControllerID) -> HidControllerType;
}
extern "C" {
    pub fn hidGetControllerColors(id: HidControllerID, colors: *mut HidControllerColors);
}
extern "C" {
    pub fn hidIsControllerConnected(id: HidControllerID) -> bool;
}
extern "C" {
    pub fn hidScanInput();
}
extern "C" {
    pub fn hidKeysHeld(id: HidControllerID) -> u64;
}
extern "C" {
    pub fn hidKeysDown(id: HidControllerID) -> u64;
}
extern "C" {
    pub fn hidKeysUp(id: HidControllerID) -> u64;
}
extern "C" {
    pub fn hidMouseButtonsHeld() -> u64;
}
extern "C" {
    pub fn hidMouseButtonsDown() -> u64;
}
extern "C" {
    pub fn hidMouseButtonsUp() -> u64;
}
extern "C" {
    pub fn hidMouseRead(pos: *mut MousePosition);
}
extern "C" {
    pub fn hidMouseMultiRead(entries: *mut MousePosition, num_entries: u32) -> u32;
}
extern "C" {
    pub fn hidKeyboardModifierHeld(modifier: HidKeyboardModifier) -> bool;
}
extern "C" {
    pub fn hidKeyboardModifierDown(modifier: HidKeyboardModifier) -> bool;
}
extern "C" {
    pub fn hidKeyboardModifierUp(modifier: HidKeyboardModifier) -> bool;
}
extern "C" {
    pub fn hidKeyboardHeld(key: HidKeyboardScancode) -> bool;
}
extern "C" {
    pub fn hidKeyboardDown(key: HidKeyboardScancode) -> bool;
}
extern "C" {
    pub fn hidKeyboardUp(key: HidKeyboardScancode) -> bool;
}
extern "C" {
    pub fn hidTouchCount() -> u32;
}
extern "C" {
    pub fn hidTouchRead(pos: *mut touchPosition, point_id: u32);
}
extern "C" {
    pub fn hidJoystickRead(
        pos: *mut JoystickPosition,
        id: HidControllerID,
        stick: HidControllerJoystick,
    );
}
extern "C" {
    pub fn hidSixAxisSensorValuesRead(
        values: *mut SixAxisSensorValues,
        id: HidControllerID,
        num_entries: u32,
    ) -> u32;
}
extern "C" {
    /// This can be used to check what CONTROLLER_P1_AUTO uses.
    /// Returns 0 when CONTROLLER_PLAYER_1 is connected, otherwise returns 1 for handheld-mode.
    pub fn hidGetHandheldMode() -> bool;
}
extern "C" {
    /// This is automatically called with CONTROLLER_PLAYER_{1-8} and CONTROLLER_HANDHELD in \ref hidInitialize.
    /// count must be <=10. Each entry in buf must be CONTROLLER_PLAYER_{1-8} or CONTROLLER_HANDHELD.
    pub fn hidSetSupportedNpadIdType(buf: *mut HidControllerID, count: usize) -> Result;
}
extern "C" {
    /// Sets which controller types are supported. This is automatically called with all types in \ref hidInitialize.
    pub fn hidSetSupportedNpadStyleSet(type_: HidControllerType) -> Result;
}
extern "C" {
    /// Gets an event with the specified autoclear for the input controller.
    /// The user *must* close the event when finished with it / before the app exits.
    /// This is signaled when the \ref hidGetControllerType output is updated for the controller.
    pub fn hidAcquireNpadStyleSetUpdateEventHandle(
        id: HidControllerID,
        event: *mut Event,
        autoclear: bool,
    ) -> Result;
}
extern "C" {
    /// Sets the hold-type, see \ref HidJoyHoldType.
    pub fn hidSetNpadJoyHoldType(type_: HidJoyHoldType) -> Result;
}
extern "C" {
    /// Use this if you want to use a single joy-con as a dedicated CONTROLLER_PLAYER_*.
    /// When used, both joy-cons in a pair should be used with this (CONTROLLER_PLAYER_1 and CONTROLLER_PLAYER_2 for example).
    /// id must be CONTROLLER_PLAYER_*.
    pub fn hidSetNpadJoyAssignmentModeSingleByDefault(id: HidControllerID) -> Result;
}
extern "C" {
    /// Use this if you want to use a pair of joy-cons as a single CONTROLLER_PLAYER_*. Only necessary if you want to use this mode in your application after \ref hidSetNpadJoyAssignmentModeSingleByDefault was used with this pair of joy-cons.
    /// Used automatically during app startup/exit for all controllers.
    /// When used, both joy-cons in a pair should be used with this (CONTROLLER_PLAYER_1 and CONTROLLER_PLAYER_2 for example).
    /// id must be CONTROLLER_PLAYER_*.
    pub fn hidSetNpadJoyAssignmentModeDual(id: HidControllerID) -> Result;
}
extern "C" {
    /// Merge two single joy-cons into a dual-mode controller. Use this after \ref hidSetNpadJoyAssignmentModeDual, when \ref hidSetNpadJoyAssignmentModeSingleByDefault was previously used (this includes using this manually at application exit).
    /// To be successful, id0/id1 must correspond to controller types TYPE_JOYCON_LEFT/TYPE_JOYCON_RIGHT, or TYPE_JOYCON_RIGHT/TYPE_JOYCON_LEFT.
    /// If successful, the id of the resulting dual controller is set to id0.
    pub fn hidMergeSingleJoyAsDualJoy(id0: HidControllerID, id1: HidControllerID) -> Result;
}
extern "C" {
    pub fn hidInitializeVibrationDevices(
        VibrationDeviceHandles: *mut u32,
        total_handles: usize,
        id: HidControllerID,
        type_: HidControllerType,
    ) -> Result;
}
extern "C" {
    /// Gets HidVibrationDeviceInfo for the specified VibrationDeviceHandle.
    pub fn hidGetVibrationDeviceInfo(
        VibrationDeviceHandle: *mut u32,
        VibrationDeviceInfo: *mut HidVibrationDeviceInfo,
    ) -> Result;
}
extern "C" {
    /// Send the VibrationValue to the specified VibrationDeviceHandle.
    pub fn hidSendVibrationValue(
        VibrationDeviceHandle: *mut u32,
        VibrationValue: *mut HidVibrationValue,
    ) -> Result;
}
extern "C" {
    /// Gets the current HidVibrationValue for the specified VibrationDeviceHandle.
    pub fn hidGetActualVibrationValue(
        VibrationDeviceHandle: *mut u32,
        VibrationValue: *mut HidVibrationValue,
    ) -> Result;
}
extern "C" {
    /// Sets whether vibration is allowed, this also affects the config displayed by System Settings.
    pub fn hidPermitVibration(flag: bool) -> Result;
}
extern "C" {
    /// Gets whether vibration is allowed.
    pub fn hidIsVibrationPermitted(flag: *mut bool) -> Result;
}
extern "C" {
    /// Send VibrationValues[index] to VibrationDeviceHandles[index], where count is the number of entries in the VibrationDeviceHandles/VibrationValues arrays.
    pub fn hidSendVibrationValues(
        VibrationDeviceHandles: *mut u32,
        VibrationValues: *mut HidVibrationValue,
        count: usize,
    ) -> Result;
}
extern "C" {
    /// Gets SixAxisSensorHandles. total_handles==2 can only be used with TYPE_JOYCON_PAIR.
    pub fn hidGetSixAxisSensorHandles(
        SixAxisSensorHandles: *mut u32,
        total_handles: usize,
        id: HidControllerID,
        type_: HidControllerType,
    ) -> Result;
}
extern "C" {
    /// Starts the SixAxisSensor for the specified handle.
    pub fn hidStartSixAxisSensor(SixAxisSensorHandle: u32) -> Result;
}
extern "C" {
    /// Stops the SixAxisSensor for the specified handle.
    pub fn hidStopSixAxisSensor(SixAxisSensorHandle: u32) -> Result;
}
extern "C" {
    pub fn hidsysInitialize() -> Result;
}
extern "C" {
    pub fn hidsysExit();
}
extern "C" {
    pub fn hidsysEnableAppletToGetInput(enable: bool) -> Result;
}
extern "C" {
    /// @brief Returns an event that fires when the home button is pressed, this will prevent the home menu from opening when the button is pressed. This event does not auto clear.
    pub fn hidsysAcquireHomeButtonEventHandle(event_out: *mut Event) -> Result;
}
extern "C" {
    pub fn hidsysActivateHomeButton() -> Result;
}
extern "C" {
    pub fn hidsysActivateSleepButton() -> Result;
}
extern "C" {
    pub fn hidsysActivateCaptureButton() -> Result;
}
#[repr(C, packed)]
pub struct IrsPackedMomentProcessorConfig {
    pub unk_x0: u64,
    pub unk_x8: u8,
    pub unk_x9: u8,
    pub unk_xa: u8,
    pub pad: [u8; 5usize],
    pub unk_x10: u16,
    pub unk_x12: u32,
    pub unk_x16: u16,
    pub unk_constant: u32,
    pub unk_x1c: u8,
    pub unk_x1d: u8,
    pub pad2: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_IrsPackedMomentProcessorConfig() {
    assert_eq!(
        ::core::mem::size_of::<IrsPackedMomentProcessorConfig>(),
        32usize,
        concat!("Size of: ", stringify!(IrsPackedMomentProcessorConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<IrsPackedMomentProcessorConfig>(),
        1usize,
        concat!("Alignment of ", stringify!(IrsPackedMomentProcessorConfig))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedMomentProcessorConfig>())).unk_x0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedMomentProcessorConfig),
            "::",
            stringify!(unk_x0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedMomentProcessorConfig>())).unk_x8 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedMomentProcessorConfig),
            "::",
            stringify!(unk_x8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedMomentProcessorConfig>())).unk_x9 as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedMomentProcessorConfig),
            "::",
            stringify!(unk_x9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedMomentProcessorConfig>())).unk_xa as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedMomentProcessorConfig),
            "::",
            stringify!(unk_xa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedMomentProcessorConfig>())).pad as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedMomentProcessorConfig),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedMomentProcessorConfig>())).unk_x10 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedMomentProcessorConfig),
            "::",
            stringify!(unk_x10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedMomentProcessorConfig>())).unk_x12 as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedMomentProcessorConfig),
            "::",
            stringify!(unk_x12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedMomentProcessorConfig>())).unk_x16 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedMomentProcessorConfig),
            "::",
            stringify!(unk_x16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedMomentProcessorConfig>())).unk_constant as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedMomentProcessorConfig),
            "::",
            stringify!(unk_constant)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedMomentProcessorConfig>())).unk_x1c as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedMomentProcessorConfig),
            "::",
            stringify!(unk_x1c)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedMomentProcessorConfig>())).unk_x1d as *const _ as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedMomentProcessorConfig),
            "::",
            stringify!(unk_x1d)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedMomentProcessorConfig>())).pad2 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedMomentProcessorConfig),
            "::",
            stringify!(pad2)
        )
    );
}
#[repr(C)]
pub struct IrsImageTransferProcessorConfig {
    /// < IR Sensor exposure time in nanoseconds.
    pub exposure: u64,
    /// < Controls the IR leds. 0: All leds, 1: Bright group, 2: Dim group, 3: None.
    pub ir_leds: u32,
    /// < IR sensor signal's digital gain.
    pub digital_gain: u32,
    /// < Inverts the colors of the captured image. 0: Normal image, 1: Negative image.
    pub color_invert: u8,
    pub pad: [u8; 7usize],
    /// < IR Sensor resolution. 0: 240x320, 1: 120x160, 2: 60x80.
    pub sensor_res: u32,
}
#[test]
fn bindgen_test_layout_IrsImageTransferProcessorConfig() {
    assert_eq!(
        ::core::mem::size_of::<IrsImageTransferProcessorConfig>(),
        32usize,
        concat!("Size of: ", stringify!(IrsImageTransferProcessorConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<IrsImageTransferProcessorConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(IrsImageTransferProcessorConfig))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsImageTransferProcessorConfig>())).exposure as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsImageTransferProcessorConfig),
            "::",
            stringify!(exposure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsImageTransferProcessorConfig>())).ir_leds as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsImageTransferProcessorConfig),
            "::",
            stringify!(ir_leds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsImageTransferProcessorConfig>())).digital_gain as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsImageTransferProcessorConfig),
            "::",
            stringify!(digital_gain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsImageTransferProcessorConfig>())).color_invert as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsImageTransferProcessorConfig),
            "::",
            stringify!(color_invert)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsImageTransferProcessorConfig>())).pad as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsImageTransferProcessorConfig),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsImageTransferProcessorConfig>())).sensor_res as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsImageTransferProcessorConfig),
            "::",
            stringify!(sensor_res)
        )
    );
}
#[repr(C)]
pub struct IrsPackedImageTransferProcessorConfig {
    /// < IR Sensor exposure time in nanoseconds.
    pub exposure: u64,
    /// < Controls the IR leds. 0: All leds, 1: Bright group, 2: Dim group, 3: None.
    pub ir_leds: u8,
    /// < IR sensor signal's digital gain.
    pub digital_gain: u8,
    /// < Inverts the colors of the captured image. 0: Normal image, 1: Negative image.
    pub color_invert: u8,
    pub pad: [u8; 5usize],
    pub unk_constant: u32,
    /// < IR Sensor resolution. 0: 240x320, 1: 120x160, 2: 60x80.
    pub sensor_res: u8,
    pub pad2: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_IrsPackedImageTransferProcessorConfig() {
    assert_eq!(
        ::core::mem::size_of::<IrsPackedImageTransferProcessorConfig>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(IrsPackedImageTransferProcessorConfig)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<IrsPackedImageTransferProcessorConfig>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(IrsPackedImageTransferProcessorConfig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedImageTransferProcessorConfig>())).exposure as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedImageTransferProcessorConfig),
            "::",
            stringify!(exposure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedImageTransferProcessorConfig>())).ir_leds as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedImageTransferProcessorConfig),
            "::",
            stringify!(ir_leds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedImageTransferProcessorConfig>())).digital_gain
                as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedImageTransferProcessorConfig),
            "::",
            stringify!(digital_gain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedImageTransferProcessorConfig>())).color_invert
                as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedImageTransferProcessorConfig),
            "::",
            stringify!(color_invert)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedImageTransferProcessorConfig>())).pad as *const _
                as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedImageTransferProcessorConfig),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedImageTransferProcessorConfig>())).unk_constant
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedImageTransferProcessorConfig),
            "::",
            stringify!(unk_constant)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedImageTransferProcessorConfig>())).sensor_res
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedImageTransferProcessorConfig),
            "::",
            stringify!(sensor_res)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedImageTransferProcessorConfig>())).pad2 as *const _
                as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedImageTransferProcessorConfig),
            "::",
            stringify!(pad2)
        )
    );
}
#[repr(C, packed)]
pub struct IrsImageTransferProcessorState {
    pub unk_x0: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_IrsImageTransferProcessorState() {
    assert_eq!(
        ::core::mem::size_of::<IrsImageTransferProcessorState>(),
        16usize,
        concat!("Size of: ", stringify!(IrsImageTransferProcessorState))
    );
    assert_eq!(
        ::core::mem::align_of::<IrsImageTransferProcessorState>(),
        1usize,
        concat!("Alignment of ", stringify!(IrsImageTransferProcessorState))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsImageTransferProcessorState>())).unk_x0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsImageTransferProcessorState),
            "::",
            stringify!(unk_x0)
        )
    );
}
extern "C" {
    /// Initialize irs.
    pub fn irsInitialize() -> Result;
}
extern "C" {
    /// Exit irs.
    pub fn irsExit();
}
extern "C" {
    pub fn irsGetSessionService() -> *mut Service;
}
extern "C" {
    pub fn irsGetSharedmemAddr() -> *mut ctypes::c_void;
}
extern "C" {
    /// (De)activate the IR sensor, this is automatically used by \ref irsExit. Must be called after irsInitialize() to activate the IR sensor.
    pub fn irsActivateIrsensor(activate: bool) -> Result;
}
extern "C" {
    pub fn irsGetIrCameraHandle(IrCameraHandle: *mut u32, id: HidControllerID) -> Result;
}
extern "C" {
    /// @brief Start ImageTransferProcessor.
    /// @param[in] IrCameraHandle Camera handle.
    /// @param[in] config Input config.
    /// @param[in] size Work-buffer size, must be 0x1000-byte aligned.
    /// @note Do not use if already started.
    pub fn irsRunImageTransferProcessor(
        IrCameraHandle: u32,
        config: *mut IrsImageTransferProcessorConfig,
        size: usize,
    ) -> Result;
}
extern "C" {
    pub fn irsGetImageTransferProcessorState(
        IrCameraHandle: u32,
        buffer: *mut ctypes::c_void,
        size: usize,
        state: *mut IrsImageTransferProcessorState,
    ) -> Result;
}
extern "C" {
    /// Stop ImageTransferProcessor. Do not use if already stopped.
    /// \ref irsExit calls this with all IrCameraHandles which were not already used with \ref irsStopImageProcessor.
    pub fn irsStopImageProcessor(IrCameraHandle: u32) -> Result;
}
extern "C" {
    /// "Suspend" ImageTransferProcessor.
    /// TODO: What does this really do?
    pub fn irsSuspendImageProcessor(IrCameraHandle: u32) -> Result;
}
extern "C" {
    /// Gets the default configuration for Image Transfer mode.
    /// Defaults are exposure 300us, IR LEDs all ON, 8x digital gain, normal image and resolution 240 x 320.
    pub fn irsGetDefaultImageTransferProcessorConfig(config: *mut IrsImageTransferProcessorConfig);
}
/// < Japan, US and Europe
pub const PlSharedFontType_PlSharedFontType_Standard: PlSharedFontType = 0;
/// < Chinese Simplified
pub const PlSharedFontType_PlSharedFontType_ChineseSimplified: PlSharedFontType = 1;
/// < Extended Chinese Simplified
pub const PlSharedFontType_PlSharedFontType_ExtChineseSimplified: PlSharedFontType = 2;
/// < Chinese Traditional
pub const PlSharedFontType_PlSharedFontType_ChineseTraditional: PlSharedFontType = 3;
/// < Korean (Hangul)
pub const PlSharedFontType_PlSharedFontType_KO: PlSharedFontType = 4;
/// < Nintendo Extended. This font only has the special Nintendo-specific characters, which aren't available with the other fonts.
pub const PlSharedFontType_PlSharedFontType_NintendoExt: PlSharedFontType = 5;
/// < Total fonts supported by this enum.
pub const PlSharedFontType_PlSharedFontType_Total: PlSharedFontType = 6;
pub type PlSharedFontType = u32;
#[repr(C)]
pub struct PlFontData {
    pub type_: u32,
    pub offset: u32,
    pub size: u32,
    pub address: *mut ctypes::c_void,
}
#[test]
fn bindgen_test_layout_PlFontData() {
    assert_eq!(
        ::core::mem::size_of::<PlFontData>(),
        24usize,
        concat!("Size of: ", stringify!(PlFontData))
    );
    assert_eq!(
        ::core::mem::align_of::<PlFontData>(),
        8usize,
        concat!("Alignment of ", stringify!(PlFontData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PlFontData>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PlFontData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PlFontData>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PlFontData),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PlFontData>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PlFontData),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PlFontData>())).address as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PlFontData),
            "::",
            stringify!(address)
        )
    );
}
extern "C" {
    pub fn plInitialize() -> Result;
}
extern "C" {
    pub fn plExit();
}
extern "C" {
    pub fn plGetSharedmemAddr() -> *mut ctypes::c_void;
}
extern "C" {
    pub fn plGetSharedFontByType(font: *mut PlFontData, SharedFontType: u32) -> Result;
}
extern "C" {
    pub fn plGetSharedFont(
        LanguageCode: u64,
        fonts: *mut PlFontData,
        max_fonts: usize,
        total_fonts: *mut usize,
    ) -> Result;
}
#[repr(C)]
pub struct ViDisplay {
    pub display_id: u64,
    pub display_name: [ctypes::c_char; 64usize],
    pub initialized: bool,
}
#[test]
fn bindgen_test_layout_ViDisplay() {
    assert_eq!(
        ::core::mem::size_of::<ViDisplay>(),
        80usize,
        concat!("Size of: ", stringify!(ViDisplay))
    );
    assert_eq!(
        ::core::mem::align_of::<ViDisplay>(),
        8usize,
        concat!("Alignment of ", stringify!(ViDisplay))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ViDisplay>())).display_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ViDisplay),
            "::",
            stringify!(display_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ViDisplay>())).display_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ViDisplay),
            "::",
            stringify!(display_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ViDisplay>())).initialized as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ViDisplay),
            "::",
            stringify!(initialized)
        )
    );
}
#[repr(C)]
pub struct ViLayer {
    pub layer_id: u64,
    pub igbp_binder_obj_id: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_ViLayer() {
    assert_eq!(
        ::core::mem::size_of::<ViLayer>(),
        16usize,
        concat!("Size of: ", stringify!(ViLayer))
    );
    assert_eq!(
        ::core::mem::align_of::<ViLayer>(),
        8usize,
        concat!("Alignment of ", stringify!(ViLayer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ViLayer>())).layer_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ViLayer),
            "::",
            stringify!(layer_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ViLayer>())).igbp_binder_obj_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ViLayer),
            "::",
            stringify!(igbp_binder_obj_id)
        )
    );
}
impl ViLayer {
    #[inline]
    pub fn initialized(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_initialized(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stray_layer(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_stray_layer(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        initialized: bool,
        stray_layer: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let initialized: u8 = unsafe { ::core::mem::transmute(initialized) };
            initialized as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let stray_layer: u8 = unsafe { ::core::mem::transmute(stray_layer) };
            stray_layer as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const ViServiceType_ViServiceType_Default: ViServiceType = -1;
pub const ViServiceType_ViServiceType_Application: ViServiceType = 0;
pub const ViServiceType_ViServiceType_System: ViServiceType = 1;
pub const ViServiceType_ViServiceType_Manager: ViServiceType = 2;
pub type ViServiceType = i32;
pub const ViLayerFlags_ViLayerFlags_Default: ViLayerFlags = 1;
/// Used by viCreateLayer when CreateStrayLayer is used internally.
pub type ViLayerFlags = u32;
pub const ViScalingMode_ViScalingMode_None: ViScalingMode = 0;
pub const ViScalingMode_ViScalingMode_FitToLayer: ViScalingMode = 2;
pub const ViScalingMode_ViScalingMode_PreserveAspectRatio: ViScalingMode = 4;
pub const ViScalingMode_ViScalingMode_Default: ViScalingMode = 2;
/// Used with viSetLayerScalingMode.
pub type ViScalingMode = u32;
pub const ViPowerState_ViPowerState_Off: ViPowerState = 0;
pub const ViPowerState_ViPowerState_NotScanning: ViPowerState = 1;
pub const ViPowerState_ViPowerState_On: ViPowerState = 2;
/// Used with viSetDisplayPowerState.
pub type ViPowerState = u32;
extern "C" {
    pub fn viInitialize(service_type: ViServiceType) -> Result;
}
extern "C" {
    pub fn viExit();
}
extern "C" {
    pub fn viGetSession_IApplicationDisplayService() -> *mut Service;
}
extern "C" {
    pub fn viGetSession_IHOSBinderDriverRelay() -> *mut Service;
}
extern "C" {
    pub fn viGetSession_ISystemDisplayService() -> *mut Service;
}
extern "C" {
    pub fn viGetSession_IManagerDisplayService() -> *mut Service;
}
extern "C" {
    pub fn viGetSession_IHOSBinderDriverIndirect() -> *mut Service;
}
extern "C" {
    pub fn viSetContentVisibility(v: bool) -> Result;
}
extern "C" {
    pub fn viOpenDisplay(display_name: *const ctypes::c_char, display: *mut ViDisplay) -> Result;
}
extern "C" {
    pub fn viCloseDisplay(display: *mut ViDisplay) -> Result;
}
extern "C" {
    pub fn viGetDisplayResolution(
        display: *mut ViDisplay,
        width: *mut u64,
        height: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn viGetDisplayLogicalResolution(
        display: *mut ViDisplay,
        width: *mut u32,
        height: *mut u32,
    ) -> Result;
}
extern "C" {
    /// Only available on [3.0.0+].
    pub fn viSetDisplayMagnification(
        display: *mut ViDisplay,
        x: u32,
        y: u32,
        width: u32,
        height: u32,
    ) -> Result;
}
extern "C" {
    pub fn viGetDisplayVsyncEvent(display: *mut ViDisplay, event_out: *mut Event) -> Result;
}
extern "C" {
    pub fn viSetDisplayPowerState(display: *mut ViDisplay, state: ViPowerState) -> Result;
}
extern "C" {
    pub fn viSetDisplayAlpha(display: *mut ViDisplay, alpha: f32) -> Result;
}
extern "C" {
    pub fn viGetDisplayMinimumZ(display: *mut ViDisplay, z: *mut u64) -> Result;
}
extern "C" {
    pub fn viGetDisplayMaximumZ(display: *mut ViDisplay, z: *mut u64) -> Result;
}
extern "C" {
    pub fn viCreateLayer(display: *const ViDisplay, layer: *mut ViLayer) -> Result;
}
extern "C" {
    pub fn viCreateManagedLayer(
        display: *const ViDisplay,
        layer_flags: ViLayerFlags,
        aruid: u64,
        layer_id: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn viSetLayerSize(layer: *mut ViLayer, width: u64, height: u64) -> Result;
}
extern "C" {
    pub fn viSetLayerZ(layer: *mut ViLayer, z: u64) -> Result;
}
extern "C" {
    pub fn viSetLayerPosition(layer: *mut ViLayer, x: f32, y: f32) -> Result;
}
extern "C" {
    pub fn viCloseLayer(layer: *mut ViLayer) -> Result;
}
extern "C" {
    pub fn viSetLayerScalingMode(layer: *mut ViLayer, scaling_mode: ViScalingMode) -> Result;
}
extern "C" {
    pub fn viGetIndirectLayerImageMap(
        buffer: *mut ctypes::c_void,
        size: usize,
        width: s32,
        height: s32,
        IndirectLayerConsumerHandle: u64,
        out0: *mut u64,
        out1: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn viGetIndirectLayerImageRequiredMemoryInfo(
        width: s32,
        height: s32,
        out_size: *mut u64,
        out_alignment: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn nvInitialize() -> Result;
}
extern "C" {
    pub fn nvExit();
}
pub const NvEventId_NvEventId_Gpu_SmException_BptIntReport: NvEventId = 1;
pub const NvEventId_NvEventId_Gpu_SmException_BptPauseReport: NvEventId = 2;
pub const NvEventId_NvEventId_Gpu_ErrorNotifier: NvEventId = 3;
pub const NvEventId_NvEventId_CtrlGpu_ErrorEventHandle: NvEventId = 1;
pub const NvEventId_NvEventId_CtrlGpu_Unknown: NvEventId = 2;
pub type NvEventId = u32;
extern "C" {
    pub fn nvOpen(fd: *mut u32, devicepath: *const ctypes::c_char) -> Result;
}
extern "C" {
    pub fn nvIoctl(fd: u32, request: u32, argp: *mut ctypes::c_void) -> Result;
}
extern "C" {
    pub fn nvIoctl2(
        fd: u32,
        request: u32,
        argp: *mut ctypes::c_void,
        inbuf: *const ctypes::c_void,
        inbuf_size: usize,
    ) -> Result;
}
extern "C" {
    pub fn nvClose(fd: u32) -> Result;
}
extern "C" {
    pub fn nvQueryEvent(fd: u32, event_id: u32, event_out: *mut Event) -> Result;
}
extern "C" {
    pub fn nvConvertError(rc: ctypes::c_int) -> Result;
}
/// < Initializes nifm:u.
pub const NifmServiceType_NifmServiceType_NotInitialized: NifmServiceType = 0;
/// < Initializes nifm:u.
pub const NifmServiceType_NifmServiceType_User: NifmServiceType = 1;
/// < Initializes nifm:s.
pub const NifmServiceType_NifmServiceType_System: NifmServiceType = 2;
/// < Initializes nifm:a.
pub const NifmServiceType_NifmServiceType_Admin: NifmServiceType = 3;
pub type NifmServiceType = u32;
/// < Wi-Fi connection is used.
pub const NifmInternetConnectionType_NifmInternetConnectionType_WiFi: NifmInternetConnectionType =
    1;
/// < Ethernet connection is used.
pub const NifmInternetConnectionType_NifmInternetConnectionType_Ethernet:
    NifmInternetConnectionType = 2;
pub type NifmInternetConnectionType = u32;
/// < Unknown internet connection status 1.
pub const NifmInternetConnectionStatus_NifmInternetConnectionStatus_ConnectingUnknown1:
    NifmInternetConnectionStatus = 0;
/// < Unknown internet connection status 2.
pub const NifmInternetConnectionStatus_NifmInternetConnectionStatus_ConnectingUnknown2:
    NifmInternetConnectionStatus = 1;
/// < Unknown internet connection status 3 (conntest?).
pub const NifmInternetConnectionStatus_NifmInternetConnectionStatus_ConnectingUnknown3:
    NifmInternetConnectionStatus = 2;
/// < Unknown internet connection status 4.
pub const NifmInternetConnectionStatus_NifmInternetConnectionStatus_ConnectingUnknown4:
    NifmInternetConnectionStatus = 3;
/// < Internet is connected.
pub const NifmInternetConnectionStatus_NifmInternetConnectionStatus_Connected:
    NifmInternetConnectionStatus = 4;
pub type NifmInternetConnectionStatus = u32;
extern "C" {
    /// @brief Sets the \ref NifmServiceType for initialization. Call this function before \ref nifmInitialize.
    /// @note By default nifm:u will be used.
    pub fn nifmSetServiceType(serviceType: NifmServiceType);
}
extern "C" {
    pub fn nifmInitialize() -> Result;
}
extern "C" {
    pub fn nifmExit();
}
extern "C" {
    pub fn nifmGetCurrentIpAddress(out: *mut u32) -> Result;
}
extern "C" {
    pub fn nifmIsWirelessCommunicationEnabled(out: *mut bool) -> Result;
}
extern "C" {
    /// @note Works only if called from nifm:a or nifm:s.
    pub fn nifmSetWirelessCommunicationEnabled(enable: bool) -> Result;
}
extern "C" {
    /// @note Will fail with 0xd46ed if Internet is neither connecting or connected (airplane mode or no known network in reach).
    /// @param wifiStrength Strength of the Wi-Fi signal in number of bars from 0 to 3.
    pub fn nifmGetInternetConnectionStatus(
        connectionType: *mut NifmInternetConnectionType,
        wifiStrength: *mut u32,
        connectionStatus: *mut NifmInternetConnectionStatus,
    ) -> Result;
}
extern "C" {
    pub fn nifmIsEthernetCommunicationEnabled(out: *mut bool) -> Result;
}
extern "C" {
    pub fn nifmIsAnyForegroundRequestAccepted(out: *mut bool) -> Result;
}
extern "C" {
    pub fn nifmPutToSleep() -> Result;
}
extern "C" {
    pub fn nifmWakeUp() -> Result;
}
#[repr(C)]
pub struct NsApplicationControlData {
    pub nacp: NacpStruct,
    pub icon: [u8; 131072usize],
}
#[test]
fn bindgen_test_layout_NsApplicationControlData() {
    assert_eq!(
        ::core::mem::size_of::<NsApplicationControlData>(),
        147456usize,
        concat!("Size of: ", stringify!(NsApplicationControlData))
    );
    assert_eq!(
        ::core::mem::align_of::<NsApplicationControlData>(),
        8usize,
        concat!("Alignment of ", stringify!(NsApplicationControlData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsApplicationControlData>())).nacp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationControlData),
            "::",
            stringify!(nacp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsApplicationControlData>())).icon as *const _ as usize },
        16384usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationControlData),
            "::",
            stringify!(icon)
        )
    );
}
#[repr(C)]
pub struct NsApplicationContentMetaStatus {
    pub title_type: u8,
    pub storageID: u8,
    pub unk_x02: u8,
    pub padding: u8,
    pub title_version: u32,
    pub titleID: u64,
}
#[test]
fn bindgen_test_layout_NsApplicationContentMetaStatus() {
    assert_eq!(
        ::core::mem::size_of::<NsApplicationContentMetaStatus>(),
        16usize,
        concat!("Size of: ", stringify!(NsApplicationContentMetaStatus))
    );
    assert_eq!(
        ::core::mem::align_of::<NsApplicationContentMetaStatus>(),
        8usize,
        concat!("Alignment of ", stringify!(NsApplicationContentMetaStatus))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NsApplicationContentMetaStatus>())).title_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationContentMetaStatus),
            "::",
            stringify!(title_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NsApplicationContentMetaStatus>())).storageID as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationContentMetaStatus),
            "::",
            stringify!(storageID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NsApplicationContentMetaStatus>())).unk_x02 as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationContentMetaStatus),
            "::",
            stringify!(unk_x02)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NsApplicationContentMetaStatus>())).padding as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationContentMetaStatus),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NsApplicationContentMetaStatus>())).title_version as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationContentMetaStatus),
            "::",
            stringify!(title_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NsApplicationContentMetaStatus>())).titleID as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationContentMetaStatus),
            "::",
            stringify!(titleID)
        )
    );
}
#[repr(C)]
pub struct NsApplicationRecord {
    pub titleID: u64,
    pub type_: u8,
    pub unk_x09: u8,
    pub unk_x0A: [u8; 6usize],
    pub unk_x10: u8,
    pub unk_x11: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_NsApplicationRecord() {
    assert_eq!(
        ::core::mem::size_of::<NsApplicationRecord>(),
        24usize,
        concat!("Size of: ", stringify!(NsApplicationRecord))
    );
    assert_eq!(
        ::core::mem::align_of::<NsApplicationRecord>(),
        8usize,
        concat!("Alignment of ", stringify!(NsApplicationRecord))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsApplicationRecord>())).titleID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationRecord),
            "::",
            stringify!(titleID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsApplicationRecord>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationRecord),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsApplicationRecord>())).unk_x09 as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationRecord),
            "::",
            stringify!(unk_x09)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsApplicationRecord>())).unk_x0A as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationRecord),
            "::",
            stringify!(unk_x0A)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsApplicationRecord>())).unk_x10 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationRecord),
            "::",
            stringify!(unk_x10)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsApplicationRecord>())).unk_x11 as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationRecord),
            "::",
            stringify!(unk_x11)
        )
    );
}
#[repr(C)]
pub struct NsLaunchProperties {
    pub titleID: u64,
    pub version: u32,
    pub storageID: u8,
    pub index: u8,
    pub is_application: u8,
}
#[test]
fn bindgen_test_layout_NsLaunchProperties() {
    assert_eq!(
        ::core::mem::size_of::<NsLaunchProperties>(),
        16usize,
        concat!("Size of: ", stringify!(NsLaunchProperties))
    );
    assert_eq!(
        ::core::mem::align_of::<NsLaunchProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(NsLaunchProperties))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsLaunchProperties>())).titleID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NsLaunchProperties),
            "::",
            stringify!(titleID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsLaunchProperties>())).version as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NsLaunchProperties),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsLaunchProperties>())).storageID as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NsLaunchProperties),
            "::",
            stringify!(storageID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsLaunchProperties>())).index as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(NsLaunchProperties),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NsLaunchProperties>())).is_application as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(NsLaunchProperties),
            "::",
            stringify!(is_application)
        )
    );
}
pub const NsShellEvent_NsShellEvent_None: NsShellEvent = 0;
pub const NsShellEvent_NsShellEvent_Exit: NsShellEvent = 1;
pub const NsShellEvent_NsShellEvent_Start: NsShellEvent = 2;
pub const NsShellEvent_NsShellEvent_Crash: NsShellEvent = 3;
pub const NsShellEvent_NsShellEvent_Debug: NsShellEvent = 4;
pub type NsShellEvent = u32;
#[repr(C)]
pub struct NsShellEventInfo {
    pub event: NsShellEvent,
    pub process_id: u64,
}
#[test]
fn bindgen_test_layout_NsShellEventInfo() {
    assert_eq!(
        ::core::mem::size_of::<NsShellEventInfo>(),
        16usize,
        concat!("Size of: ", stringify!(NsShellEventInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<NsShellEventInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(NsShellEventInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsShellEventInfo>())).event as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NsShellEventInfo),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsShellEventInfo>())).process_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NsShellEventInfo),
            "::",
            stringify!(process_id)
        )
    );
}
extern "C" {
    pub fn nsInitialize() -> Result;
}
extern "C" {
    pub fn nsExit();
}
extern "C" {
    pub fn nsListApplicationRecord(
        buffer: *mut NsApplicationRecord,
        size: usize,
        entry_offset: usize,
        out_entrycount: *mut usize,
    ) -> Result;
}
extern "C" {
    pub fn nsListApplicationContentMetaStatus(
        titleID: u64,
        index: u32,
        buffer: *mut NsApplicationContentMetaStatus,
        size: usize,
        out_entrycount: *mut usize,
    ) -> Result;
}
extern "C" {
    pub fn nsGetApplicationControlData(
        flag: u8,
        titleID: u64,
        buffer: *mut NsApplicationControlData,
        size: usize,
        actual_size: *mut usize,
    ) -> Result;
}
extern "C" {
    /// @brief Returns the total storage capacity (used + free) from content manager services.
    /// @param storage_id Specified FsStorageId. (Must be FsStorageId_SdCard)
    /// @param size Pointer to output the total storage size to.
    pub fn nsGetTotalSpaceSize(storage_id: FsStorageId, size: *mut u64) -> Result;
}
extern "C" {
    /// @brief Returns the available storage capacity from content manager services.
    /// @param storage_id Specified FsStorageId. (Must be FsStorageId_SdCard)
    /// @param size Pointer to output the free storage size to.
    pub fn nsGetFreeSpaceSize(storage_id: FsStorageId, size: *mut u64) -> Result;
}
extern "C" {
    pub fn nsvmInitialize() -> Result;
}
extern "C" {
    pub fn nsvmExit();
}
extern "C" {
    pub fn nsvmNeedsUpdateVulnerability(out: *mut bool) -> Result;
}
extern "C" {
    pub fn nsvmGetSafeSystemVersion(out: *mut u16) -> Result;
}
extern "C" {
    pub fn nsdevInitialize() -> Result;
}
extern "C" {
    pub fn nsdevExit();
}
extern "C" {
    pub fn nsdevLaunchProgram(
        out_pid: *mut u64,
        properties: *const NsLaunchProperties,
        flags: u32,
    ) -> Result;
}
extern "C" {
    pub fn nsdevTerminateProcess(pid: u64) -> Result;
}
extern "C" {
    pub fn nsdevTerminateProgram(tid: u64) -> Result;
}
extern "C" {
    pub fn nsdevGetShellEvent(out: *mut Event) -> Result;
}
extern "C" {
    pub fn nsdevGetShellEventInfo(out: *mut NsShellEventInfo) -> Result;
}
extern "C" {
    pub fn nsdevTerminateApplication() -> Result;
}
extern "C" {
    pub fn nsdevPrepareLaunchProgramFromHost(
        out: *mut NsLaunchProperties,
        path: *const ctypes::c_char,
        path_len: usize,
    ) -> Result;
}
extern "C" {
    pub fn nsdevLaunchApplication(out_pid: *mut u64, app_title_id: u64, flags: u32) -> Result;
}
extern "C" {
    pub fn nsdevLaunchApplicationWithStorageId(
        out_pid: *mut u64,
        app_title_id: u64,
        flags: u32,
        app_storage_id: u8,
        patch_storage_id: u8,
    ) -> Result;
}
extern "C" {
    pub fn nsdevIsSystemMemoryResourceLimitBoosted(out: *mut bool) -> Result;
}
extern "C" {
    pub fn nsdevGetRunningApplicationProcessId(out_pid: *mut u64) -> Result;
}
extern "C" {
    pub fn nsdevSetCurrentApplicationRightsEnvironmentCanBeActive(can_be_active: bool) -> Result;
}
#[repr(C)]
pub struct LoaderProgramInfo {
    pub main_thread_priority: u8,
    pub default_cpu_id: u8,
    pub application_type: u16,
    pub main_thread_stack_size: u32,
    pub title_id: u64,
    pub acid_sac_size: u32,
    pub aci0_sac_size: u32,
    pub acid_fac_size: u32,
    pub aci0_fah_size: u32,
    pub ac_buffer: [u8; 992usize],
}
#[test]
fn bindgen_test_layout_LoaderProgramInfo() {
    assert_eq!(
        ::core::mem::size_of::<LoaderProgramInfo>(),
        1024usize,
        concat!("Size of: ", stringify!(LoaderProgramInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<LoaderProgramInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(LoaderProgramInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LoaderProgramInfo>())).main_thread_priority as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderProgramInfo),
            "::",
            stringify!(main_thread_priority)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LoaderProgramInfo>())).default_cpu_id as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderProgramInfo),
            "::",
            stringify!(default_cpu_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LoaderProgramInfo>())).application_type as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderProgramInfo),
            "::",
            stringify!(application_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LoaderProgramInfo>())).main_thread_stack_size as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderProgramInfo),
            "::",
            stringify!(main_thread_stack_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LoaderProgramInfo>())).title_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderProgramInfo),
            "::",
            stringify!(title_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LoaderProgramInfo>())).acid_sac_size as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderProgramInfo),
            "::",
            stringify!(acid_sac_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LoaderProgramInfo>())).aci0_sac_size as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderProgramInfo),
            "::",
            stringify!(aci0_sac_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LoaderProgramInfo>())).acid_fac_size as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderProgramInfo),
            "::",
            stringify!(acid_fac_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LoaderProgramInfo>())).aci0_fah_size as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderProgramInfo),
            "::",
            stringify!(aci0_fah_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LoaderProgramInfo>())).ac_buffer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderProgramInfo),
            "::",
            stringify!(ac_buffer)
        )
    );
}
#[repr(C)]
pub struct LoaderModuleInfo {
    pub base_address: u64,
    pub size: u64,
    pub build_id: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_LoaderModuleInfo() {
    assert_eq!(
        ::core::mem::size_of::<LoaderModuleInfo>(),
        48usize,
        concat!("Size of: ", stringify!(LoaderModuleInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<LoaderModuleInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(LoaderModuleInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LoaderModuleInfo>())).base_address as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderModuleInfo),
            "::",
            stringify!(base_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LoaderModuleInfo>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderModuleInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LoaderModuleInfo>())).build_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderModuleInfo),
            "::",
            stringify!(build_id)
        )
    );
}
extern "C" {
    pub fn ldrShellInitialize() -> Result;
}
extern "C" {
    pub fn ldrShellExit();
}
extern "C" {
    pub fn ldrDmntInitialize() -> Result;
}
extern "C" {
    pub fn ldrDmntExit();
}
extern "C" {
    pub fn ldrPmInitialize() -> Result;
}
extern "C" {
    pub fn ldrPmExit();
}
extern "C" {
    pub fn ldrShellAddTitleToLaunchQueue(
        tid: u64,
        args: *const ctypes::c_void,
        args_size: usize,
    ) -> Result;
}
extern "C" {
    pub fn ldrShellClearLaunchQueue() -> Result;
}
extern "C" {
    pub fn ldrDmntAddTitleToLaunchQueue(
        tid: u64,
        args: *const ctypes::c_void,
        args_size: usize,
    ) -> Result;
}
extern "C" {
    pub fn ldrDmntClearLaunchQueue() -> Result;
}
extern "C" {
    pub fn ldrDmntGetModuleInfos(
        pid: u64,
        out_module_infos: *mut LoaderModuleInfo,
        out_size: usize,
        num_out: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn ldrPmCreateProcess(
        flags: u64,
        launch_index: u64,
        reslimit_h: Handle,
        out_process_h: *mut Handle,
    ) -> Result;
}
extern "C" {
    pub fn ldrPmGetProgramInfo(
        title_id: u64,
        storage_id: FsStorageId,
        out_program_info: *mut LoaderProgramInfo,
    ) -> Result;
}
extern "C" {
    pub fn ldrPmRegisterTitle(
        title_id: u64,
        storage_id: FsStorageId,
        out_index: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn ldrPmUnregisterTitle(launch_index: u64) -> Result;
}
extern "C" {
    pub fn ldrRoInitialize() -> Result;
}
extern "C" {
    pub fn ldrRoExit();
}
extern "C" {
    pub fn roDmntInitialize() -> Result;
}
extern "C" {
    pub fn roDmntExit();
}
extern "C" {
    pub fn ldrRoLoadNro(
        out_address: *mut u64,
        nro_address: u64,
        nro_size: u64,
        bss_address: u64,
        bss_size: u64,
    ) -> Result;
}
extern "C" {
    pub fn ldrRoUnloadNro(nro_address: u64) -> Result;
}
extern "C" {
    pub fn ldrRoLoadNrr(nrr_address: u64, nrr_size: u64) -> Result;
}
extern "C" {
    pub fn ldrRoUnloadNrr(nrr_address: u64) -> Result;
}
extern "C" {
    pub fn roDmntGetModuleInfos(
        pid: u64,
        out_module_infos: *mut LoaderModuleInfo,
        out_size: usize,
        num_out: *mut u32,
    ) -> Result;
}
pub const PmLaunchFlag_PmLaunchFlag_None: PmLaunchFlag = 0;
pub const PmLaunchFlag_PmLaunchFlag_SignalOnExit: PmLaunchFlag = 1;
pub const PmLaunchFlag_PmLaunchFlag_SignalOnStart: PmLaunchFlag = 2;
pub const PmLaunchFlag_PmLaunchFlag_SignalOnCrash: PmLaunchFlag = 4;
pub const PmLaunchFlag_PmLaunchFlag_SignalOnDebug: PmLaunchFlag = 8;
pub const PmLaunchFlag_PmLaunchFlag_StartSuspended: PmLaunchFlag = 16;
pub const PmLaunchFlag_PmLaunchFlag_DisableAslr: PmLaunchFlag = 32;
pub const PmLaunchFlag_PmLaunchFlagOld_SignalOnExit: PmLaunchFlag = 1;
pub const PmLaunchFlag_PmLaunchFlagOld_StartSuspended: PmLaunchFlag = 2;
pub const PmLaunchFlag_PmLaunchFlagOld_SignalOnCrash: PmLaunchFlag = 4;
pub const PmLaunchFlag_PmLaunchFlagOld_DisableAslr: PmLaunchFlag = 8;
pub const PmLaunchFlag_PmLaunchFlagOld_SignalOnDebug: PmLaunchFlag = 16;
pub const PmLaunchFlag_PmLaunchFlagOld_SignalOnStart: PmLaunchFlag = 32;
pub type PmLaunchFlag = u32;
pub const PmProcessEvent_PmProcessEvent_None: PmProcessEvent = 0;
pub const PmProcessEvent_PmProcessEvent_Exit: PmProcessEvent = 1;
pub const PmProcessEvent_PmProcessEvent_Start: PmProcessEvent = 2;
pub const PmProcessEvent_PmProcessEvent_Crash: PmProcessEvent = 3;
pub const PmProcessEvent_PmProcessEvent_DebugStart: PmProcessEvent = 4;
pub const PmProcessEvent_PmProcessEvent_DebugBreak: PmProcessEvent = 5;
pub type PmProcessEvent = u32;
#[repr(C)]
pub struct PmProcessEventInfo {
    pub event: PmProcessEvent,
    pub process_id: u64,
}
#[test]
fn bindgen_test_layout_PmProcessEventInfo() {
    assert_eq!(
        ::core::mem::size_of::<PmProcessEventInfo>(),
        16usize,
        concat!("Size of: ", stringify!(PmProcessEventInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<PmProcessEventInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(PmProcessEventInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PmProcessEventInfo>())).event as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PmProcessEventInfo),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PmProcessEventInfo>())).process_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PmProcessEventInfo),
            "::",
            stringify!(process_id)
        )
    );
}
extern "C" {
    pub fn pmdmntInitialize() -> Result;
}
extern "C" {
    pub fn pmdmntExit();
}
extern "C" {
    pub fn pmdmntGetServiceSession() -> *mut Service;
}
extern "C" {
    pub fn pminfoInitialize() -> Result;
}
extern "C" {
    pub fn pminfoExit();
}
extern "C" {
    pub fn pmshellInitialize() -> Result;
}
extern "C" {
    pub fn pmshellExit();
}
extern "C" {
    pub fn pmdmntGetDebugProcesses(
        out_count: *mut u32,
        out_pids: *mut u64,
        max_pids: usize,
    ) -> Result;
}
extern "C" {
    pub fn pmdmntStartProcess(pid: u64) -> Result;
}
extern "C" {
    pub fn pmdmntGetTitlePid(pid_out: *mut u64, title_id: u64) -> Result;
}
extern "C" {
    pub fn pmdmntEnableDebugForTitleId(handle_out: *mut Handle, title_id: u64) -> Result;
}
extern "C" {
    pub fn pmdmntGetApplicationPid(pid_out: *mut u64) -> Result;
}
extern "C" {
    pub fn pmdmntEnableDebugForApplication(handle_out: *mut Handle) -> Result;
}
extern "C" {
    pub fn pmdmntDisableDebug() -> Result;
}
extern "C" {
    pub fn pminfoGetTitleId(title_id_out: *mut u64, pid: u64) -> Result;
}
extern "C" {
    pub fn pmshellLaunchProcess(
        launch_flags: u32,
        titleID: u64,
        storageID: u64,
        pid: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn pmshellTerminateProcessByProcessId(processID: u64) -> Result;
}
extern "C" {
    pub fn pmshellTerminateProcessByTitleId(titleID: u64) -> Result;
}
extern "C" {
    pub fn pmshellGetProcessEvent(out: *mut Event) -> Result;
}
extern "C" {
    pub fn pmshellGetProcessEventInfo(out: *mut PmProcessEventInfo) -> Result;
}
extern "C" {
    pub fn pmshellFinalizeDeadProcess(pid: u64) -> Result;
}
extern "C" {
    pub fn pmshellClearProcessExceptionOccurred(pid: u64) -> Result;
}
extern "C" {
    pub fn pmshellNotifyBootFinished() -> Result;
}
extern "C" {
    pub fn pmshellGetApplicationPid(pid_out: *mut u64) -> Result;
}
extern "C" {
    pub fn pmshellBoostSystemMemoryResourceLimit(boost_size: u64) -> Result;
}
pub const ColorSetId_ColorSetId_Light: ColorSetId = 0;
pub const ColorSetId_ColorSetId_Dark: ColorSetId = 1;
pub type ColorSetId = u32;
/// < Japanese
pub const SetLanguage_SetLanguage_JA: SetLanguage = 0;
/// < US English ("AmericanEnglish")
pub const SetLanguage_SetLanguage_ENUS: SetLanguage = 1;
/// < French
pub const SetLanguage_SetLanguage_FR: SetLanguage = 2;
/// < German
pub const SetLanguage_SetLanguage_DE: SetLanguage = 3;
/// < Italian
pub const SetLanguage_SetLanguage_IT: SetLanguage = 4;
/// < Spanish
pub const SetLanguage_SetLanguage_ES: SetLanguage = 5;
/// < Simplified Chinese ("Chinese")
pub const SetLanguage_SetLanguage_ZHCN: SetLanguage = 6;
/// < Korean
pub const SetLanguage_SetLanguage_KO: SetLanguage = 7;
/// < Dutch
pub const SetLanguage_SetLanguage_NL: SetLanguage = 8;
/// < Portuguese
pub const SetLanguage_SetLanguage_PT: SetLanguage = 9;
/// < Russian
pub const SetLanguage_SetLanguage_RU: SetLanguage = 10;
/// < Traditional Chinese ("Taiwanese")
pub const SetLanguage_SetLanguage_ZHTW: SetLanguage = 11;
/// < GB English ("BritishEnglish")
pub const SetLanguage_SetLanguage_ENGB: SetLanguage = 12;
/// < CA French ("CanadianFrench")
pub const SetLanguage_SetLanguage_FRCA: SetLanguage = 13;
/// < "LatinAmericanSpanish"
pub const SetLanguage_SetLanguage_ES419: SetLanguage = 14;
/// < Total languages supported by this enum.
pub const SetLanguage_SetLanguage_Total: SetLanguage = 15;
/// IDs for Language.
pub type SetLanguage = u32;
/// < Japan
pub const SetRegion_SetRegion_JPN: SetRegion = 0;
/// < The Americas
pub const SetRegion_SetRegion_USA: SetRegion = 1;
/// < Europe
pub const SetRegion_SetRegion_EUR: SetRegion = 2;
/// < Australia/New Zealand
pub const SetRegion_SetRegion_AUS: SetRegion = 3;
/// Region codes.
pub type SetRegion = u32;
pub const SetSysFlag_SetSysFlag_LockScreen: SetSysFlag = 7;
pub const SetSysFlag_SetSysFlag_ConsoleInformationUpload: SetSysFlag = 25;
pub const SetSysFlag_SetSysFlag_AutomaticApplicationDownload: SetSysFlag = 27;
pub const SetSysFlag_SetSysFlag_Quest: SetSysFlag = 47;
pub const SetSysFlag_SetSysFlag_Usb30Enable: SetSysFlag = 65;
pub const SetSysFlag_SetSysFlag_NfcEnable: SetSysFlag = 69;
pub const SetSysFlag_SetSysFlag_WirelessLanEnable: SetSysFlag = 73;
pub const SetSysFlag_SetSysFlag_BluetoothEnable: SetSysFlag = 88;
pub const SetSysFlag_SetSysFlag_AutoUpdateEnable: SetSysFlag = 95;
pub const SetSysFlag_SetSysFlag_BatteryPercentage: SetSysFlag = 99;
pub const SetSysFlag_SetSysFlag_ExternalRtcReset: SetSysFlag = 101;
pub const SetSysFlag_SetSysFlag_UsbFullKeyEnable: SetSysFlag = 103;
pub const SetSysFlag_SetSysFlag_BluetoothAfhEnable: SetSysFlag = 111;
pub const SetSysFlag_SetSysFlag_BluetoothBoostEnable: SetSysFlag = 113;
pub const SetSysFlag_SetSysFlag_InRepairProcessEnable: SetSysFlag = 115;
pub const SetSysFlag_SetSysFlag_HeadphoneVolumeUpdate: SetSysFlag = 117;
pub const SetSysFlag_SetSysFlag_RequiresRunRepairTimeReviser: SetSysFlag = 141;
/// Command IDs for setsysGetFlag/setsysSetFlag.
pub type SetSysFlag = u32;
/// Structure returned by \ref setsysGetFirmwareVersion
#[repr(C)]
pub struct SetSysFirmwareVersion {
    pub major: u8,
    pub minor: u8,
    pub micro: u8,
    pub padding1: u8,
    pub revision_major: u8,
    pub revision_minor: u8,
    pub padding2: u8,
    pub padding3: u8,
    pub platform: [ctypes::c_char; 32usize],
    pub version_hash: [ctypes::c_char; 64usize],
    pub display_version: [ctypes::c_char; 24usize],
    pub display_title: [ctypes::c_char; 128usize],
}
#[test]
fn bindgen_test_layout_SetSysFirmwareVersion() {
    assert_eq!(
        ::core::mem::size_of::<SetSysFirmwareVersion>(),
        256usize,
        concat!("Size of: ", stringify!(SetSysFirmwareVersion))
    );
    assert_eq!(
        ::core::mem::align_of::<SetSysFirmwareVersion>(),
        1usize,
        concat!("Alignment of ", stringify!(SetSysFirmwareVersion))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SetSysFirmwareVersion>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SetSysFirmwareVersion),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SetSysFirmwareVersion>())).minor as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SetSysFirmwareVersion),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SetSysFirmwareVersion>())).micro as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SetSysFirmwareVersion),
            "::",
            stringify!(micro)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SetSysFirmwareVersion>())).padding1 as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(SetSysFirmwareVersion),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SetSysFirmwareVersion>())).revision_major as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SetSysFirmwareVersion),
            "::",
            stringify!(revision_major)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SetSysFirmwareVersion>())).revision_minor as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(SetSysFirmwareVersion),
            "::",
            stringify!(revision_minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SetSysFirmwareVersion>())).padding2 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SetSysFirmwareVersion),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SetSysFirmwareVersion>())).padding3 as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(SetSysFirmwareVersion),
            "::",
            stringify!(padding3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SetSysFirmwareVersion>())).platform as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SetSysFirmwareVersion),
            "::",
            stringify!(platform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SetSysFirmwareVersion>())).version_hash as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SetSysFirmwareVersion),
            "::",
            stringify!(version_hash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SetSysFirmwareVersion>())).display_version as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(SetSysFirmwareVersion),
            "::",
            stringify!(display_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SetSysFirmwareVersion>())).display_title as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(SetSysFirmwareVersion),
            "::",
            stringify!(display_title)
        )
    );
}
extern "C" {
    pub fn setInitialize() -> Result;
}
extern "C" {
    pub fn setExit();
}
extern "C" {
    /// Converts LanguageCode to Language.
    pub fn setMakeLanguage(LanguageCode: u64, Language: *mut s32) -> Result;
}
extern "C" {
    /// Converts Language to LanguageCode.
    pub fn setMakeLanguageCode(Language: s32, LanguageCode: *mut u64) -> Result;
}
extern "C" {
    /// Gets the current system LanguageCode.
    /// Normally this should be used instead of \ref setGetLanguageCode.
    /// LanguageCode is a string, see here: https://switchbrew.org/wiki/Settings_services#LanguageCode
    pub fn setGetSystemLanguage(LanguageCode: *mut u64) -> Result;
}
extern "C" {
    /// Gets the current LanguageCode, \ref setGetSystemLanguage should be used instead normally.
    pub fn setGetLanguageCode(LanguageCode: *mut u64) -> Result;
}
extern "C" {
    /// Gets available LanguageCodes.
    /// On system-version <4.0.0, max_entries is set to the output from \ref setGetAvailableLanguageCodeCount if max_entries is larger than that.
    pub fn setGetAvailableLanguageCodes(
        total_entries: *mut s32,
        LanguageCodes: *mut u64,
        max_entries: usize,
    ) -> Result;
}
extern "C" {
    /// Gets total available LanguageCodes.
    /// Output total is overridden with value 0 if the total is <0.
    pub fn setGetAvailableLanguageCodeCount(total: *mut s32) -> Result;
}
extern "C" {
    /// Gets the RegionCode.
    pub fn setGetRegionCode(out: *mut SetRegion) -> Result;
}
extern "C" {
    pub fn setsysInitialize() -> Result;
}
extern "C" {
    pub fn setsysExit();
}
extern "C" {
    /// Gets the current system theme.
    pub fn setsysGetColorSetId(out: *mut ColorSetId) -> Result;
}
extern "C" {
    /// Sets the current system theme.
    pub fn setsysSetColorSetId(id: ColorSetId) -> Result;
}
extern "C" {
    /// @brief Gets the size of a settings item value.
    /// @param name Name string.
    /// @param item_key Item key string.
    /// @param size_out Pointer to output the size to.
    pub fn setsysGetSettingsItemValueSize(
        name: *const ctypes::c_char,
        item_key: *const ctypes::c_char,
        size_out: *mut u64,
    ) -> Result;
}
extern "C" {
    /// @brief Gets the value of a settings item.
    /// @param name Name string.
    /// @param item_key Item key string.
    /// @param value_out Pointer to output the value to.
    /// @param value_out_size Size of the value_out buffer.
    pub fn setsysGetSettingsItemValue(
        name: *const ctypes::c_char,
        item_key: *const ctypes::c_char,
        value_out: *mut ctypes::c_void,
        value_out_size: usize,
    ) -> Result;
}
extern "C" {
    /// @brief Gets the system's serial number.
    /// @param serial Pointer to output the serial to. (The buffer size needs to be at least 0x19 bytes)
    pub fn setsysGetSerialNumber(serial: *mut ctypes::c_char) -> Result;
}
extern "C" {
    /// @brief Gets the status of the specified settings flag.
    /// @param flag The specified settings flag.
    /// @param out Output pointer for the status.
    pub fn setsysGetFlag(flag: SetSysFlag, out: *mut bool) -> Result;
}
extern "C" {
    /// @brief Enables/disables the specified settings flag.
    /// @param flag The specified settings flag.
    /// @param enable To enable/disable the flag.
    pub fn setsysSetFlag(flag: SetSysFlag, enable: bool) -> Result;
}
extern "C" {
    /// @brief Gets the system firmware version.
    /// @param out Firmware version to populate.
    pub fn setsysGetFirmwareVersion(out: *mut SetSysFirmwareVersion) -> Result;
}
extern "C" {
    /// @brief Gets an event that settings will signal on flag change.
    /// @param out Event to bind. Output event will have autoclear=false.
    pub fn setsysBindFatalDirtyFlagEvent(out: *mut Event) -> Result;
}
extern "C" {
    /// @brief Gets the settings flags that have changed.
    /// @param flags_0 Pointer to populate with first 64 flags.
    /// @param flags_1 Pointer to populate with second 64 flags.
    pub fn setsysGetFatalDirtyFlags(flags_0: *mut u64, flags_1: *mut u64) -> Result;
}
#[repr(C)]
pub struct LrLocationResolver {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_LrLocationResolver() {
    assert_eq!(
        ::core::mem::size_of::<LrLocationResolver>(),
        12usize,
        concat!("Size of: ", stringify!(LrLocationResolver))
    );
    assert_eq!(
        ::core::mem::align_of::<LrLocationResolver>(),
        4usize,
        concat!("Alignment of ", stringify!(LrLocationResolver))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LrLocationResolver>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LrLocationResolver),
            "::",
            stringify!(s)
        )
    );
}
#[repr(C)]
pub struct LrRegisteredLocationResolver {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_LrRegisteredLocationResolver() {
    assert_eq!(
        ::core::mem::size_of::<LrRegisteredLocationResolver>(),
        12usize,
        concat!("Size of: ", stringify!(LrRegisteredLocationResolver))
    );
    assert_eq!(
        ::core::mem::align_of::<LrRegisteredLocationResolver>(),
        4usize,
        concat!("Alignment of ", stringify!(LrRegisteredLocationResolver))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LrRegisteredLocationResolver>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LrRegisteredLocationResolver),
            "::",
            stringify!(s)
        )
    );
}
extern "C" {
    pub fn lrInitialize() -> Result;
}
extern "C" {
    pub fn lrExit();
}
extern "C" {
    pub fn lrOpenLocationResolver(storage: FsStorageId, out: *mut LrLocationResolver) -> Result;
}
extern "C" {
    pub fn lrOpenRegisteredLocationResolver(out: *mut LrRegisteredLocationResolver) -> Result;
}
extern "C" {
    pub fn lrLrResolveProgramPath(
        lr: *mut LrLocationResolver,
        tid: u64,
        out: *mut ctypes::c_char,
    ) -> Result;
}
extern "C" {
    pub fn lrLrRedirectProgramPath(
        lr: *mut LrLocationResolver,
        tid: u64,
        path: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    pub fn lrLrResolveApplicationControlPath(
        lr: *mut LrLocationResolver,
        tid: u64,
        out: *mut ctypes::c_char,
    ) -> Result;
}
extern "C" {
    pub fn lrLrResolveApplicationHtmlDocumentPath(
        lr: *mut LrLocationResolver,
        tid: u64,
        out: *mut ctypes::c_char,
    ) -> Result;
}
extern "C" {
    pub fn lrLrResolveDataPath(
        lr: *mut LrLocationResolver,
        tid: u64,
        out: *mut ctypes::c_char,
    ) -> Result;
}
extern "C" {
    pub fn lrLrRedirectApplicationControlPath(
        lr: *mut LrLocationResolver,
        tid: u64,
        path: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    pub fn lrLrRedirectApplicationHtmlDocumentPath(
        lr: *mut LrLocationResolver,
        tid: u64,
        path: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    pub fn lrLrResolveLegalInformationPath(
        lr: *mut LrLocationResolver,
        tid: u64,
        out: *mut ctypes::c_char,
    ) -> Result;
}
extern "C" {
    pub fn lrLrRedirectLegalInformationPath(
        lr: *mut LrLocationResolver,
        tid: u64,
        path: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    pub fn lrLrRefresh(lr: *mut LrLocationResolver) -> Result;
}
extern "C" {
    pub fn lrRegLrResolveProgramPath(
        reg: *mut LrRegisteredLocationResolver,
        tid: u64,
        out: *mut ctypes::c_char,
    ) -> Result;
}
pub const SplConfigItem_SplConfigItem_DisableProgramVerification: SplConfigItem = 1;
pub const SplConfigItem_SplConfigItem_DramId: SplConfigItem = 2;
pub const SplConfigItem_SplConfigItem_SecurityEngineIrqNumber: SplConfigItem = 3;
pub const SplConfigItem_SplConfigItem_Version: SplConfigItem = 4;
pub const SplConfigItem_SplConfigItem_HardwareType: SplConfigItem = 5;
pub const SplConfigItem_SplConfigItem_IsRetail: SplConfigItem = 6;
pub const SplConfigItem_SplConfigItem_IsRecoveryBoot: SplConfigItem = 7;
pub const SplConfigItem_SplConfigItem_DeviceId: SplConfigItem = 8;
pub const SplConfigItem_SplConfigItem_BootReason: SplConfigItem = 9;
pub const SplConfigItem_SplConfigItem_MemoryArrange: SplConfigItem = 10;
pub const SplConfigItem_SplConfigItem_IsDebugMode: SplConfigItem = 11;
pub const SplConfigItem_SplConfigItem_KernelMemoryConfiguration: SplConfigItem = 12;
pub const SplConfigItem_SplConfigItem_IsChargerHiZModeEnabled: SplConfigItem = 13;
pub const SplConfigItem_SplConfigItem_IsKiosk: SplConfigItem = 14;
pub const SplConfigItem_SplConfigItem_NewHardwareType: SplConfigItem = 15;
pub const SplConfigItem_SplConfigItem_NewKeyGeneration: SplConfigItem = 16;
pub const SplConfigItem_SplConfigItem_Package2Hash: SplConfigItem = 17;
pub type SplConfigItem = u32;
pub const RsaKeyVersion_RsaKeyVersion_Deprecated: RsaKeyVersion = 0;
pub const RsaKeyVersion_RsaKeyVersion_Extended: RsaKeyVersion = 1;
pub type RsaKeyVersion = u32;
extern "C" {
    pub fn splInitialize() -> Result;
}
extern "C" {
    pub fn splExit();
}
extern "C" {
    pub fn splCryptoInitialize() -> Result;
}
extern "C" {
    pub fn splCryptoExit();
}
extern "C" {
    pub fn splSslInitialize() -> Result;
}
extern "C" {
    pub fn splSslExit();
}
extern "C" {
    pub fn splEsInitialize() -> Result;
}
extern "C" {
    pub fn splEsExit();
}
extern "C" {
    pub fn splFsInitialize() -> Result;
}
extern "C" {
    pub fn splFsExit();
}
extern "C" {
    pub fn splManuInitialize() -> Result;
}
extern "C" {
    pub fn splManuExit();
}
extern "C" {
    pub fn splGetConfig(config_item: SplConfigItem, out_config: *mut u64) -> Result;
}
extern "C" {
    pub fn splUserExpMod(
        input: *const ctypes::c_void,
        modulus: *const ctypes::c_void,
        exp: *const ctypes::c_void,
        exp_size: usize,
        dst: *mut ctypes::c_void,
    ) -> Result;
}
extern "C" {
    pub fn splSetConfig(config_item: SplConfigItem, value: u64) -> Result;
}
extern "C" {
    pub fn splGetRandomBytes(out: *mut ctypes::c_void, out_size: usize) -> Result;
}
extern "C" {
    pub fn splIsDevelopment(out_is_development: *mut bool) -> Result;
}
extern "C" {
    pub fn splSetSharedData(value: u32) -> Result;
}
extern "C" {
    pub fn splGetSharedData(out_value: *mut u32) -> Result;
}
extern "C" {
    pub fn splCryptoGenerateAesKek(
        wrapped_kek: *const ctypes::c_void,
        key_generation: u32,
        option: u32,
        out_sealed_kek: *mut ctypes::c_void,
    ) -> Result;
}
extern "C" {
    pub fn splCryptoLoadAesKey(
        sealed_kek: *const ctypes::c_void,
        wrapped_key: *const ctypes::c_void,
        keyslot: u32,
    ) -> Result;
}
extern "C" {
    pub fn splCryptoGenerateAesKey(
        sealed_kek: *const ctypes::c_void,
        wrapped_key: *const ctypes::c_void,
        out_sealed_key: *mut ctypes::c_void,
    ) -> Result;
}
extern "C" {
    pub fn splCryptoDecryptAesKey(
        wrapped_key: *const ctypes::c_void,
        key_generation: u32,
        option: u32,
        out_sealed_key: *mut ctypes::c_void,
    ) -> Result;
}
extern "C" {
    pub fn splCryptoCryptAesCtr(
        input: *const ctypes::c_void,
        output: *mut ctypes::c_void,
        size: usize,
        ctr: *const ctypes::c_void,
    ) -> Result;
}
extern "C" {
    pub fn splCryptoComputeCmac(
        input: *const ctypes::c_void,
        size: usize,
        keyslot: u32,
        out_cmac: *mut ctypes::c_void,
    ) -> Result;
}
extern "C" {
    pub fn splCryptoLockAesEngine(out_keyslot: *mut u32) -> Result;
}
extern "C" {
    pub fn splCryptoUnlockAesEngine(keyslot: u32) -> Result;
}
extern "C" {
    pub fn splCryptoGetSecurityEngineEvent(out_event: *mut Handle) -> Result;
}
extern "C" {
    pub fn splRsaDecryptPrivateKey(
        sealed_kek: *const ctypes::c_void,
        wrapped_key: *const ctypes::c_void,
        wrapped_rsa_key: *const ctypes::c_void,
        wrapped_rsa_key_size: usize,
        version: RsaKeyVersion,
        dst: *mut ctypes::c_void,
        dst_size: usize,
    ) -> Result;
}
extern "C" {
    pub fn splSslLoadSecureExpModKey(
        sealed_kek: *const ctypes::c_void,
        wrapped_key: *const ctypes::c_void,
        wrapped_rsa_key: *const ctypes::c_void,
        wrapped_rsa_key_size: usize,
        version: RsaKeyVersion,
    ) -> Result;
}
extern "C" {
    pub fn splSslSecureExpMod(
        input: *const ctypes::c_void,
        modulus: *const ctypes::c_void,
        dst: *mut ctypes::c_void,
    ) -> Result;
}
extern "C" {
    pub fn splEsLoadRsaOaepKey(
        sealed_kek: *const ctypes::c_void,
        wrapped_key: *const ctypes::c_void,
        wrapped_rsa_key: *const ctypes::c_void,
        wrapped_rsa_key_size: usize,
        version: RsaKeyVersion,
    ) -> Result;
}
extern "C" {
    pub fn splEsUnwrapRsaOaepWrappedTitlekey(
        rsa_wrapped_titlekey: *const ctypes::c_void,
        modulus: *const ctypes::c_void,
        label_hash: *const ctypes::c_void,
        label_hash_size: usize,
        key_generation: u32,
        out_sealed_titlekey: *mut ctypes::c_void,
    ) -> Result;
}
extern "C" {
    pub fn splEsUnwrapAesWrappedTitlekey(
        aes_wrapped_titlekey: *const ctypes::c_void,
        key_generation: u32,
        out_sealed_titlekey: *mut ctypes::c_void,
    ) -> Result;
}
extern "C" {
    pub fn splEsLoadSecureExpModKey(
        sealed_kek: *const ctypes::c_void,
        wrapped_key: *const ctypes::c_void,
        wrapped_rsa_key: *const ctypes::c_void,
        wrapped_rsa_key_size: usize,
        version: RsaKeyVersion,
    ) -> Result;
}
extern "C" {
    pub fn splEsSecureExpMod(
        input: *const ctypes::c_void,
        modulus: *const ctypes::c_void,
        dst: *mut ctypes::c_void,
    ) -> Result;
}
extern "C" {
    pub fn splFsLoadSecureExpModKey(
        sealed_kek: *const ctypes::c_void,
        wrapped_key: *const ctypes::c_void,
        wrapped_rsa_key: *const ctypes::c_void,
        wrapped_rsa_key_size: usize,
        version: RsaKeyVersion,
    ) -> Result;
}
extern "C" {
    pub fn splFsSecureExpMod(
        input: *const ctypes::c_void,
        modulus: *const ctypes::c_void,
        dst: *mut ctypes::c_void,
    ) -> Result;
}
extern "C" {
    pub fn splFsGenerateSpecificAesKey(
        wrapped_key: *const ctypes::c_void,
        key_generation: u32,
        option: u32,
        out_sealed_key: *mut ctypes::c_void,
    ) -> Result;
}
extern "C" {
    pub fn splFsLoadTitlekey(sealed_titlekey: *const ctypes::c_void, keyslot: u32) -> Result;
}
extern "C" {
    pub fn splFsGetPackage2Hash(out_hash: *mut ctypes::c_void) -> Result;
}
extern "C" {
    pub fn splManuEncryptRsaKeyForImport(
        sealed_kek_pre: *const ctypes::c_void,
        wrapped_key_pre: *const ctypes::c_void,
        sealed_kek_post: *const ctypes::c_void,
        wrapped_kek_post: *const ctypes::c_void,
        option: u32,
        wrapped_rsa_key: *const ctypes::c_void,
        out_wrapped_rsa_key: *mut ctypes::c_void,
        rsa_key_size: usize,
    ) -> Result;
}
pub const NcmContentType_NcmContentType_CNMT: NcmContentType = 0;
pub const NcmContentType_NcmContentType_Program: NcmContentType = 1;
pub const NcmContentType_NcmContentType_Data: NcmContentType = 2;
pub const NcmContentType_NcmContentType_Icon: NcmContentType = 3;
pub const NcmContentType_NcmContentType_Doc: NcmContentType = 4;
pub const NcmContentType_NcmContentType_Info: NcmContentType = 5;
pub type NcmContentType = u32;
#[repr(C)]
pub struct NcmContentStorage {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_NcmContentStorage() {
    assert_eq!(
        ::core::mem::size_of::<NcmContentStorage>(),
        12usize,
        concat!("Size of: ", stringify!(NcmContentStorage))
    );
    assert_eq!(
        ::core::mem::align_of::<NcmContentStorage>(),
        4usize,
        concat!("Alignment of ", stringify!(NcmContentStorage))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmContentStorage>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmContentStorage),
            "::",
            stringify!(s)
        )
    );
}
#[repr(C)]
pub struct NcmContentMetaDatabase {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_NcmContentMetaDatabase() {
    assert_eq!(
        ::core::mem::size_of::<NcmContentMetaDatabase>(),
        12usize,
        concat!("Size of: ", stringify!(NcmContentMetaDatabase))
    );
    assert_eq!(
        ::core::mem::align_of::<NcmContentMetaDatabase>(),
        4usize,
        concat!("Alignment of ", stringify!(NcmContentMetaDatabase))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmContentMetaDatabase>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmContentMetaDatabase),
            "::",
            stringify!(s)
        )
    );
}
#[repr(C)]
pub struct NcmNcaId {
    pub c: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_NcmNcaId() {
    assert_eq!(
        ::core::mem::size_of::<NcmNcaId>(),
        16usize,
        concat!("Size of: ", stringify!(NcmNcaId))
    );
    assert_eq!(
        ::core::mem::align_of::<NcmNcaId>(),
        1usize,
        concat!("Alignment of ", stringify!(NcmNcaId))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmNcaId>())).c as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmNcaId),
            "::",
            stringify!(c)
        )
    );
}
#[repr(C)]
pub struct NcmMetaRecord {
    pub titleId: u64,
    pub version: u32,
    pub type_: u8,
    pub flags: u8,
    pub padding: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_NcmMetaRecord() {
    assert_eq!(
        ::core::mem::size_of::<NcmMetaRecord>(),
        16usize,
        concat!("Size of: ", stringify!(NcmMetaRecord))
    );
    assert_eq!(
        ::core::mem::align_of::<NcmMetaRecord>(),
        8usize,
        concat!("Alignment of ", stringify!(NcmMetaRecord))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmMetaRecord>())).titleId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmMetaRecord),
            "::",
            stringify!(titleId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmMetaRecord>())).version as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmMetaRecord),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmMetaRecord>())).type_ as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmMetaRecord),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmMetaRecord>())).flags as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmMetaRecord),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmMetaRecord>())).padding as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmMetaRecord),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
pub struct NcmContentRecord {
    pub ncaId: NcmNcaId,
    pub size: [u8; 6usize],
    pub type_: u8,
    pub padding: u8,
}
#[test]
fn bindgen_test_layout_NcmContentRecord() {
    assert_eq!(
        ::core::mem::size_of::<NcmContentRecord>(),
        24usize,
        concat!("Size of: ", stringify!(NcmContentRecord))
    );
    assert_eq!(
        ::core::mem::align_of::<NcmContentRecord>(),
        1usize,
        concat!("Alignment of ", stringify!(NcmContentRecord))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmContentRecord>())).ncaId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmContentRecord),
            "::",
            stringify!(ncaId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmContentRecord>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmContentRecord),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmContentRecord>())).type_ as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmContentRecord),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmContentRecord>())).padding as *const _ as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmContentRecord),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
pub struct NcmContentMetaRecordsHeader {
    /// < Size of optional struct that comes after this one.
    pub numExtraBytes: u16,
    /// < Number of NcmContentRecord entries after the extra bytes.
    pub numContentRecords: u16,
    /// < Number of NcmMetaRecord entries that come after the NcmContentRecords.
    pub numMetaRecords: u16,
    /// < Always zero.
    pub padding: u16,
}
#[test]
fn bindgen_test_layout_NcmContentMetaRecordsHeader() {
    assert_eq!(
        ::core::mem::size_of::<NcmContentMetaRecordsHeader>(),
        8usize,
        concat!("Size of: ", stringify!(NcmContentMetaRecordsHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<NcmContentMetaRecordsHeader>(),
        2usize,
        concat!("Alignment of ", stringify!(NcmContentMetaRecordsHeader))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NcmContentMetaRecordsHeader>())).numExtraBytes as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmContentMetaRecordsHeader),
            "::",
            stringify!(numExtraBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NcmContentMetaRecordsHeader>())).numContentRecords as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmContentMetaRecordsHeader),
            "::",
            stringify!(numContentRecords)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NcmContentMetaRecordsHeader>())).numMetaRecords as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmContentMetaRecordsHeader),
            "::",
            stringify!(numMetaRecords)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NcmContentMetaRecordsHeader>())).padding as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmContentMetaRecordsHeader),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
pub struct NcmApplicationContentMetaKey {
    pub metaRecord: NcmMetaRecord,
    pub baseTitleId: u64,
}
#[test]
fn bindgen_test_layout_NcmApplicationContentMetaKey() {
    assert_eq!(
        ::core::mem::size_of::<NcmApplicationContentMetaKey>(),
        24usize,
        concat!("Size of: ", stringify!(NcmApplicationContentMetaKey))
    );
    assert_eq!(
        ::core::mem::align_of::<NcmApplicationContentMetaKey>(),
        8usize,
        concat!("Alignment of ", stringify!(NcmApplicationContentMetaKey))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NcmApplicationContentMetaKey>())).metaRecord as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmApplicationContentMetaKey),
            "::",
            stringify!(metaRecord)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NcmApplicationContentMetaKey>())).baseTitleId as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmApplicationContentMetaKey),
            "::",
            stringify!(baseTitleId)
        )
    );
}
#[repr(C)]
pub struct NcmRightsId {
    pub c: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_NcmRightsId() {
    assert_eq!(
        ::core::mem::size_of::<NcmRightsId>(),
        16usize,
        concat!("Size of: ", stringify!(NcmRightsId))
    );
    assert_eq!(
        ::core::mem::align_of::<NcmRightsId>(),
        1usize,
        concat!("Alignment of ", stringify!(NcmRightsId))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmRightsId>())).c as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmRightsId),
            "::",
            stringify!(c)
        )
    );
}
extern "C" {
    pub fn ncmInitialize() -> Result;
}
extern "C" {
    pub fn ncmExit();
}
extern "C" {
    pub fn ncmOpenContentStorage(storage: FsStorageId, out: *mut NcmContentStorage) -> Result;
}
extern "C" {
    pub fn ncmOpenContentMetaDatabase(
        storage: FsStorageId,
        out: *mut NcmContentMetaDatabase,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentStorageGeneratePlaceHolderId(
        cs: *mut NcmContentStorage,
        outputId: *mut NcmNcaId,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentStorageCreatePlaceHolder(
        cs: *mut NcmContentStorage,
        registeredId: *const NcmNcaId,
        placeholderId: *const NcmNcaId,
        size: u64,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentStorageDeletePlaceHolder(
        cs: *mut NcmContentStorage,
        placeholderId: *const NcmNcaId,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentStorageWritePlaceHolder(
        cs: *mut NcmContentStorage,
        placeholderId: *const NcmNcaId,
        offset: u64,
        srcData: *const ctypes::c_void,
        srcDataSize: usize,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentStorageRegister(
        cs: *mut NcmContentStorage,
        registeredId: *const NcmNcaId,
        placeholderId: *const NcmNcaId,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentStorageDelete(
        cs: *mut NcmContentStorage,
        registeredId: *const NcmNcaId,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentStorageHas(
        cs: *mut NcmContentStorage,
        ncaId: *const NcmNcaId,
        out: *mut bool,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentStorageGetPath(
        cs: *mut NcmContentStorage,
        ncaId: *const NcmNcaId,
        out: *mut ctypes::c_char,
        outSize: usize,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentStorageGetPlaceHolderPath(
        cs: *mut NcmContentStorage,
        ncaId: *const NcmNcaId,
        out: *mut ctypes::c_char,
        outSize: usize,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentStorageCleanupAllPlaceHolder(cs: *mut NcmContentStorage) -> Result;
}
extern "C" {
    pub fn ncmContentStorageGetSize(
        cs: *mut NcmContentStorage,
        ncaId: *const NcmNcaId,
        out: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentStorageDisableForcibly(cs: *mut NcmContentStorage) -> Result;
}
extern "C" {
    pub fn ncmContentStorageReadContentIdFile(
        cs: *mut NcmContentStorage,
        ncaId: *const NcmNcaId,
        offset: u64,
        outBuf: *mut ctypes::c_void,
        bufSize: usize,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentStorageGetRightsIdFromContentId(
        cs: *mut NcmContentStorage,
        ncaId: *const NcmNcaId,
        rightsIdOut: *mut NcmRightsId,
        keyGenerationOut: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentMetaDatabaseSet(
        db: *mut NcmContentMetaDatabase,
        record: *const NcmMetaRecord,
        inDataSize: u64,
        srcRecordsData: *const NcmContentMetaRecordsHeader,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentMetaDatabaseGet(
        db: *mut NcmContentMetaDatabase,
        record: *const NcmMetaRecord,
        outDataSize: u64,
        outRecordsData: *mut NcmContentMetaRecordsHeader,
        sizeRead: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentMetaDatabaseRemove(
        db: *mut NcmContentMetaDatabase,
        record: *const NcmMetaRecord,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentMetaDatabaseGetContentIdByType(
        db: *mut NcmContentMetaDatabase,
        contentType: NcmContentType,
        record: *const NcmMetaRecord,
        out: *mut NcmNcaId,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentMetaDatabaseListContentInfo(
        db: *mut NcmContentMetaDatabase,
        record: *const NcmMetaRecord,
        index: u32,
        contentRecordsOut: *mut NcmContentRecord,
        contentRecordsBufSize: usize,
        numEntriesRead: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentMetaDatabaseList(
        db: *mut NcmContentMetaDatabase,
        titleType: u32,
        titleIdExact: u64,
        titleIdLow: u64,
        titleIdHigh: u64,
        metaRecordsOut: *mut NcmMetaRecord,
        metaRecordsBufSize: usize,
        numEntriesWritten: *mut u32,
        numEntriesTotal: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentMetaDatabaseGetLatestContentMetaKey(
        db: *mut NcmContentMetaDatabase,
        titleId: u64,
        out: *mut NcmMetaRecord,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentMetaDatabaseListApplication(
        db: *mut NcmContentMetaDatabase,
        filter: u8,
        outBuf: *mut NcmApplicationContentMetaKey,
        outBufSize: usize,
        numEntriesWritten: *mut u32,
        numEntriesTotal: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentMetaDatabaseHas(
        db: *mut NcmContentMetaDatabase,
        record: *const NcmMetaRecord,
        out: *mut bool,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentMetaDatabaseDisableForcibly(db: *mut NcmContentMetaDatabase) -> Result;
}
extern "C" {
    pub fn ncmContentMetaDatabaseCommit(db: *mut NcmContentMetaDatabase) -> Result;
}
/// < Everything is awake.
pub const PscPmState_PscPmState_Awake: PscPmState = 0;
/// < Preparing to transition to awake.
pub const PscPmState_PscPmState_ReadyAwaken: PscPmState = 1;
/// < Preparing to transition to sleep.
pub const PscPmState_PscPmState_ReadySleep: PscPmState = 2;
/// < Critical services are ready to sleep.
pub const PscPmState_PscPmState_ReadySleepCritical: PscPmState = 3;
/// < Critical services are ready to wake up.
pub const PscPmState_PscPmState_ReadyAwakenCritical: PscPmState = 4;
/// < Preparing to transition to shutdown.
pub const PscPmState_PscPmState_ReadyShutdown: PscPmState = 5;
pub type PscPmState = u32;
#[repr(C)]
pub struct PscPmModule {
    pub event: Event,
    pub srv: Service,
    pub module_id: u16,
}
#[test]
fn bindgen_test_layout_PscPmModule() {
    assert_eq!(
        ::core::mem::size_of::<PscPmModule>(),
        28usize,
        concat!("Size of: ", stringify!(PscPmModule))
    );
    assert_eq!(
        ::core::mem::align_of::<PscPmModule>(),
        4usize,
        concat!("Alignment of ", stringify!(PscPmModule))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PscPmModule>())).event as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PscPmModule),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PscPmModule>())).srv as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PscPmModule),
            "::",
            stringify!(srv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PscPmModule>())).module_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PscPmModule),
            "::",
            stringify!(module_id)
        )
    );
}
extern "C" {
    pub fn pscInitialize() -> Result;
}
extern "C" {
    pub fn pscExit();
}
extern "C" {
    pub fn pscGetPmModule(
        out: *mut PscPmModule,
        module_id: u16,
        dependencies: *const u16,
        dependency_count: usize,
        autoclear: bool,
    ) -> Result;
}
extern "C" {
    pub fn pscPmModuleGetRequest(
        module: *mut PscPmModule,
        out_state: *mut PscPmState,
        out_flags: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn pscPmModuleAcknowledge(module: *mut PscPmModule, state: PscPmState) -> Result;
}
extern "C" {
    pub fn pscPmModuleFinalize(module: *mut PscPmModule) -> Result;
}
#[repr(C)]
pub struct CapsScreenShotAttribute {
    pub unk_x0: u32,
    pub unk_x4: [u8; 60usize],
}
#[test]
fn bindgen_test_layout_CapsScreenShotAttribute() {
    assert_eq!(
        ::core::mem::size_of::<CapsScreenShotAttribute>(),
        64usize,
        concat!("Size of: ", stringify!(CapsScreenShotAttribute))
    );
    assert_eq!(
        ::core::mem::align_of::<CapsScreenShotAttribute>(),
        4usize,
        concat!("Alignment of ", stringify!(CapsScreenShotAttribute))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CapsScreenShotAttribute>())).unk_x0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CapsScreenShotAttribute),
            "::",
            stringify!(unk_x0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CapsScreenShotAttribute>())).unk_x4 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CapsScreenShotAttribute),
            "::",
            stringify!(unk_x4)
        )
    );
}
/// AlbumEntry
#[repr(C)]
pub struct CapsAlbumEntry {
    pub unk_x0: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_CapsAlbumEntry() {
    assert_eq!(
        ::core::mem::size_of::<CapsAlbumEntry>(),
        32usize,
        concat!("Size of: ", stringify!(CapsAlbumEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<CapsAlbumEntry>(),
        1usize,
        concat!("Alignment of ", stringify!(CapsAlbumEntry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CapsAlbumEntry>())).unk_x0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CapsAlbumEntry),
            "::",
            stringify!(unk_x0)
        )
    );
}
/// ApplicationAlbumEntry
#[repr(C)]
pub struct CapsApplicationAlbumEntry {
    pub unk_x0: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_CapsApplicationAlbumEntry() {
    assert_eq!(
        ::core::mem::size_of::<CapsApplicationAlbumEntry>(),
        32usize,
        concat!("Size of: ", stringify!(CapsApplicationAlbumEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<CapsApplicationAlbumEntry>(),
        1usize,
        concat!("Alignment of ", stringify!(CapsApplicationAlbumEntry))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CapsApplicationAlbumEntry>())).unk_x0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CapsApplicationAlbumEntry),
            "::",
            stringify!(unk_x0)
        )
    );
}
extern "C" {
    /// Initialize caps:sc. Only available on 2.0.0+.
    pub fn capsscInitialize() -> Result;
}
extern "C" {
    pub fn capsscExit();
}
extern "C" {
    /// @brief This takes a screenshot, with the screenshot being written into the output buffer.
    /// @note Not available with 5.0.0+ (stubbed).
    /// @note buffer_index and buffer_count correspond to buffers with size 0x384000(1280*720*4). These must not be negative.
    /// @param buf Output buffer containing the RGBA8 image.
    /// @param size Size of buf, should be 0x384000(1280*720*4) * buffer_count.
    /// @param inval Value 0 can be used for this.
    /// @param width Image width, must be 1280.
    /// @param height Image height, must be 720.
    /// @param buffer_count Total number of output image buffers.
    /// @param buffer_index Starting image buffer index. Must be < buffer_count.
    /// @param timeout Timeout in nanoseconds. A default value of 100000000 can be used.
    pub fn capsscCaptureScreenshot(
        buf: *mut ctypes::c_void,
        size: usize,
        inval: u32,
        width: u64,
        height: u64,
        buffer_count: s64,
        buffer_index: s64,
        timeout: u64,
    ) -> Result;
}
extern "C" {
    /// Initialize caps:su. Only available on 4.0.0+.
    pub fn capssuInitialize() -> Result;
}
extern "C" {
    pub fn capssuExit();
}
extern "C" {
    /// Same as \ref capssuSaveScreenShotEx0, except this uses an all-zero CapsScreenShotAttribute where the first u32 is set to attr_val. attr_val can be zero.
    pub fn capssuSaveScreenShot(
        buffer: *const ctypes::c_void,
        size: usize,
        unk: u32,
        attr_val: u32,
        out: *mut CapsApplicationAlbumEntry,
    ) -> Result;
}
extern "C" {
    /// Saves an Album screenshot using the specified gfx data in buffer (1280x720 RGBA8), size must be at least 0x384000. unk can be zero.
    pub fn capssuSaveScreenShotEx0(
        buffer: *const ctypes::c_void,
        size: usize,
        attr: *mut CapsScreenShotAttribute,
        unk: u32,
        out: *mut CapsApplicationAlbumEntry,
    ) -> Result;
}
#[repr(C, packed)]
pub struct NfpuTagInfo {
    pub uuid: [u8; 10usize],
    pub uuid_length: u8,
    pub reserved1: [u8; 21usize],
    pub protocol: u32,
    pub tag_type: u32,
    pub reserved2: [u8; 48usize],
}
#[test]
fn bindgen_test_layout_NfpuTagInfo() {
    assert_eq!(
        ::core::mem::size_of::<NfpuTagInfo>(),
        88usize,
        concat!("Size of: ", stringify!(NfpuTagInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<NfpuTagInfo>(),
        1usize,
        concat!("Alignment of ", stringify!(NfpuTagInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuTagInfo>())).uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuTagInfo),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuTagInfo>())).uuid_length as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuTagInfo),
            "::",
            stringify!(uuid_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuTagInfo>())).reserved1 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuTagInfo),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuTagInfo>())).protocol as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuTagInfo),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuTagInfo>())).tag_type as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuTagInfo),
            "::",
            stringify!(tag_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuTagInfo>())).reserved2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuTagInfo),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C, packed)]
pub struct NfpuCommonInfo {
    pub last_write_year: u16,
    pub last_write_month: u8,
    pub last_write_day: u8,
    pub write_counter: u16,
    pub version: u16,
    pub application_area_size: u32,
    pub reserved: [u8; 52usize],
}
#[test]
fn bindgen_test_layout_NfpuCommonInfo() {
    assert_eq!(
        ::core::mem::size_of::<NfpuCommonInfo>(),
        64usize,
        concat!("Size of: ", stringify!(NfpuCommonInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<NfpuCommonInfo>(),
        1usize,
        concat!("Alignment of ", stringify!(NfpuCommonInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuCommonInfo>())).last_write_year as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuCommonInfo),
            "::",
            stringify!(last_write_year)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuCommonInfo>())).last_write_month as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuCommonInfo),
            "::",
            stringify!(last_write_month)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuCommonInfo>())).last_write_day as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuCommonInfo),
            "::",
            stringify!(last_write_day)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuCommonInfo>())).write_counter as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuCommonInfo),
            "::",
            stringify!(write_counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuCommonInfo>())).version as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuCommonInfo),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuCommonInfo>())).application_area_size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuCommonInfo),
            "::",
            stringify!(application_area_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuCommonInfo>())).reserved as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuCommonInfo),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
pub struct NfpuModelInfo {
    pub amiibo_id: [u8; 8usize],
    pub reserved: [u8; 56usize],
}
#[test]
fn bindgen_test_layout_NfpuModelInfo() {
    assert_eq!(
        ::core::mem::size_of::<NfpuModelInfo>(),
        64usize,
        concat!("Size of: ", stringify!(NfpuModelInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<NfpuModelInfo>(),
        1usize,
        concat!("Alignment of ", stringify!(NfpuModelInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuModelInfo>())).amiibo_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuModelInfo),
            "::",
            stringify!(amiibo_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuModelInfo>())).reserved as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuModelInfo),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
pub struct NfpuMiiCharInfo {
    pub unk_x0: [u8; 16usize],
    /// < utf-16be, null-terminated
    pub mii_name: [u16; 11usize],
    pub unk_x26: u8,
    pub mii_color: u8,
    pub mii_sex: u8,
    pub mii_height: u8,
    pub mii_width: u8,
    pub unk_x2b: [u8; 2usize],
    pub mii_face_shape: u8,
    pub mii_face_color: u8,
    pub mii_wrinkles_style: u8,
    pub mii_makeup_style: u8,
    pub mii_hair_style: u8,
    pub mii_hair_color: u8,
    pub mii_has_hair_flipped: u8,
    pub mii_eye_style: u8,
    pub mii_eye_color: u8,
    pub mii_eye_size: u8,
    pub mii_eye_thickness: u8,
    pub mii_eye_angle: u8,
    pub mii_eye_pos_x: u8,
    pub mii_eye_pos_y: u8,
    pub mii_eyebrow_style: u8,
    pub mii_eyebrow_color: u8,
    pub mii_eyebrow_size: u8,
    pub mii_eyebrow_thickness: u8,
    pub mii_eyebrow_angle: u8,
    pub mii_eyebrow_pos_x: u8,
    pub mii_eyebrow_pos_y: u8,
    pub mii_nose_style: u8,
    pub mii_nose_size: u8,
    pub mii_nose_pos: u8,
    pub mii_mouth_style: u8,
    pub mii_mouth_color: u8,
    pub mii_mouth_size: u8,
    pub mii_mouth_thickness: u8,
    pub mii_mouth_pos: u8,
    pub mii_facial_hair_color: u8,
    pub mii_beard_style: u8,
    pub mii_mustache_style: u8,
    pub mii_mustache_size: u8,
    pub mii_mustache_pos: u8,
    pub mii_glasses_style: u8,
    pub mii_glasses_color: u8,
    pub mii_glasses_size: u8,
    pub mii_glasses_pos: u8,
    pub mii_has_mole: u8,
    pub mii_mole_size: u8,
    pub mii_mole_pos_x: u8,
    pub mii_mole_pos_y: u8,
    pub unk_x57: u8,
}
#[test]
fn bindgen_test_layout_NfpuMiiCharInfo() {
    assert_eq!(
        ::core::mem::size_of::<NfpuMiiCharInfo>(),
        88usize,
        concat!("Size of: ", stringify!(NfpuMiiCharInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<NfpuMiiCharInfo>(),
        1usize,
        concat!("Alignment of ", stringify!(NfpuMiiCharInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).unk_x0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(unk_x0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).unk_x26 as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(unk_x26)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_color as *const _ as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_sex as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_sex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_height as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_width as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).unk_x2b as *const _ as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(unk_x2b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_face_shape as *const _ as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_face_shape)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_face_color as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_face_color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_wrinkles_style as *const _ as usize
        },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_wrinkles_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_makeup_style as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_makeup_style)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_hair_style as *const _ as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_hair_style)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_hair_color as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_hair_color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_has_hair_flipped as *const _ as usize
        },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_has_hair_flipped)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_eye_style as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_eye_style)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_eye_color as *const _ as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_eye_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_eye_size as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_eye_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_eye_thickness as *const _ as usize
        },
        55usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_eye_thickness)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_eye_angle as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_eye_angle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_eye_pos_x as *const _ as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_eye_pos_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_eye_pos_y as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_eye_pos_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_eyebrow_style as *const _ as usize
        },
        59usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_eyebrow_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_eyebrow_color as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_eyebrow_color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_eyebrow_size as *const _ as usize
        },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_eyebrow_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_eyebrow_thickness as *const _ as usize
        },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_eyebrow_thickness)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_eyebrow_angle as *const _ as usize
        },
        63usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_eyebrow_angle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_eyebrow_pos_x as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_eyebrow_pos_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_eyebrow_pos_y as *const _ as usize
        },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_eyebrow_pos_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_nose_style as *const _ as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_nose_style)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_nose_size as *const _ as usize },
        67usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_nose_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_nose_pos as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_nose_pos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_mouth_style as *const _ as usize
        },
        69usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_mouth_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_mouth_color as *const _ as usize
        },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_mouth_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_mouth_size as *const _ as usize },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_mouth_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_mouth_thickness as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_mouth_thickness)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_mouth_pos as *const _ as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_mouth_pos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_facial_hair_color as *const _ as usize
        },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_facial_hair_color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_beard_style as *const _ as usize
        },
        75usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_beard_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_mustache_style as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_mustache_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_mustache_size as *const _ as usize
        },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_mustache_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_mustache_pos as *const _ as usize
        },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_mustache_pos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_glasses_style as *const _ as usize
        },
        79usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_glasses_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_glasses_color as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_glasses_color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_glasses_size as *const _ as usize
        },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_glasses_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_glasses_pos as *const _ as usize
        },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_glasses_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_has_mole as *const _ as usize },
        83usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_has_mole)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_mole_size as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_mole_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_mole_pos_x as *const _ as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_mole_pos_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).mii_mole_pos_y as *const _ as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(mii_mole_pos_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuMiiCharInfo>())).unk_x57 as *const _ as usize },
        87usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuMiiCharInfo),
            "::",
            stringify!(unk_x57)
        )
    );
}
#[repr(C, packed)]
pub struct NfpuRegisterInfo {
    pub mii: NfpuMiiCharInfo,
    pub first_write_year: u16,
    pub first_write_month: u8,
    pub first_write_day: u8,
    /// < utf-8, null-terminated
    pub amiibo_name: [ctypes::c_char; 11usize],
    pub reserved: [u8; 153usize],
}
#[test]
fn bindgen_test_layout_NfpuRegisterInfo() {
    assert_eq!(
        ::core::mem::size_of::<NfpuRegisterInfo>(),
        256usize,
        concat!("Size of: ", stringify!(NfpuRegisterInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<NfpuRegisterInfo>(),
        1usize,
        concat!("Alignment of ", stringify!(NfpuRegisterInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuRegisterInfo>())).mii as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuRegisterInfo),
            "::",
            stringify!(mii)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuRegisterInfo>())).first_write_year as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuRegisterInfo),
            "::",
            stringify!(first_write_year)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuRegisterInfo>())).first_write_month as *const _ as usize
        },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuRegisterInfo),
            "::",
            stringify!(first_write_month)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NfpuRegisterInfo>())).first_write_day as *const _ as usize
        },
        91usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuRegisterInfo),
            "::",
            stringify!(first_write_day)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuRegisterInfo>())).amiibo_name as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuRegisterInfo),
            "::",
            stringify!(amiibo_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuRegisterInfo>())).reserved as *const _ as usize },
        103usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuRegisterInfo),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
pub struct NfpuInitConfig {
    pub unk1: u64,
    pub reserved1: [u64; 3usize],
    pub unk2: u64,
    pub reserved2: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_NfpuInitConfig() {
    assert_eq!(
        ::core::mem::size_of::<NfpuInitConfig>(),
        64usize,
        concat!("Size of: ", stringify!(NfpuInitConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<NfpuInitConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(NfpuInitConfig))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuInitConfig>())).unk1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuInitConfig),
            "::",
            stringify!(unk1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuInitConfig>())).reserved1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuInitConfig),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuInitConfig>())).unk2 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuInitConfig),
            "::",
            stringify!(unk2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NfpuInitConfig>())).reserved2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NfpuInitConfig),
            "::",
            stringify!(reserved2)
        )
    );
}
pub const NfpuState_NfpuState_NonInitialized: NfpuState = 0;
pub const NfpuState_NfpuState_Initialized: NfpuState = 1;
pub type NfpuState = u32;
pub const NfpuDeviceState_NfpuDeviceState_Initialized: NfpuDeviceState = 0;
pub const NfpuDeviceState_NfpuDeviceState_SearchingForTag: NfpuDeviceState = 1;
pub const NfpuDeviceState_NfpuDeviceState_TagFound: NfpuDeviceState = 2;
pub const NfpuDeviceState_NfpuDeviceState_TagRemoved: NfpuDeviceState = 3;
pub const NfpuDeviceState_NfpuDeviceState_TagMounted: NfpuDeviceState = 4;
pub const NfpuDeviceState_NfpuDeviceState_Unavailable: NfpuDeviceState = 5;
pub const NfpuDeviceState_NfpuDeviceState_Finalized: NfpuDeviceState = 6;
pub type NfpuDeviceState = u32;
pub const NfpuDeviceType_NfpuDeviceType_Amiibo: NfpuDeviceType = 0;
pub type NfpuDeviceType = u32;
pub const NfpuMountTarget_NfpuMountTarget_Rom: NfpuMountTarget = 1;
pub const NfpuMountTarget_NfpuMountTarget_Ram: NfpuMountTarget = 2;
pub const NfpuMountTarget_NfpuMountTarget_All: NfpuMountTarget = 3;
pub type NfpuMountTarget = u32;
extern "C" {
    pub fn nfpuInitialize(config: *const NfpuInitConfig) -> Result;
}
extern "C" {
    pub fn nfpuExit();
}
extern "C" {
    pub fn nfpuGetInterface() -> *mut Service;
}
extern "C" {
    pub fn nfpuStartDetection(id: HidControllerID) -> Result;
}
extern "C" {
    pub fn nfpuStopDetection(id: HidControllerID) -> Result;
}
extern "C" {
    /// Returned event will have autoclear off.
    pub fn nfpuAttachActivateEvent(id: HidControllerID, out: *mut Event) -> Result;
}
extern "C" {
    /// Returned event will have autoclear off.
    pub fn nfpuAttachDeactivateEvent(id: HidControllerID, out: *mut Event) -> Result;
}
extern "C" {
    /// Returned event will have autoclear on.
    pub fn nfpuAttachAvailabilityChangeEvent(out: *mut Event) -> Result;
}
extern "C" {
    pub fn nfpuGetState(out: *mut NfpuState) -> Result;
}
extern "C" {
    pub fn nfpuGetDeviceState(id: HidControllerID, out: *mut NfpuDeviceState) -> Result;
}
extern "C" {
    pub fn nfpuListDevices(
        count: *mut u32,
        out: *mut HidControllerID,
        num_elements: usize,
    ) -> Result;
}
extern "C" {
    pub fn nfpuGetNpadId(id: HidControllerID, out: *mut u32) -> Result;
}
extern "C" {
    pub fn nfpuMount(
        id: HidControllerID,
        device_type: NfpuDeviceType,
        mount_target: NfpuMountTarget,
    ) -> Result;
}
extern "C" {
    pub fn nfpuUnmount(id: HidControllerID) -> Result;
}
extern "C" {
    pub fn nfpuGetTagInfo(id: HidControllerID, out: *mut NfpuTagInfo) -> Result;
}
extern "C" {
    pub fn nfpuGetRegisterInfo(id: HidControllerID, out: *mut NfpuRegisterInfo) -> Result;
}
extern "C" {
    pub fn nfpuGetCommonInfo(id: HidControllerID, out: *mut NfpuCommonInfo) -> Result;
}
extern "C" {
    pub fn nfpuGetModelInfo(id: HidControllerID, out: *mut NfpuModelInfo) -> Result;
}
extern "C" {
    pub fn nfpuOpenApplicationArea(id: HidControllerID, app_id: u32, npad_id: *mut u32) -> Result;
}
extern "C" {
    pub fn nfpuGetApplicationArea(
        id: HidControllerID,
        buf: *mut ctypes::c_void,
        buf_size: usize,
    ) -> Result;
}
extern "C" {
    pub fn nfpuSetApplicationArea(
        id: HidControllerID,
        buf: *const ctypes::c_void,
        buf_size: usize,
    ) -> Result;
}
extern "C" {
    pub fn nfpuCreateApplicationArea(
        id: HidControllerID,
        app_id: u32,
        buf: *const ctypes::c_void,
        buf_size: usize,
    ) -> Result;
}
extern "C" {
    pub fn nfpuFlush(id: HidControllerID) -> Result;
}
extern "C" {
    pub fn nfpuRestore(id: HidControllerID) -> Result;
}
extern "C" {
    /// Calls nfc:user.
    pub fn nfpuIsNfcEnabled(out: *mut bool) -> Result;
}
/// < WLAN is disabled or enabled and not connected.
pub const WlanInfState_WlanInfState_NotConnected: WlanInfState = 1;
/// < WLAN is connecting.
pub const WlanInfState_WlanInfState_Connecting: WlanInfState = 2;
/// < WLAN is connected.
pub const WlanInfState_WlanInfState_Connected: WlanInfState = 3;
/// WLAN State.
pub type WlanInfState = u32;
extern "C" {
    pub fn wlaninfInitialize() -> Result;
}
extern "C" {
    pub fn wlaninfExit();
}
extern "C" {
    pub fn wlaninfGetState(out: *mut WlanInfState) -> Result;
}
extern "C" {
    /// Value goes from -30 (really good signal) to -90 (barely enough to stay connected)
    /// on a logarithmic scale
    pub fn wlaninfGetRSSI(out: *mut s32) -> Result;
}
extern "C" {
    pub fn pctlInitialize() -> Result;
}
extern "C" {
    pub fn pctlExit();
}
extern "C" {
    /// Gets whether Parental Controls are enabled.
    pub fn pctlIsRestrictionEnabled(flag: *mut bool) -> Result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Binder {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub id: s32,
    pub ipc_buffer_size: usize,
}
#[test]
fn bindgen_test_layout_Binder() {
    assert_eq!(
        ::core::mem::size_of::<Binder>(),
        16usize,
        concat!("Size of: ", stringify!(Binder))
    );
    assert_eq!(
        ::core::mem::align_of::<Binder>(),
        8usize,
        concat!("Alignment of ", stringify!(Binder))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Binder>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Binder),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Binder>())).ipc_buffer_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Binder),
            "::",
            stringify!(ipc_buffer_size)
        )
    );
}
impl Binder {
    #[inline]
    pub fn created(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_created(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn initialized(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_initialized(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_transact_auto(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_has_transact_auto(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        created: bool,
        initialized: bool,
        has_transact_auto: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let created: u8 = unsafe { ::core::mem::transmute(created) };
            created as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let initialized: u8 = unsafe { ::core::mem::transmute(initialized) };
            initialized as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let has_transact_auto: u8 = unsafe { ::core::mem::transmute(has_transact_auto) };
            has_transact_auto as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn binderCreate(b: *mut Binder, id: s32);
}
extern "C" {
    pub fn binderClose(b: *mut Binder);
}
extern "C" {
    pub fn binderInitSession(b: *mut Binder) -> Result;
}
extern "C" {
    pub fn binderTransactParcel(
        b: *mut Binder,
        code: u32,
        parcel_data: *mut ctypes::c_void,
        parcel_data_size: usize,
        parcel_reply: *mut ctypes::c_void,
        parcel_reply_size: usize,
        flags: u32,
    ) -> Result;
}
extern "C" {
    pub fn binderConvertErrorCode(code: s32) -> Result;
}
extern "C" {
    pub fn binderAdjustRefcount(b: *mut Binder, addval: s32, type_: s32) -> Result;
}
extern "C" {
    pub fn binderGetNativeHandle(b: *mut Binder, unk0: u32, event_out: *mut Event) -> Result;
}
#[repr(C)]
pub struct ParcelHeader {
    pub payload_size: u32,
    pub payload_off: u32,
    pub objects_size: u32,
    pub objects_off: u32,
}
#[test]
fn bindgen_test_layout_ParcelHeader() {
    assert_eq!(
        ::core::mem::size_of::<ParcelHeader>(),
        16usize,
        concat!("Size of: ", stringify!(ParcelHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<ParcelHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(ParcelHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ParcelHeader>())).payload_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ParcelHeader),
            "::",
            stringify!(payload_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ParcelHeader>())).payload_off as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ParcelHeader),
            "::",
            stringify!(payload_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ParcelHeader>())).objects_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ParcelHeader),
            "::",
            stringify!(objects_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ParcelHeader>())).objects_off as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ParcelHeader),
            "::",
            stringify!(objects_off)
        )
    );
}
#[repr(C)]
pub struct Parcel {
    pub payload: [u8; 1024usize],
    pub payload_size: u32,
    pub objects: *mut u8,
    pub objects_size: u32,
    pub capacity: u32,
    pub pos: u32,
}
#[test]
fn bindgen_test_layout_Parcel() {
    assert_eq!(
        ::core::mem::size_of::<Parcel>(),
        1056usize,
        concat!("Size of: ", stringify!(Parcel))
    );
    assert_eq!(
        ::core::mem::align_of::<Parcel>(),
        8usize,
        concat!("Alignment of ", stringify!(Parcel))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Parcel>())).payload as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Parcel),
            "::",
            stringify!(payload)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Parcel>())).payload_size as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(Parcel),
            "::",
            stringify!(payload_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Parcel>())).objects as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(Parcel),
            "::",
            stringify!(objects)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Parcel>())).objects_size as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(Parcel),
            "::",
            stringify!(objects_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Parcel>())).capacity as *const _ as usize },
        1044usize,
        concat!(
            "Offset of field: ",
            stringify!(Parcel),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Parcel>())).pos as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(Parcel),
            "::",
            stringify!(pos)
        )
    );
}
extern "C" {
    pub fn parcelCreate(ctx: *mut Parcel);
}
extern "C" {
    pub fn parcelTransact(
        session: *mut Binder,
        code: u32,
        in_parcel: *mut Parcel,
        reply_parcel: *mut Parcel,
    ) -> Result;
}
extern "C" {
    pub fn parcelWriteData(
        ctx: *mut Parcel,
        data: *const ctypes::c_void,
        data_size: usize,
    ) -> *mut ctypes::c_void;
}
extern "C" {
    pub fn parcelReadData(
        ctx: *mut Parcel,
        data: *mut ctypes::c_void,
        data_size: usize,
    ) -> *mut ctypes::c_void;
}
extern "C" {
    pub fn parcelWriteInt32(ctx: *mut Parcel, val: s32);
}
extern "C" {
    pub fn parcelWriteUInt32(ctx: *mut Parcel, val: u32);
}
extern "C" {
    pub fn parcelWriteString16(ctx: *mut Parcel, str: *const ctypes::c_char);
}
extern "C" {
    pub fn parcelReadInt32(ctx: *mut Parcel) -> s32;
}
extern "C" {
    pub fn parcelReadUInt32(ctx: *mut Parcel) -> u32;
}
extern "C" {
    pub fn parcelWriteInterfaceToken(ctx: *mut Parcel, str: *const ctypes::c_char);
}
extern "C" {
    pub fn parcelReadFlattenedObject(ctx: *mut Parcel, size: *mut usize) -> *mut ctypes::c_void;
}
extern "C" {
    pub fn parcelWriteFlattenedObject(
        ctx: *mut Parcel,
        data: *const ctypes::c_void,
        size: usize,
    ) -> *mut ctypes::c_void;
}
pub const PIXEL_FORMAT_RGBA_8888: _bindgen_ty_6 = 1;
pub const PIXEL_FORMAT_RGBX_8888: _bindgen_ty_6 = 2;
pub const PIXEL_FORMAT_RGB_888: _bindgen_ty_6 = 3;
pub const PIXEL_FORMAT_RGB_565: _bindgen_ty_6 = 4;
pub const PIXEL_FORMAT_BGRA_8888: _bindgen_ty_6 = 5;
pub const PIXEL_FORMAT_RGBA_5551: _bindgen_ty_6 = 6;
pub const PIXEL_FORMAT_RGBA_4444: _bindgen_ty_6 = 7;
pub const PIXEL_FORMAT_YCRCB_420_SP: _bindgen_ty_6 = 17;
pub const PIXEL_FORMAT_RAW16: _bindgen_ty_6 = 32;
pub const PIXEL_FORMAT_BLOB: _bindgen_ty_6 = 33;
pub const PIXEL_FORMAT_IMPLEMENTATION_DEFINED: _bindgen_ty_6 = 34;
pub const PIXEL_FORMAT_YCBCR_420_888: _bindgen_ty_6 = 35;
pub const PIXEL_FORMAT_Y8: _bindgen_ty_6 = 538982489;
pub const PIXEL_FORMAT_Y16: _bindgen_ty_6 = 540422489;
pub const PIXEL_FORMAT_YV12: _bindgen_ty_6 = 842094169;
pub type _bindgen_ty_6 = u32;
pub const GRALLOC_USAGE_SW_READ_NEVER: _bindgen_ty_7 = 0;
pub const GRALLOC_USAGE_SW_READ_RARELY: _bindgen_ty_7 = 2;
pub const GRALLOC_USAGE_SW_READ_OFTEN: _bindgen_ty_7 = 3;
pub const GRALLOC_USAGE_SW_READ_MASK: _bindgen_ty_7 = 15;
pub const GRALLOC_USAGE_SW_WRITE_NEVER: _bindgen_ty_7 = 0;
pub const GRALLOC_USAGE_SW_WRITE_RARELY: _bindgen_ty_7 = 32;
pub const GRALLOC_USAGE_SW_WRITE_OFTEN: _bindgen_ty_7 = 48;
pub const GRALLOC_USAGE_SW_WRITE_MASK: _bindgen_ty_7 = 240;
pub const GRALLOC_USAGE_HW_TEXTURE: _bindgen_ty_7 = 256;
pub const GRALLOC_USAGE_HW_RENDER: _bindgen_ty_7 = 512;
pub const GRALLOC_USAGE_HW_2D: _bindgen_ty_7 = 1024;
pub const GRALLOC_USAGE_HW_COMPOSER: _bindgen_ty_7 = 2048;
pub const GRALLOC_USAGE_HW_FB: _bindgen_ty_7 = 4096;
pub const GRALLOC_USAGE_EXTERNAL_DISP: _bindgen_ty_7 = 8192;
pub const GRALLOC_USAGE_PROTECTED: _bindgen_ty_7 = 16384;
pub const GRALLOC_USAGE_CURSOR: _bindgen_ty_7 = 32768;
pub const GRALLOC_USAGE_HW_VIDEO_ENCODER: _bindgen_ty_7 = 65536;
pub const GRALLOC_USAGE_HW_CAMERA_WRITE: _bindgen_ty_7 = 131072;
pub const GRALLOC_USAGE_HW_CAMERA_READ: _bindgen_ty_7 = 262144;
pub const GRALLOC_USAGE_HW_CAMERA_ZSL: _bindgen_ty_7 = 393216;
pub const GRALLOC_USAGE_HW_CAMERA_MASK: _bindgen_ty_7 = 393216;
pub const GRALLOC_USAGE_HW_MASK: _bindgen_ty_7 = 466688;
pub const GRALLOC_USAGE_RENDERSCRIPT: _bindgen_ty_7 = 1048576;
pub type _bindgen_ty_7 = u32;
pub const NATIVE_WINDOW_WIDTH: _bindgen_ty_8 = 0;
pub const NATIVE_WINDOW_HEIGHT: _bindgen_ty_8 = 1;
pub const NATIVE_WINDOW_FORMAT: _bindgen_ty_8 = 2;
pub type _bindgen_ty_8 = u32;
pub const NATIVE_WINDOW_API_CPU: _bindgen_ty_9 = 2;
pub type _bindgen_ty_9 = u32;
pub const HAL_TRANSFORM_FLIP_H: _bindgen_ty_10 = 1;
pub const HAL_TRANSFORM_FLIP_V: _bindgen_ty_10 = 2;
pub const HAL_TRANSFORM_ROT_90: _bindgen_ty_10 = 4;
pub const HAL_TRANSFORM_ROT_180: _bindgen_ty_10 = 3;
pub const HAL_TRANSFORM_ROT_270: _bindgen_ty_10 = 7;
/// Transformation definitions
///
/// IMPORTANT NOTE:
/// HAL_TRANSFORM_ROT_90 is applied CLOCKWISE and AFTER HAL_TRANSFORM_FLIP_{H|V}.
///
pub type _bindgen_ty_10 = u32;
pub const NATIVE_WINDOW_TRANSFORM_FLIP_H: _bindgen_ty_11 = 1;
pub const NATIVE_WINDOW_TRANSFORM_FLIP_V: _bindgen_ty_11 = 2;
pub const NATIVE_WINDOW_TRANSFORM_ROT_90: _bindgen_ty_11 = 4;
pub const NATIVE_WINDOW_TRANSFORM_ROT_180: _bindgen_ty_11 = 3;
pub const NATIVE_WINDOW_TRANSFORM_ROT_270: _bindgen_ty_11 = 7;
pub type _bindgen_ty_11 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NativeHandle {
    pub version: ctypes::c_int,
    pub num_fds: ctypes::c_int,
    pub num_ints: ctypes::c_int,
}
#[test]
fn bindgen_test_layout_NativeHandle() {
    assert_eq!(
        ::core::mem::size_of::<NativeHandle>(),
        12usize,
        concat!("Size of: ", stringify!(NativeHandle))
    );
    assert_eq!(
        ::core::mem::align_of::<NativeHandle>(),
        4usize,
        concat!("Alignment of ", stringify!(NativeHandle))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NativeHandle>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NativeHandle),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NativeHandle>())).num_fds as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NativeHandle),
            "::",
            stringify!(num_fds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NativeHandle>())).num_ints as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NativeHandle),
            "::",
            stringify!(num_ints)
        )
    );
}
pub type iova_t = u64;
pub const NvLayout_NvLayout_Pitch: NvLayout = 1;
pub const NvLayout_NvLayout_Tiled: NvLayout = 2;
pub const NvLayout_NvLayout_BlockLinear: NvLayout = 3;
pub type NvLayout = u32;
pub const NvDisplayScanFormat_NvDisplayScanFormat_Progressive: NvDisplayScanFormat = 0;
pub const NvDisplayScanFormat_NvDisplayScanFormat_Interlaced: NvDisplayScanFormat = 1;
pub type NvDisplayScanFormat = u32;
pub const NvKind_NvKind_Pitch: NvKind = 0;
pub const NvKind_NvKind_Z16: NvKind = 1;
pub const NvKind_NvKind_Z16_2C: NvKind = 2;
pub const NvKind_NvKind_Z16_MS2_2C: NvKind = 3;
pub const NvKind_NvKind_Z16_MS4_2C: NvKind = 4;
pub const NvKind_NvKind_Z16_MS8_2C: NvKind = 5;
pub const NvKind_NvKind_Z16_MS16_2C: NvKind = 6;
pub const NvKind_NvKind_Z16_2Z: NvKind = 7;
pub const NvKind_NvKind_Z16_MS2_2Z: NvKind = 8;
pub const NvKind_NvKind_Z16_MS4_2Z: NvKind = 9;
pub const NvKind_NvKind_Z16_MS8_2Z: NvKind = 10;
pub const NvKind_NvKind_Z16_MS16_2Z: NvKind = 11;
pub const NvKind_NvKind_Z16_4CZ: NvKind = 12;
pub const NvKind_NvKind_Z16_MS2_4CZ: NvKind = 13;
pub const NvKind_NvKind_Z16_MS4_4CZ: NvKind = 14;
pub const NvKind_NvKind_Z16_MS8_4CZ: NvKind = 15;
pub const NvKind_NvKind_Z16_MS16_4CZ: NvKind = 16;
pub const NvKind_NvKind_S8Z24: NvKind = 17;
pub const NvKind_NvKind_S8Z24_1Z: NvKind = 18;
pub const NvKind_NvKind_S8Z24_MS2_1Z: NvKind = 19;
pub const NvKind_NvKind_S8Z24_MS4_1Z: NvKind = 20;
pub const NvKind_NvKind_S8Z24_MS8_1Z: NvKind = 21;
pub const NvKind_NvKind_S8Z24_MS16_1Z: NvKind = 22;
pub const NvKind_NvKind_S8Z24_2CZ: NvKind = 23;
pub const NvKind_NvKind_S8Z24_MS2_2CZ: NvKind = 24;
pub const NvKind_NvKind_S8Z24_MS4_2CZ: NvKind = 25;
pub const NvKind_NvKind_S8Z24_MS8_2CZ: NvKind = 26;
pub const NvKind_NvKind_S8Z24_MS16_2CZ: NvKind = 27;
pub const NvKind_NvKind_S8Z24_2CS: NvKind = 28;
pub const NvKind_NvKind_S8Z24_MS2_2CS: NvKind = 29;
pub const NvKind_NvKind_S8Z24_MS4_2CS: NvKind = 30;
pub const NvKind_NvKind_S8Z24_MS8_2CS: NvKind = 31;
pub const NvKind_NvKind_S8Z24_MS16_2CS: NvKind = 32;
pub const NvKind_NvKind_S8Z24_4CSZV: NvKind = 33;
pub const NvKind_NvKind_S8Z24_MS2_4CSZV: NvKind = 34;
pub const NvKind_NvKind_S8Z24_MS4_4CSZV: NvKind = 35;
pub const NvKind_NvKind_S8Z24_MS8_4CSZV: NvKind = 36;
pub const NvKind_NvKind_S8Z24_MS16_4CSZV: NvKind = 37;
pub const NvKind_NvKind_V8Z24_MS4_VC12: NvKind = 38;
pub const NvKind_NvKind_V8Z24_MS4_VC4: NvKind = 39;
pub const NvKind_NvKind_V8Z24_MS8_VC8: NvKind = 40;
pub const NvKind_NvKind_V8Z24_MS8_VC24: NvKind = 41;
pub const NvKind_NvKind_S8: NvKind = 42;
pub const NvKind_NvKind_S8_2S: NvKind = 43;
pub const NvKind_NvKind_V8Z24_MS4_VC12_1ZV: NvKind = 46;
pub const NvKind_NvKind_V8Z24_MS4_VC4_1ZV: NvKind = 47;
pub const NvKind_NvKind_V8Z24_MS8_VC8_1ZV: NvKind = 48;
pub const NvKind_NvKind_V8Z24_MS8_VC24_1ZV: NvKind = 49;
pub const NvKind_NvKind_V8Z24_MS4_VC12_2CS: NvKind = 50;
pub const NvKind_NvKind_V8Z24_MS4_VC4_2CS: NvKind = 51;
pub const NvKind_NvKind_V8Z24_MS8_VC8_2CS: NvKind = 52;
pub const NvKind_NvKind_V8Z24_MS8_VC24_2CS: NvKind = 53;
pub const NvKind_NvKind_V8Z24_MS4_VC12_2CZV: NvKind = 58;
pub const NvKind_NvKind_V8Z24_MS4_VC4_2CZV: NvKind = 59;
pub const NvKind_NvKind_V8Z24_MS8_VC8_2CZV: NvKind = 60;
pub const NvKind_NvKind_V8Z24_MS8_VC24_2CZV: NvKind = 61;
pub const NvKind_NvKind_V8Z24_MS4_VC12_2ZV: NvKind = 62;
pub const NvKind_NvKind_V8Z24_MS4_VC4_2ZV: NvKind = 63;
pub const NvKind_NvKind_V8Z24_MS8_VC8_2ZV: NvKind = 64;
pub const NvKind_NvKind_V8Z24_MS8_VC24_2ZV: NvKind = 65;
pub const NvKind_NvKind_V8Z24_MS4_VC12_4CSZV: NvKind = 66;
pub const NvKind_NvKind_V8Z24_MS4_VC4_4CSZV: NvKind = 67;
pub const NvKind_NvKind_V8Z24_MS8_VC8_4CSZV: NvKind = 68;
pub const NvKind_NvKind_V8Z24_MS8_VC24_4CSZV: NvKind = 69;
pub const NvKind_NvKind_Z24S8: NvKind = 70;
pub const NvKind_NvKind_Z24S8_1Z: NvKind = 71;
pub const NvKind_NvKind_Z24S8_MS2_1Z: NvKind = 72;
pub const NvKind_NvKind_Z24S8_MS4_1Z: NvKind = 73;
pub const NvKind_NvKind_Z24S8_MS8_1Z: NvKind = 74;
pub const NvKind_NvKind_Z24S8_MS16_1Z: NvKind = 75;
pub const NvKind_NvKind_Z24S8_2CS: NvKind = 76;
pub const NvKind_NvKind_Z24S8_MS2_2CS: NvKind = 77;
pub const NvKind_NvKind_Z24S8_MS4_2CS: NvKind = 78;
pub const NvKind_NvKind_Z24S8_MS8_2CS: NvKind = 79;
pub const NvKind_NvKind_Z24S8_MS16_2CS: NvKind = 80;
pub const NvKind_NvKind_Z24S8_2CZ: NvKind = 81;
pub const NvKind_NvKind_Z24S8_MS2_2CZ: NvKind = 82;
pub const NvKind_NvKind_Z24S8_MS4_2CZ: NvKind = 83;
pub const NvKind_NvKind_Z24S8_MS8_2CZ: NvKind = 84;
pub const NvKind_NvKind_Z24S8_MS16_2CZ: NvKind = 85;
pub const NvKind_NvKind_Z24S8_4CSZV: NvKind = 86;
pub const NvKind_NvKind_Z24S8_MS2_4CSZV: NvKind = 87;
pub const NvKind_NvKind_Z24S8_MS4_4CSZV: NvKind = 88;
pub const NvKind_NvKind_Z24S8_MS8_4CSZV: NvKind = 89;
pub const NvKind_NvKind_Z24S8_MS16_4CSZV: NvKind = 90;
pub const NvKind_NvKind_Z24V8_MS4_VC12: NvKind = 91;
pub const NvKind_NvKind_Z24V8_MS4_VC4: NvKind = 92;
pub const NvKind_NvKind_Z24V8_MS8_VC8: NvKind = 93;
pub const NvKind_NvKind_Z24V8_MS8_VC24: NvKind = 94;
pub const NvKind_NvKind_Z24V8_MS4_VC12_1ZV: NvKind = 99;
pub const NvKind_NvKind_Z24V8_MS4_VC4_1ZV: NvKind = 100;
pub const NvKind_NvKind_Z24V8_MS8_VC8_1ZV: NvKind = 101;
pub const NvKind_NvKind_Z24V8_MS8_VC24_1ZV: NvKind = 102;
pub const NvKind_NvKind_Z24V8_MS4_VC12_2CS: NvKind = 103;
pub const NvKind_NvKind_Z24V8_MS4_VC4_2CS: NvKind = 104;
pub const NvKind_NvKind_Z24V8_MS8_VC8_2CS: NvKind = 105;
pub const NvKind_NvKind_Z24V8_MS8_VC24_2CS: NvKind = 106;
pub const NvKind_NvKind_Z24V8_MS4_VC12_2CZV: NvKind = 111;
pub const NvKind_NvKind_Z24V8_MS4_VC4_2CZV: NvKind = 112;
pub const NvKind_NvKind_Z24V8_MS8_VC8_2CZV: NvKind = 113;
pub const NvKind_NvKind_Z24V8_MS8_VC24_2CZV: NvKind = 114;
pub const NvKind_NvKind_Z24V8_MS4_VC12_2ZV: NvKind = 115;
pub const NvKind_NvKind_Z24V8_MS4_VC4_2ZV: NvKind = 116;
pub const NvKind_NvKind_Z24V8_MS8_VC8_2ZV: NvKind = 117;
pub const NvKind_NvKind_Z24V8_MS8_VC24_2ZV: NvKind = 118;
pub const NvKind_NvKind_Z24V8_MS4_VC12_4CSZV: NvKind = 119;
pub const NvKind_NvKind_Z24V8_MS4_VC4_4CSZV: NvKind = 120;
pub const NvKind_NvKind_Z24V8_MS8_VC8_4CSZV: NvKind = 121;
pub const NvKind_NvKind_Z24V8_MS8_VC24_4CSZV: NvKind = 122;
pub const NvKind_NvKind_ZF32: NvKind = 123;
pub const NvKind_NvKind_ZF32_1Z: NvKind = 124;
pub const NvKind_NvKind_ZF32_MS2_1Z: NvKind = 125;
pub const NvKind_NvKind_ZF32_MS4_1Z: NvKind = 126;
pub const NvKind_NvKind_ZF32_MS8_1Z: NvKind = 127;
pub const NvKind_NvKind_ZF32_MS16_1Z: NvKind = 128;
pub const NvKind_NvKind_ZF32_2CS: NvKind = 129;
pub const NvKind_NvKind_ZF32_MS2_2CS: NvKind = 130;
pub const NvKind_NvKind_ZF32_MS4_2CS: NvKind = 131;
pub const NvKind_NvKind_ZF32_MS8_2CS: NvKind = 132;
pub const NvKind_NvKind_ZF32_MS16_2CS: NvKind = 133;
pub const NvKind_NvKind_ZF32_2CZ: NvKind = 134;
pub const NvKind_NvKind_ZF32_MS2_2CZ: NvKind = 135;
pub const NvKind_NvKind_ZF32_MS4_2CZ: NvKind = 136;
pub const NvKind_NvKind_ZF32_MS8_2CZ: NvKind = 137;
pub const NvKind_NvKind_ZF32_MS16_2CZ: NvKind = 138;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS4_VC12: NvKind = 139;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS4_VC4: NvKind = 140;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS8_VC8: NvKind = 141;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS8_VC24: NvKind = 142;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS4_VC12_1CS: NvKind = 143;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS4_VC4_1CS: NvKind = 144;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS8_VC8_1CS: NvKind = 145;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS8_VC24_1CS: NvKind = 146;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS4_VC12_1ZV: NvKind = 151;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS4_VC4_1ZV: NvKind = 152;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS8_VC8_1ZV: NvKind = 153;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS8_VC24_1ZV: NvKind = 154;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS4_VC12_1CZV: NvKind = 155;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS4_VC4_1CZV: NvKind = 156;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS8_VC8_1CZV: NvKind = 157;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS8_VC24_1CZV: NvKind = 158;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS4_VC12_2CS: NvKind = 159;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS4_VC4_2CS: NvKind = 160;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS8_VC8_2CS: NvKind = 161;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS8_VC24_2CS: NvKind = 162;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS4_VC12_2CSZV: NvKind = 163;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS4_VC4_2CSZV: NvKind = 164;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS8_VC8_2CSZV: NvKind = 165;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS8_VC24_2CSZV: NvKind = 166;
pub const NvKind_NvKind_ZF32_X16V8S8_MS4_VC12: NvKind = 167;
pub const NvKind_NvKind_ZF32_X16V8S8_MS4_VC4: NvKind = 168;
pub const NvKind_NvKind_ZF32_X16V8S8_MS8_VC8: NvKind = 169;
pub const NvKind_NvKind_ZF32_X16V8S8_MS8_VC24: NvKind = 170;
pub const NvKind_NvKind_ZF32_X16V8S8_MS4_VC12_1CS: NvKind = 171;
pub const NvKind_NvKind_ZF32_X16V8S8_MS4_VC4_1CS: NvKind = 172;
pub const NvKind_NvKind_ZF32_X16V8S8_MS8_VC8_1CS: NvKind = 173;
pub const NvKind_NvKind_ZF32_X16V8S8_MS8_VC24_1CS: NvKind = 174;
pub const NvKind_NvKind_ZF32_X16V8S8_MS4_VC12_1ZV: NvKind = 179;
pub const NvKind_NvKind_ZF32_X16V8S8_MS4_VC4_1ZV: NvKind = 180;
pub const NvKind_NvKind_ZF32_X16V8S8_MS8_VC8_1ZV: NvKind = 181;
pub const NvKind_NvKind_ZF32_X16V8S8_MS8_VC24_1ZV: NvKind = 182;
pub const NvKind_NvKind_ZF32_X16V8S8_MS4_VC12_1CZV: NvKind = 183;
pub const NvKind_NvKind_ZF32_X16V8S8_MS4_VC4_1CZV: NvKind = 184;
pub const NvKind_NvKind_ZF32_X16V8S8_MS8_VC8_1CZV: NvKind = 185;
pub const NvKind_NvKind_ZF32_X16V8S8_MS8_VC24_1CZV: NvKind = 186;
pub const NvKind_NvKind_ZF32_X16V8S8_MS4_VC12_2CS: NvKind = 187;
pub const NvKind_NvKind_ZF32_X16V8S8_MS4_VC4_2CS: NvKind = 188;
pub const NvKind_NvKind_ZF32_X16V8S8_MS8_VC8_2CS: NvKind = 189;
pub const NvKind_NvKind_ZF32_X16V8S8_MS8_VC24_2CS: NvKind = 190;
pub const NvKind_NvKind_ZF32_X16V8S8_MS4_VC12_2CSZV: NvKind = 191;
pub const NvKind_NvKind_ZF32_X16V8S8_MS4_VC4_2CSZV: NvKind = 192;
pub const NvKind_NvKind_ZF32_X16V8S8_MS8_VC8_2CSZV: NvKind = 193;
pub const NvKind_NvKind_ZF32_X16V8S8_MS8_VC24_2CSZV: NvKind = 194;
pub const NvKind_NvKind_ZF32_X24S8: NvKind = 195;
pub const NvKind_NvKind_ZF32_X24S8_1CS: NvKind = 196;
pub const NvKind_NvKind_ZF32_X24S8_MS2_1CS: NvKind = 197;
pub const NvKind_NvKind_ZF32_X24S8_MS4_1CS: NvKind = 198;
pub const NvKind_NvKind_ZF32_X24S8_MS8_1CS: NvKind = 199;
pub const NvKind_NvKind_ZF32_X24S8_MS16_1CS: NvKind = 200;
pub const NvKind_NvKind_SmskedMessage: NvKind = 202;
pub const NvKind_NvKind_SmhostMessage: NvKind = 203;
pub const NvKind_NvKind_C64_MS2_2CRA: NvKind = 205;
pub const NvKind_NvKind_ZF32_X24S8_2CSZV: NvKind = 206;
pub const NvKind_NvKind_ZF32_X24S8_MS2_2CSZV: NvKind = 207;
pub const NvKind_NvKind_ZF32_X24S8_MS4_2CSZV: NvKind = 208;
pub const NvKind_NvKind_ZF32_X24S8_MS8_2CSZV: NvKind = 209;
pub const NvKind_NvKind_ZF32_X24S8_MS16_2CSZV: NvKind = 210;
pub const NvKind_NvKind_ZF32_X24S8_2CS: NvKind = 211;
pub const NvKind_NvKind_ZF32_X24S8_MS2_2CS: NvKind = 212;
pub const NvKind_NvKind_ZF32_X24S8_MS4_2CS: NvKind = 213;
pub const NvKind_NvKind_ZF32_X24S8_MS8_2CS: NvKind = 214;
pub const NvKind_NvKind_ZF32_X24S8_MS16_2CS: NvKind = 215;
pub const NvKind_NvKind_C32_2C: NvKind = 216;
pub const NvKind_NvKind_C32_2CBR: NvKind = 217;
pub const NvKind_NvKind_C32_2CBA: NvKind = 218;
pub const NvKind_NvKind_C32_2CRA: NvKind = 219;
pub const NvKind_NvKind_C32_2BRA: NvKind = 220;
pub const NvKind_NvKind_C32_MS2_2C: NvKind = 221;
pub const NvKind_NvKind_C32_MS2_2CBR: NvKind = 222;
pub const NvKind_NvKind_C32_MS2_2CRA: NvKind = 204;
pub const NvKind_NvKind_C32_MS4_2C: NvKind = 223;
pub const NvKind_NvKind_C32_MS4_2CBR: NvKind = 224;
pub const NvKind_NvKind_C32_MS4_2CBA: NvKind = 225;
pub const NvKind_NvKind_C32_MS4_2CRA: NvKind = 226;
pub const NvKind_NvKind_C32_MS4_2BRA: NvKind = 227;
pub const NvKind_NvKind_C32_MS8_MS16_2C: NvKind = 228;
pub const NvKind_NvKind_C32_MS8_MS16_2CRA: NvKind = 229;
pub const NvKind_NvKind_C64_2C: NvKind = 230;
pub const NvKind_NvKind_C64_2CBR: NvKind = 231;
pub const NvKind_NvKind_C64_2CBA: NvKind = 232;
pub const NvKind_NvKind_C64_2CRA: NvKind = 233;
pub const NvKind_NvKind_C64_2BRA: NvKind = 234;
pub const NvKind_NvKind_C64_MS2_2C: NvKind = 235;
pub const NvKind_NvKind_C64_MS2_2CBR: NvKind = 236;
pub const NvKind_NvKind_C64_MS4_2C: NvKind = 237;
pub const NvKind_NvKind_C64_MS4_2CBR: NvKind = 238;
pub const NvKind_NvKind_C64_MS4_2CBA: NvKind = 239;
pub const NvKind_NvKind_C64_MS4_2CRA: NvKind = 240;
pub const NvKind_NvKind_C64_MS4_2BRA: NvKind = 241;
pub const NvKind_NvKind_C64_MS8_MS16_2C: NvKind = 242;
pub const NvKind_NvKind_C64_MS8_MS16_2CRA: NvKind = 243;
pub const NvKind_NvKind_C128_2C: NvKind = 244;
pub const NvKind_NvKind_C128_2CR: NvKind = 245;
pub const NvKind_NvKind_C128_MS2_2C: NvKind = 246;
pub const NvKind_NvKind_C128_MS2_2CR: NvKind = 247;
pub const NvKind_NvKind_C128_MS4_2C: NvKind = 248;
pub const NvKind_NvKind_C128_MS4_2CR: NvKind = 249;
pub const NvKind_NvKind_C128_MS8_MS16_2C: NvKind = 250;
pub const NvKind_NvKind_C128_MS8_MS16_2CR: NvKind = 251;
pub const NvKind_NvKind_X8C24: NvKind = 252;
pub const NvKind_NvKind_PitchNoSwizzle: NvKind = 253;
pub const NvKind_NvKind_Generic_16BX2: NvKind = 254;
pub const NvKind_NvKind_Invalid: NvKind = 255;
pub type NvKind = u32;
pub const NvColorFormat_NvColorFormat_Unspecified: NvColorFormat = 0;
pub const NvColorFormat_NvColorFormat_NonColor8: NvColorFormat = 153093128;
pub const NvColorFormat_NvColorFormat_NonColor16: NvColorFormat = 153094672;
pub const NvColorFormat_NvColorFormat_NonColor24: NvColorFormat = 153098776;
pub const NvColorFormat_NvColorFormat_NonColor32: NvColorFormat = 153099296;
pub const NvColorFormat_NvColorFormat_X4C4: NvColorFormat = 153158920;
pub const NvColorFormat_NvColorFormat_A4L4: NvColorFormat = 4299752712;
pub const NvColorFormat_NvColorFormat_A8L8: NvColorFormat = 4299755024;
pub const NvColorFormat_NvColorFormat_Float_A16L16: NvColorFormat = 4299775264;
pub const NvColorFormat_NvColorFormat_A1B5G5R5: NvColorFormat = 4300411920;
pub const NvColorFormat_NvColorFormat_A4B4G4R4: NvColorFormat = 4300412176;
pub const NvColorFormat_NvColorFormat_A5B5G5R1: NvColorFormat = 4300412944;
pub const NvColorFormat_NvColorFormat_A2B10G10R10: NvColorFormat = 4300415008;
pub const NvColorFormat_NvColorFormat_A8B8G8R8: NvColorFormat = 4300415264;
pub const NvColorFormat_NvColorFormat_A16B16G16R16: NvColorFormat = 4300416832;
pub const NvColorFormat_NvColorFormat_Float_A16B16G16R16: NvColorFormat = 4300433216;
pub const NvColorFormat_NvColorFormat_A1R5G5B5: NvColorFormat = 4308669456;
pub const NvColorFormat_NvColorFormat_A4R4G4B4: NvColorFormat = 4308669712;
pub const NvColorFormat_NvColorFormat_A5R1G5B5: NvColorFormat = 4308669968;
pub const NvColorFormat_NvColorFormat_A2R10G10B10: NvColorFormat = 4308672544;
pub const NvColorFormat_NvColorFormat_A8R8G8B8: NvColorFormat = 4308672800;
pub const NvColorFormat_NvColorFormat_A1: NvColorFormat = 4314104065;
pub const NvColorFormat_NvColorFormat_A2: NvColorFormat = 4314104322;
pub const NvColorFormat_NvColorFormat_A4: NvColorFormat = 4314104580;
pub const NvColorFormat_NvColorFormat_A8: NvColorFormat = 4314104840;
pub const NvColorFormat_NvColorFormat_A16: NvColorFormat = 4314106384;
pub const NvColorFormat_NvColorFormat_A32: NvColorFormat = 4314111008;
pub const NvColorFormat_NvColorFormat_Float_A16: NvColorFormat = 4314122768;
pub const NvColorFormat_NvColorFormat_L4A4: NvColorFormat = 4328523016;
pub const NvColorFormat_NvColorFormat_L8A8: NvColorFormat = 4328525328;
pub const NvColorFormat_NvColorFormat_B4G4R4A4: NvColorFormat = 4396291344;
pub const NvColorFormat_NvColorFormat_B5G5R1A5: NvColorFormat = 4396291856;
pub const NvColorFormat_NvColorFormat_B5G5R5A1: NvColorFormat = 4396292112;
pub const NvColorFormat_NvColorFormat_B8G8R8A8: NvColorFormat = 4396294432;
pub const NvColorFormat_NvColorFormat_B10G10R10A2: NvColorFormat = 4396294944;
pub const NvColorFormat_NvColorFormat_R1G5B5A5: NvColorFormat = 4404548624;
pub const NvColorFormat_NvColorFormat_R4G4B4A4: NvColorFormat = 4404548880;
pub const NvColorFormat_NvColorFormat_R5G5B5A1: NvColorFormat = 4404549648;
pub const NvColorFormat_NvColorFormat_R8G8B8A8: NvColorFormat = 4404551968;
pub const NvColorFormat_NvColorFormat_R10G10B10A2: NvColorFormat = 4404552480;
pub const NvColorFormat_NvColorFormat_L1: NvColorFormat = 4462739713;
pub const NvColorFormat_NvColorFormat_L2: NvColorFormat = 4462739970;
pub const NvColorFormat_NvColorFormat_L4: NvColorFormat = 4462740228;
pub const NvColorFormat_NvColorFormat_L8: NvColorFormat = 4462740488;
pub const NvColorFormat_NvColorFormat_L16: NvColorFormat = 4462742032;
pub const NvColorFormat_NvColorFormat_L32: NvColorFormat = 4462746656;
pub const NvColorFormat_NvColorFormat_Float_L16: NvColorFormat = 4462758416;
pub const NvColorFormat_NvColorFormat_B5G6R5: NvColorFormat = 4463399440;
pub const NvColorFormat_NvColorFormat_B6G5R5: NvColorFormat = 4463399696;
pub const NvColorFormat_NvColorFormat_B5G5R5X1: NvColorFormat = 4463400976;
pub const NvColorFormat_NvColorFormat_B8_G8_R8: NvColorFormat = 4463401240;
pub const NvColorFormat_NvColorFormat_B8G8R8X8: NvColorFormat = 4463403296;
pub const NvColorFormat_NvColorFormat_Float_B10G11R11: NvColorFormat = 4463418912;
pub const NvColorFormat_NvColorFormat_X1B5G5R5: NvColorFormat = 4468184080;
pub const NvColorFormat_NvColorFormat_X8B8G8R8: NvColorFormat = 4468187424;
pub const NvColorFormat_NvColorFormat_X16B16G16R16: NvColorFormat = 4468188992;
pub const NvColorFormat_NvColorFormat_Float_X16B16G16R16: NvColorFormat = 4468205376;
pub const NvColorFormat_NvColorFormat_R3G3B2: NvColorFormat = 4471653896;
pub const NvColorFormat_NvColorFormat_R5G5B6: NvColorFormat = 4471656720;
pub const NvColorFormat_NvColorFormat_R5G6B5: NvColorFormat = 4471656976;
pub const NvColorFormat_NvColorFormat_R5G5B5X1: NvColorFormat = 4471658512;
pub const NvColorFormat_NvColorFormat_R8_G8_B8: NvColorFormat = 4471658776;
pub const NvColorFormat_NvColorFormat_R8G8B8X8: NvColorFormat = 4471660832;
pub const NvColorFormat_NvColorFormat_X1R5G5B5: NvColorFormat = 4476441616;
pub const NvColorFormat_NvColorFormat_X8R8G8B8: NvColorFormat = 4476444960;
pub const NvColorFormat_NvColorFormat_RG8: NvColorFormat = 4480044560;
pub const NvColorFormat_NvColorFormat_R16G16: NvColorFormat = 4480048416;
pub const NvColorFormat_NvColorFormat_Float_R16G16: NvColorFormat = 4480064800;
pub const NvColorFormat_NvColorFormat_R8: NvColorFormat = 4481614856;
pub const NvColorFormat_NvColorFormat_R16: NvColorFormat = 4481616400;
pub const NvColorFormat_NvColorFormat_Float_R16: NvColorFormat = 4481632784;
pub const NvColorFormat_NvColorFormat_A2B10G10R10_sRGB: NvColorFormat = 8595382304;
pub const NvColorFormat_NvColorFormat_A8B8G8R8_sRGB: NvColorFormat = 8595382560;
pub const NvColorFormat_NvColorFormat_A16B16G16R16_sRGB: NvColorFormat = 8595384128;
pub const NvColorFormat_NvColorFormat_A2R10G10B10_sRGB: NvColorFormat = 8603639840;
pub const NvColorFormat_NvColorFormat_B10G10R10A2_sRGB: NvColorFormat = 8691262240;
pub const NvColorFormat_NvColorFormat_R10G10B10A2_sRGB: NvColorFormat = 8699519776;
pub const NvColorFormat_NvColorFormat_X8B8G8R8_sRGB: NvColorFormat = 8763154720;
pub const NvColorFormat_NvColorFormat_X16B16G16R16_sRGB: NvColorFormat = 8763156288;
pub const NvColorFormat_NvColorFormat_A2B10G10R10_709: NvColorFormat = 12890349600;
pub const NvColorFormat_NvColorFormat_A8B8G8R8_709: NvColorFormat = 12890349856;
pub const NvColorFormat_NvColorFormat_A16B16G16R16_709: NvColorFormat = 12890351424;
pub const NvColorFormat_NvColorFormat_A2R10G10B10_709: NvColorFormat = 12898607136;
pub const NvColorFormat_NvColorFormat_B10G10R10A2_709: NvColorFormat = 12986229536;
pub const NvColorFormat_NvColorFormat_R10G10B10A2_709: NvColorFormat = 12994487072;
pub const NvColorFormat_NvColorFormat_X8B8G8R8_709: NvColorFormat = 13058122016;
pub const NvColorFormat_NvColorFormat_X16B16G16R16_709: NvColorFormat = 13058123584;
pub const NvColorFormat_NvColorFormat_A2B10G10R10_709_Linear: NvColorFormat = 17185316896;
pub const NvColorFormat_NvColorFormat_A8B8G8R8_709_Linear: NvColorFormat = 17185317152;
pub const NvColorFormat_NvColorFormat_A16B16G16R16_709_Linear: NvColorFormat = 17185318720;
pub const NvColorFormat_NvColorFormat_A2R10G10B10_709_Linear: NvColorFormat = 17193574432;
pub const NvColorFormat_NvColorFormat_B10G10R10A2_709_Linear: NvColorFormat = 17281196832;
pub const NvColorFormat_NvColorFormat_R10G10B10A2_709_Linear: NvColorFormat = 17289454368;
pub const NvColorFormat_NvColorFormat_X8B8G8R8_709_Linear: NvColorFormat = 17353089312;
pub const NvColorFormat_NvColorFormat_X16B16G16R16_709_Linear: NvColorFormat = 17353090880;
pub const NvColorFormat_NvColorFormat_Float_A16B16G16R16_scRGB_Linear: NvColorFormat = 21480302400;
pub const NvColorFormat_NvColorFormat_A2B10G10R10_2020: NvColorFormat = 25775251488;
pub const NvColorFormat_NvColorFormat_A8B8G8R8_2020: NvColorFormat = 25775251744;
pub const NvColorFormat_NvColorFormat_A16B16G16R16_2020: NvColorFormat = 25775253312;
pub const NvColorFormat_NvColorFormat_A2R10G10B10_2020: NvColorFormat = 25783509024;
pub const NvColorFormat_NvColorFormat_B10G10R10A2_2020: NvColorFormat = 25871131424;
pub const NvColorFormat_NvColorFormat_R10G10B10A2_2020: NvColorFormat = 25879388960;
pub const NvColorFormat_NvColorFormat_X8B8G8R8_2020: NvColorFormat = 25943023904;
pub const NvColorFormat_NvColorFormat_X16B16G16R16_2020: NvColorFormat = 25943025472;
pub const NvColorFormat_NvColorFormat_A2B10G10R10_2020_Linear: NvColorFormat = 30070218784;
pub const NvColorFormat_NvColorFormat_A8B8G8R8_2020_Linear: NvColorFormat = 30070219040;
pub const NvColorFormat_NvColorFormat_A16B16G16R16_2020_Linear: NvColorFormat = 30070220608;
pub const NvColorFormat_NvColorFormat_Float_A16B16G16R16_2020_Linear: NvColorFormat = 30070236992;
pub const NvColorFormat_NvColorFormat_A2R10G10B10_2020_Linear: NvColorFormat = 30078476320;
pub const NvColorFormat_NvColorFormat_B10G10R10A2_2020_Linear: NvColorFormat = 30166098720;
pub const NvColorFormat_NvColorFormat_R10G10B10A2_2020_Linear: NvColorFormat = 30174356256;
pub const NvColorFormat_NvColorFormat_X8B8G8R8_2020_Linear: NvColorFormat = 30237991200;
pub const NvColorFormat_NvColorFormat_X16B16G16R16_2020_Linear: NvColorFormat = 30237992768;
pub const NvColorFormat_NvColorFormat_Float_A16B16G16R16_2020_PQ: NvColorFormat = 34365204288;
pub const NvColorFormat_NvColorFormat_A4I4: NvColorFormat = 38673646856;
pub const NvColorFormat_NvColorFormat_A8I8: NvColorFormat = 38673649168;
pub const NvColorFormat_NvColorFormat_I4A4: NvColorFormat = 38707135752;
pub const NvColorFormat_NvColorFormat_I8A8: NvColorFormat = 38707138064;
pub const NvColorFormat_NvColorFormat_I1: NvColorFormat = 38807798017;
pub const NvColorFormat_NvColorFormat_I2: NvColorFormat = 38807798274;
pub const NvColorFormat_NvColorFormat_I4: NvColorFormat = 38807798532;
pub const NvColorFormat_NvColorFormat_I8: NvColorFormat = 38807798792;
pub const NvColorFormat_NvColorFormat_A8Y8U8V8: NvColorFormat = 42963378464;
pub const NvColorFormat_NvColorFormat_A16Y16U16V16: NvColorFormat = 42963380032;
pub const NvColorFormat_NvColorFormat_Y8U8V8A8: NvColorFormat = 43059257632;
pub const NvColorFormat_NvColorFormat_V8_U8: NvColorFormat = 43084678928;
pub const NvColorFormat_NvColorFormat_V8U8: NvColorFormat = 43084680720;
pub const NvColorFormat_NvColorFormat_V10U10: NvColorFormat = 43085210144;
pub const NvColorFormat_NvColorFormat_V12U12: NvColorFormat = 43085210656;
pub const NvColorFormat_NvColorFormat_V8: NvColorFormat = 43086251016;
pub const NvColorFormat_NvColorFormat_V10: NvColorFormat = 43086253840;
pub const NvColorFormat_NvColorFormat_V12: NvColorFormat = 43086254096;
pub const NvColorFormat_NvColorFormat_U8_V8: NvColorFormat = 43088348944;
pub const NvColorFormat_NvColorFormat_U8V8: NvColorFormat = 43088350736;
pub const NvColorFormat_NvColorFormat_U10V10: NvColorFormat = 43092550176;
pub const NvColorFormat_NvColorFormat_U12V12: NvColorFormat = 43092550688;
pub const NvColorFormat_NvColorFormat_U8: NvColorFormat = 43100931080;
pub const NvColorFormat_NvColorFormat_U10: NvColorFormat = 43100933904;
pub const NvColorFormat_NvColorFormat_U12: NvColorFormat = 43100934160;
pub const NvColorFormat_NvColorFormat_Y8: NvColorFormat = 43102766088;
pub const NvColorFormat_NvColorFormat_Y10: NvColorFormat = 43102768912;
pub const NvColorFormat_NvColorFormat_Y12: NvColorFormat = 43102769168;
pub const NvColorFormat_NvColorFormat_YVYU: NvColorFormat = 43122690064;
pub const NvColorFormat_NvColorFormat_VYUY: NvColorFormat = 43122690320;
pub const NvColorFormat_NvColorFormat_YUYV: NvColorFormat = 43126360080;
pub const NvColorFormat_NvColorFormat_UYVY: NvColorFormat = 43126360336;
pub const NvColorFormat_NvColorFormat_Y8_U8_V8: NvColorFormat = 43126364440;
pub const NvColorFormat_NvColorFormat_V8_U8_RR: NvColorFormat = 47379646224;
pub const NvColorFormat_NvColorFormat_V8U8_RR: NvColorFormat = 47379648016;
pub const NvColorFormat_NvColorFormat_V8_RR: NvColorFormat = 47381218312;
pub const NvColorFormat_NvColorFormat_U8_V8_RR: NvColorFormat = 47383316240;
pub const NvColorFormat_NvColorFormat_U8V8_RR: NvColorFormat = 47383318032;
pub const NvColorFormat_NvColorFormat_U8_RR: NvColorFormat = 47395898376;
pub const NvColorFormat_NvColorFormat_Y8_RR: NvColorFormat = 47397733384;
pub const NvColorFormat_NvColorFormat_V8_U8_ER: NvColorFormat = 51674613520;
pub const NvColorFormat_NvColorFormat_V8U8_ER: NvColorFormat = 51674615312;
pub const NvColorFormat_NvColorFormat_V8_ER: NvColorFormat = 51676185608;
pub const NvColorFormat_NvColorFormat_U8_V8_ER: NvColorFormat = 51678283536;
pub const NvColorFormat_NvColorFormat_U8V8_ER: NvColorFormat = 51678285328;
pub const NvColorFormat_NvColorFormat_U8_ER: NvColorFormat = 51690865672;
pub const NvColorFormat_NvColorFormat_Y8_ER: NvColorFormat = 51692700680;
pub const NvColorFormat_NvColorFormat_V8_U8_709: NvColorFormat = 55969580816;
pub const NvColorFormat_NvColorFormat_V8U8_709: NvColorFormat = 55969582608;
pub const NvColorFormat_NvColorFormat_V10U10_709: NvColorFormat = 55970112032;
pub const NvColorFormat_NvColorFormat_V12U12_709: NvColorFormat = 55970112544;
pub const NvColorFormat_NvColorFormat_V8_709: NvColorFormat = 55971152904;
pub const NvColorFormat_NvColorFormat_V10_709: NvColorFormat = 55971155728;
pub const NvColorFormat_NvColorFormat_V12_709: NvColorFormat = 55971155984;
pub const NvColorFormat_NvColorFormat_U8_V8_709: NvColorFormat = 55973250832;
pub const NvColorFormat_NvColorFormat_U8V8_709: NvColorFormat = 55973252624;
pub const NvColorFormat_NvColorFormat_U10V10_709: NvColorFormat = 55977452064;
pub const NvColorFormat_NvColorFormat_U12V12_709: NvColorFormat = 55977452576;
pub const NvColorFormat_NvColorFormat_U8_709: NvColorFormat = 55985832968;
pub const NvColorFormat_NvColorFormat_U10_709: NvColorFormat = 55985835792;
pub const NvColorFormat_NvColorFormat_U12_709: NvColorFormat = 55985836048;
pub const NvColorFormat_NvColorFormat_Y8_709: NvColorFormat = 55987667976;
pub const NvColorFormat_NvColorFormat_Y10_709: NvColorFormat = 55987670800;
pub const NvColorFormat_NvColorFormat_Y12_709: NvColorFormat = 55987671056;
pub const NvColorFormat_NvColorFormat_V8_U8_709_ER: NvColorFormat = 60264548112;
pub const NvColorFormat_NvColorFormat_V8U8_709_ER: NvColorFormat = 60264549904;
pub const NvColorFormat_NvColorFormat_V10U10_709_ER: NvColorFormat = 60265079328;
pub const NvColorFormat_NvColorFormat_V12U12_709_ER: NvColorFormat = 60265079840;
pub const NvColorFormat_NvColorFormat_V8_709_ER: NvColorFormat = 60266120200;
pub const NvColorFormat_NvColorFormat_V10_709_ER: NvColorFormat = 60266123024;
pub const NvColorFormat_NvColorFormat_V12_709_ER: NvColorFormat = 60266123280;
pub const NvColorFormat_NvColorFormat_U8_V8_709_ER: NvColorFormat = 60268218128;
pub const NvColorFormat_NvColorFormat_U8V8_709_ER: NvColorFormat = 60268219920;
pub const NvColorFormat_NvColorFormat_U10V10_709_ER: NvColorFormat = 60272419360;
pub const NvColorFormat_NvColorFormat_U12V12_709_ER: NvColorFormat = 60272419872;
pub const NvColorFormat_NvColorFormat_U8_709_ER: NvColorFormat = 60280800264;
pub const NvColorFormat_NvColorFormat_U10_709_ER: NvColorFormat = 60280803088;
pub const NvColorFormat_NvColorFormat_U12_709_ER: NvColorFormat = 60280803344;
pub const NvColorFormat_NvColorFormat_Y8_709_ER: NvColorFormat = 60282635272;
pub const NvColorFormat_NvColorFormat_Y10_709_ER: NvColorFormat = 60282638096;
pub const NvColorFormat_NvColorFormat_Y12_709_ER: NvColorFormat = 60282638352;
pub const NvColorFormat_NvColorFormat_V10U10_2020: NvColorFormat = 64560046624;
pub const NvColorFormat_NvColorFormat_V12U12_2020: NvColorFormat = 64560047136;
pub const NvColorFormat_NvColorFormat_V10_2020: NvColorFormat = 64561090320;
pub const NvColorFormat_NvColorFormat_V12_2020: NvColorFormat = 64561090576;
pub const NvColorFormat_NvColorFormat_U10V10_2020: NvColorFormat = 64567386656;
pub const NvColorFormat_NvColorFormat_U12V12_2020: NvColorFormat = 64567387168;
pub const NvColorFormat_NvColorFormat_U10_2020: NvColorFormat = 64575770384;
pub const NvColorFormat_NvColorFormat_U12_2020: NvColorFormat = 64575770640;
pub const NvColorFormat_NvColorFormat_Y10_2020: NvColorFormat = 64577605392;
pub const NvColorFormat_NvColorFormat_Y12_2020: NvColorFormat = 64577605648;
pub const NvColorFormat_NvColorFormat_Bayer8RGGB: NvColorFormat = 68872569864;
pub const NvColorFormat_NvColorFormat_Bayer16RGGB: NvColorFormat = 68872571408;
pub const NvColorFormat_NvColorFormat_BayerS16RGGB: NvColorFormat = 68872604176;
pub const NvColorFormat_NvColorFormat_X2Bayer14RGGB: NvColorFormat = 68872637200;
pub const NvColorFormat_NvColorFormat_X4Bayer12RGGB: NvColorFormat = 68872637456;
pub const NvColorFormat_NvColorFormat_X6Bayer10RGGB: NvColorFormat = 68872637712;
pub const NvColorFormat_NvColorFormat_Bayer8BGGR: NvColorFormat = 73167537160;
pub const NvColorFormat_NvColorFormat_Bayer16BGGR: NvColorFormat = 73167538704;
pub const NvColorFormat_NvColorFormat_BayerS16BGGR: NvColorFormat = 73167571472;
pub const NvColorFormat_NvColorFormat_X2Bayer14BGGR: NvColorFormat = 73167604496;
pub const NvColorFormat_NvColorFormat_X4Bayer12BGGR: NvColorFormat = 73167604752;
pub const NvColorFormat_NvColorFormat_X6Bayer10BGGR: NvColorFormat = 73167605008;
pub const NvColorFormat_NvColorFormat_Bayer8GRBG: NvColorFormat = 77462504456;
pub const NvColorFormat_NvColorFormat_Bayer16GRBG: NvColorFormat = 77462506000;
pub const NvColorFormat_NvColorFormat_BayerS16GRBG: NvColorFormat = 77462538768;
pub const NvColorFormat_NvColorFormat_X2Bayer14GRBG: NvColorFormat = 77462571792;
pub const NvColorFormat_NvColorFormat_X4Bayer12GRBG: NvColorFormat = 77462572048;
pub const NvColorFormat_NvColorFormat_X6Bayer10GRBG: NvColorFormat = 77462572304;
pub const NvColorFormat_NvColorFormat_Bayer8GBRG: NvColorFormat = 81757471752;
pub const NvColorFormat_NvColorFormat_Bayer16GBRG: NvColorFormat = 81757473296;
pub const NvColorFormat_NvColorFormat_BayerS16GBRG: NvColorFormat = 81757506064;
pub const NvColorFormat_NvColorFormat_X2Bayer14GBRG: NvColorFormat = 81757539088;
pub const NvColorFormat_NvColorFormat_X4Bayer12GBRG: NvColorFormat = 81757539344;
pub const NvColorFormat_NvColorFormat_X6Bayer10GBRG: NvColorFormat = 81757539600;
pub const NvColorFormat_NvColorFormat_XYZ: NvColorFormat = 86076057152;
pub type NvColorFormat = u64;
#[repr(C)]
pub struct nvioctl_gpu_characteristics {
    pub arch: u32,
    pub impl_: u32,
    pub rev: u32,
    pub num_gpc: u32,
    pub L2_cache_size: u64,
    pub on_board_video_memory_size: u64,
    pub num_tpc_per_gpc: u32,
    pub bus_type: u32,
    pub big_page_size: u32,
    pub compression_page_size: u32,
    pub pde_coverage_bit_count: u32,
    pub available_big_page_sizes: u32,
    pub gpc_mask: u32,
    pub sm_arch_sm_version: u32,
    pub sm_arch_spa_version: u32,
    pub sm_arch_warp_count: u32,
    pub gpu_va_bit_count: u32,
    pub reserved: u32,
    pub flags: u64,
    pub twod_class: u32,
    pub threed_class: u32,
    pub compute_class: u32,
    pub gpfifo_class: u32,
    pub inline_to_memory_class: u32,
    pub dma_copy_class: u32,
    pub max_fbps_count: u32,
    pub fbp_en_mask: u32,
    pub max_ltc_per_fbp: u32,
    pub max_lts_per_ltc: u32,
    pub max_tex_per_tpc: u32,
    pub max_gpc_count: u32,
    pub rop_l2_en_mask_0: u32,
    pub rop_l2_en_mask_1: u32,
    pub chipname: u64,
    pub gr_compbit_store_base_hw: u64,
}
#[test]
fn bindgen_test_layout_nvioctl_gpu_characteristics() {
    assert_eq!(
        ::core::mem::size_of::<nvioctl_gpu_characteristics>(),
        160usize,
        concat!("Size of: ", stringify!(nvioctl_gpu_characteristics))
    );
    assert_eq!(
        ::core::mem::align_of::<nvioctl_gpu_characteristics>(),
        8usize,
        concat!("Alignment of ", stringify!(nvioctl_gpu_characteristics))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).arch as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(arch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).impl_ as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).rev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(rev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).num_gpc as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(num_gpc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).L2_cache_size as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(L2_cache_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).on_board_video_memory_size
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(on_board_video_memory_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).num_tpc_per_gpc as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(num_tpc_per_gpc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).bus_type as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(bus_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).big_page_size as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(big_page_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).compression_page_size
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(compression_page_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).pde_coverage_bit_count
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(pde_coverage_bit_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).available_big_page_sizes
                as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(available_big_page_sizes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).gpc_mask as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(gpc_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).sm_arch_sm_version as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(sm_arch_sm_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).sm_arch_spa_version as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(sm_arch_spa_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).sm_arch_warp_count as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(sm_arch_warp_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).gpu_va_bit_count as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(gpu_va_bit_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).reserved as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).flags as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).twod_class as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(twod_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).threed_class as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(threed_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).compute_class as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(compute_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).gpfifo_class as *const _
                as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(gpfifo_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).inline_to_memory_class
                as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(inline_to_memory_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).dma_copy_class as *const _
                as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(dma_copy_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).max_fbps_count as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(max_fbps_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).fbp_en_mask as *const _
                as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(fbp_en_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).max_ltc_per_fbp as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(max_ltc_per_fbp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).max_lts_per_ltc as *const _
                as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(max_lts_per_ltc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).max_tex_per_tpc as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(max_tex_per_tpc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).max_gpc_count as *const _
                as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(max_gpc_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).rop_l2_en_mask_0 as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(rop_l2_en_mask_0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).rop_l2_en_mask_1 as *const _
                as usize
        },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(rop_l2_en_mask_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).chipname as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(chipname)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).gr_compbit_store_base_hw
                as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(gr_compbit_store_base_hw)
        )
    );
}
#[repr(C)]
pub struct nvioctl_va_region {
    pub offset: u64,
    pub page_size: u32,
    pub pad: u32,
    pub pages: u64,
}
#[test]
fn bindgen_test_layout_nvioctl_va_region() {
    assert_eq!(
        ::core::mem::size_of::<nvioctl_va_region>(),
        24usize,
        concat!("Size of: ", stringify!(nvioctl_va_region))
    );
    assert_eq!(
        ::core::mem::align_of::<nvioctl_va_region>(),
        8usize,
        concat!("Alignment of ", stringify!(nvioctl_va_region))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvioctl_va_region>())).offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_va_region),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvioctl_va_region>())).page_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_va_region),
            "::",
            stringify!(page_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvioctl_va_region>())).pad as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_va_region),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvioctl_va_region>())).pages as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_va_region),
            "::",
            stringify!(pages)
        )
    );
}
#[repr(C)]
pub struct nvioctl_l2_state {
    pub mask: u32,
    pub flush: u32,
}
#[test]
fn bindgen_test_layout_nvioctl_l2_state() {
    assert_eq!(
        ::core::mem::size_of::<nvioctl_l2_state>(),
        8usize,
        concat!("Size of: ", stringify!(nvioctl_l2_state))
    );
    assert_eq!(
        ::core::mem::align_of::<nvioctl_l2_state>(),
        4usize,
        concat!("Alignment of ", stringify!(nvioctl_l2_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvioctl_l2_state>())).mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_l2_state),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvioctl_l2_state>())).flush as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_l2_state),
            "::",
            stringify!(flush)
        )
    );
}
#[repr(C)]
pub struct nvioctl_fence {
    pub id: u32,
    pub value: u32,
}
#[test]
fn bindgen_test_layout_nvioctl_fence() {
    assert_eq!(
        ::core::mem::size_of::<nvioctl_fence>(),
        8usize,
        concat!("Size of: ", stringify!(nvioctl_fence))
    );
    assert_eq!(
        ::core::mem::align_of::<nvioctl_fence>(),
        4usize,
        concat!("Alignment of ", stringify!(nvioctl_fence))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvioctl_fence>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_fence),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvioctl_fence>())).value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_fence),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
pub struct nvioctl_gpfifo_entry {
    pub __bindgen_anon_1: nvioctl_gpfifo_entry__bindgen_ty_1,
}
#[repr(C)]
pub struct nvioctl_gpfifo_entry__bindgen_ty_1 {
    pub desc: __BindgenUnionField<u64>,
    pub desc32: __BindgenUnionField<[u32; 2usize]>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_nvioctl_gpfifo_entry__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<nvioctl_gpfifo_entry__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(nvioctl_gpfifo_entry__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<nvioctl_gpfifo_entry__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(nvioctl_gpfifo_entry__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpfifo_entry__bindgen_ty_1>())).desc as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpfifo_entry__bindgen_ty_1),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpfifo_entry__bindgen_ty_1>())).desc32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpfifo_entry__bindgen_ty_1),
            "::",
            stringify!(desc32)
        )
    );
}
#[test]
fn bindgen_test_layout_nvioctl_gpfifo_entry() {
    assert_eq!(
        ::core::mem::size_of::<nvioctl_gpfifo_entry>(),
        8usize,
        concat!("Size of: ", stringify!(nvioctl_gpfifo_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<nvioctl_gpfifo_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(nvioctl_gpfifo_entry))
    );
}
pub const nvioctl_map_param_NvMapParam_Size: nvioctl_map_param = 1;
pub const nvioctl_map_param_NvMapParam_Alignment: nvioctl_map_param = 2;
pub const nvioctl_map_param_NvMapParam_Base: nvioctl_map_param = 3;
pub const nvioctl_map_param_NvMapParam_Heap: nvioctl_map_param = 4;
pub const nvioctl_map_param_NvMapParam_Kind: nvioctl_map_param = 5;
pub type nvioctl_map_param = u32;
pub use self::nvioctl_map_param as NvMapParam;
pub const nvioctl_channel_obj_classnum_NvClassNumber_2D: nvioctl_channel_obj_classnum = 36909;
pub const nvioctl_channel_obj_classnum_NvClassNumber_3D: nvioctl_channel_obj_classnum = 45463;
pub const nvioctl_channel_obj_classnum_NvClassNumber_Compute: nvioctl_channel_obj_classnum = 45504;
pub const nvioctl_channel_obj_classnum_NvClassNumber_Kepler: nvioctl_channel_obj_classnum = 41280;
pub const nvioctl_channel_obj_classnum_NvClassNumber_DMA: nvioctl_channel_obj_classnum = 45237;
pub const nvioctl_channel_obj_classnum_NvClassNumber_ChannelGpfifo: nvioctl_channel_obj_classnum =
    45167;
pub type nvioctl_channel_obj_classnum = u32;
pub use self::nvioctl_channel_obj_classnum as NvClassNumber;
pub const nvioctl_channel_priority_NvChannelPriority_Low: nvioctl_channel_priority = 50;
pub const nvioctl_channel_priority_NvChannelPriority_Medium: nvioctl_channel_priority = 100;
pub const nvioctl_channel_priority_NvChannelPriority_High: nvioctl_channel_priority = 150;
pub type nvioctl_channel_priority = u32;
pub use self::nvioctl_channel_priority as NvChannelPriority;
pub const NvZcullConfig_NvZcullConfig_Global: NvZcullConfig = 0;
pub const NvZcullConfig_NvZcullConfig_NoCtxSwitch: NvZcullConfig = 1;
pub const NvZcullConfig_NvZcullConfig_SeparateBuffer: NvZcullConfig = 2;
pub const NvZcullConfig_NvZcullConfig_PartOfRegularBuffer: NvZcullConfig = 3;
pub type NvZcullConfig = u32;
pub const NvAllocSpaceFlags_NvAllocSpaceFlags_FixedOffset: NvAllocSpaceFlags = 1;
pub const NvAllocSpaceFlags_NvAllocSpaceFlags_Sparse: NvAllocSpaceFlags = 2;
pub type NvAllocSpaceFlags = u32;
pub const NvMapBufferFlags_NvMapBufferFlags_FixedOffset: NvMapBufferFlags = 1;
pub const NvMapBufferFlags_NvMapBufferFlags_IsCacheable: NvMapBufferFlags = 4;
pub const NvMapBufferFlags_NvMapBufferFlags_Modify: NvMapBufferFlags = 256;
pub type NvMapBufferFlags = u32;
pub const NvErrorType_NvErrorType_FifoErrorIdleTimeout: NvErrorType = 8;
pub const NvErrorType_NvErrorType_GrErrorSwNotify: NvErrorType = 13;
pub const NvErrorType_NvErrorType_GrSemaphoreTimeout: NvErrorType = 24;
pub const NvErrorType_NvErrorType_GrIllegalNotify: NvErrorType = 25;
pub const NvErrorType_NvErrorType_FifoErrorMmuErrFlt: NvErrorType = 31;
pub const NvErrorType_NvErrorType_PbdmaError: NvErrorType = 32;
pub const NvErrorType_NvErrorType_ResetChannelVerifError: NvErrorType = 43;
pub const NvErrorType_NvErrorType_PbdmaPushbufferCrcMismatch: NvErrorType = 80;
pub type NvErrorType = u32;
#[repr(C)]
pub struct NvError {
    pub tickstamp: u64,
    pub error_type: u32,
    pub unk16: u16,
    pub status: u16,
}
#[test]
fn bindgen_test_layout_NvError() {
    assert_eq!(
        ::core::mem::size_of::<NvError>(),
        16usize,
        concat!("Size of: ", stringify!(NvError))
    );
    assert_eq!(
        ::core::mem::align_of::<NvError>(),
        8usize,
        concat!("Alignment of ", stringify!(NvError))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvError>())).tickstamp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvError),
            "::",
            stringify!(tickstamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvError>())).error_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvError),
            "::",
            stringify!(error_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvError>())).unk16 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NvError),
            "::",
            stringify!(unk16)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvError>())).status as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(NvError),
            "::",
            stringify!(status)
        )
    );
}
extern "C" {
    pub fn nvioctlNvhostCtrl_SyncptRead(fd: u32, id: u32, out: *mut u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostCtrl_SyncptIncr(fd: u32, id: u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostCtrl_SyncptWait(fd: u32, id: u32, threshold: u32, timeout: u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostCtrl_EventSignal(fd: u32, event_id: u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostCtrl_EventWait(
        fd: u32,
        syncpt_id: u32,
        threshold: u32,
        timeout: s32,
        event_id: u32,
        out: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostCtrl_EventWaitAsync(
        fd: u32,
        syncpt_id: u32,
        threshold: u32,
        timeout: s32,
        event_id: u32,
    ) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostCtrl_EventRegister(fd: u32, event_id: u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostCtrl_EventUnregister(fd: u32, event_id: u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostCtrlGpu_ZCullGetCtxSize(fd: u32, out: *mut u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostCtrlGpu_ZCullGetInfo(fd: u32, out: *mut u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostCtrlGpu_GetCharacteristics(
        fd: u32,
        out: *mut nvioctl_gpu_characteristics,
    ) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostCtrlGpu_GetTpcMasks(fd: u32, inval: u32, out: *mut u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostCtrlGpu_GetL2State(fd: u32, out: *mut nvioctl_l2_state) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostAsGpu_BindChannel(fd: u32, channel_fd: u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostAsGpu_AllocSpace(
        fd: u32,
        pages: u32,
        page_size: u32,
        flags: u32,
        align_or_offset: u64,
        offset: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostAsGpu_FreeSpace(fd: u32, offset: u64, pages: u32, page_size: u32)
        -> Result;
}
extern "C" {
    pub fn nvioctlNvhostAsGpu_MapBufferEx(
        fd: u32,
        flags: u32,
        kind: u32,
        nvmap_handle: u32,
        page_size: u32,
        buffer_offset: u64,
        mapping_size: u64,
        input_offset: u64,
        offset: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostAsGpu_UnmapBuffer(fd: u32, offset: u64) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostAsGpu_GetVARegions(fd: u32, regions: *mut nvioctl_va_region) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostAsGpu_InitializeEx(fd: u32, flags: u32, big_page_size: u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvmap_Create(fd: u32, size: u32, nvmap_handle: *mut u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvmap_FromId(fd: u32, id: u32, nvmap_handle: *mut u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvmap_Alloc(
        fd: u32,
        nvmap_handle: u32,
        heapmask: u32,
        flags: u32,
        align: u32,
        kind: u8,
        addr: *mut ctypes::c_void,
    ) -> Result;
}
extern "C" {
    pub fn nvioctlNvmap_Free(fd: u32, nvmap_handle: u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvmap_Param(
        fd: u32,
        nvmap_handle: u32,
        param: NvMapParam,
        result: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn nvioctlNvmap_GetId(fd: u32, nvmap_handle: u32, id: *mut u32) -> Result;
}
extern "C" {
    pub fn nvioctlChannel_SetNvmapFd(fd: u32, nvmap_fd: u32) -> Result;
}
extern "C" {
    pub fn nvioctlChannel_SubmitGpfifo(
        fd: u32,
        entries: *mut nvioctl_gpfifo_entry,
        num_entries: u32,
        flags: u32,
        fence_inout: *mut nvioctl_fence,
    ) -> Result;
}
extern "C" {
    pub fn nvioctlChannel_KickoffPb(
        fd: u32,
        entries: *mut nvioctl_gpfifo_entry,
        num_entries: u32,
        flags: u32,
        fence_inout: *mut nvioctl_fence,
    ) -> Result;
}
extern "C" {
    pub fn nvioctlChannel_AllocObjCtx(
        fd: u32,
        class_num: u32,
        flags: u32,
        id_out: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn nvioctlChannel_ZCullBind(fd: u32, gpu_va: u64, mode: u32) -> Result;
}
extern "C" {
    pub fn nvioctlChannel_SetErrorNotifier(fd: u32, enable: u32) -> Result;
}
extern "C" {
    pub fn nvioctlChannel_GetErrorNotification(fd: u32, out: *mut NvError) -> Result;
}
extern "C" {
    pub fn nvioctlChannel_SetPriority(fd: u32, priority: u32) -> Result;
}
extern "C" {
    pub fn nvioctlChannel_SetTimeout(fd: u32, timeout: u32) -> Result;
}
extern "C" {
    pub fn nvioctlChannel_AllocGpfifoEx2(
        fd: u32,
        num_entries: u32,
        flags: u32,
        unk0: u32,
        unk1: u32,
        unk2: u32,
        unk3: u32,
        fence_out: *mut nvioctl_fence,
    ) -> Result;
}
extern "C" {
    pub fn nvioctlChannel_SetUserData(fd: u32, addr: *mut ctypes::c_void) -> Result;
}
pub type NvFence = nvioctl_fence;
#[repr(C)]
pub struct NvMultiFence {
    pub num_fences: u32,
    pub fences: [NvFence; 4usize],
}
#[test]
fn bindgen_test_layout_NvMultiFence() {
    assert_eq!(
        ::core::mem::size_of::<NvMultiFence>(),
        36usize,
        concat!("Size of: ", stringify!(NvMultiFence))
    );
    assert_eq!(
        ::core::mem::align_of::<NvMultiFence>(),
        4usize,
        concat!("Alignment of ", stringify!(NvMultiFence))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvMultiFence>())).num_fences as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvMultiFence),
            "::",
            stringify!(num_fences)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvMultiFence>())).fences as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvMultiFence),
            "::",
            stringify!(fences)
        )
    );
}
extern "C" {
    pub fn nvFenceInit() -> Result;
}
extern "C" {
    pub fn nvFenceExit();
}
extern "C" {
    pub fn nvFenceWait(f: *mut NvFence, timeout_us: s32) -> Result;
}
extern "C" {
    pub fn nvMultiFenceWait(mf: *mut NvMultiFence, timeout_us: s32) -> Result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BqRect {
    pub left: s32,
    pub top: s32,
    pub right: s32,
    pub bottom: s32,
}
#[test]
fn bindgen_test_layout_BqRect() {
    assert_eq!(
        ::core::mem::size_of::<BqRect>(),
        16usize,
        concat!("Size of: ", stringify!(BqRect))
    );
    assert_eq!(
        ::core::mem::align_of::<BqRect>(),
        4usize,
        concat!("Alignment of ", stringify!(BqRect))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqRect>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BqRect),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqRect>())).top as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BqRect),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqRect>())).right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BqRect),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqRect>())).bottom as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BqRect),
            "::",
            stringify!(bottom)
        )
    );
}
#[repr(C)]
pub struct BqBufferInput {
    pub __bindgen_anon_1: BqBufferInput__bindgen_ty_1,
    pub isAutoTimestamp: s32,
    pub crop: BqRect,
    pub scalingMode: s32,
    pub transform: u32,
    pub stickyTransform: u32,
    pub unk: u32,
    pub swapInterval: u32,
    pub fence: NvMultiFence,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct BqBufferInput__bindgen_ty_1 {
    pub timestamp: s64,
}
#[test]
fn bindgen_test_layout_BqBufferInput__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<BqBufferInput__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(BqBufferInput__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<BqBufferInput__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(BqBufferInput__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqBufferInput__bindgen_ty_1>())).timestamp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BqBufferInput__bindgen_ty_1),
            "::",
            stringify!(timestamp)
        )
    );
}
#[test]
fn bindgen_test_layout_BqBufferInput() {
    assert_eq!(
        ::core::mem::size_of::<BqBufferInput>(),
        84usize,
        concat!("Size of: ", stringify!(BqBufferInput))
    );
    assert_eq!(
        ::core::mem::align_of::<BqBufferInput>(),
        4usize,
        concat!("Alignment of ", stringify!(BqBufferInput))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqBufferInput>())).isAutoTimestamp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BqBufferInput),
            "::",
            stringify!(isAutoTimestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqBufferInput>())).crop as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BqBufferInput),
            "::",
            stringify!(crop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqBufferInput>())).scalingMode as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(BqBufferInput),
            "::",
            stringify!(scalingMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqBufferInput>())).transform as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BqBufferInput),
            "::",
            stringify!(transform)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqBufferInput>())).stickyTransform as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(BqBufferInput),
            "::",
            stringify!(stickyTransform)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqBufferInput>())).unk as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BqBufferInput),
            "::",
            stringify!(unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqBufferInput>())).swapInterval as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(BqBufferInput),
            "::",
            stringify!(swapInterval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqBufferInput>())).fence as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(BqBufferInput),
            "::",
            stringify!(fence)
        )
    );
}
#[repr(C)]
pub struct BqBufferOutput {
    pub width: u32,
    pub height: u32,
    pub transformHint: u32,
    pub numPendingBuffers: u32,
}
#[test]
fn bindgen_test_layout_BqBufferOutput() {
    assert_eq!(
        ::core::mem::size_of::<BqBufferOutput>(),
        16usize,
        concat!("Size of: ", stringify!(BqBufferOutput))
    );
    assert_eq!(
        ::core::mem::align_of::<BqBufferOutput>(),
        4usize,
        concat!("Alignment of ", stringify!(BqBufferOutput))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqBufferOutput>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BqBufferOutput),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqBufferOutput>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BqBufferOutput),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqBufferOutput>())).transformHint as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BqBufferOutput),
            "::",
            stringify!(transformHint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqBufferOutput>())).numPendingBuffers as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BqBufferOutput),
            "::",
            stringify!(numPendingBuffers)
        )
    );
}
#[repr(C)]
pub struct BqGraphicBuffer {
    pub width: u32,
    pub height: u32,
    pub stride: u32,
    pub format: u32,
    pub usage: u32,
    pub native_handle: *mut NativeHandle,
}
#[test]
fn bindgen_test_layout_BqGraphicBuffer() {
    assert_eq!(
        ::core::mem::size_of::<BqGraphicBuffer>(),
        32usize,
        concat!("Size of: ", stringify!(BqGraphicBuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<BqGraphicBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(BqGraphicBuffer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqGraphicBuffer>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqGraphicBuffer>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqGraphicBuffer>())).stride as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqGraphicBuffer>())).format as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqGraphicBuffer>())).usage as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqGraphicBuffer>())).native_handle as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer),
            "::",
            stringify!(native_handle)
        )
    );
}
extern "C" {
    pub fn bqRequestBuffer(b: *mut Binder, bufferIdx: s32, buf: *mut BqGraphicBuffer) -> Result;
}
extern "C" {
    pub fn bqDequeueBuffer(
        b: *mut Binder,
        async: bool,
        width: u32,
        height: u32,
        format: s32,
        usage: u32,
        buf: *mut s32,
        fence: *mut NvMultiFence,
    ) -> Result;
}
extern "C" {
    pub fn bqDetachBuffer(b: *mut Binder, slot: s32) -> Result;
}
extern "C" {
    pub fn bqQueueBuffer(
        b: *mut Binder,
        buf: s32,
        input: *const BqBufferInput,
        output: *mut BqBufferOutput,
    ) -> Result;
}
extern "C" {
    pub fn bqCancelBuffer(b: *mut Binder, buf: s32, fence: *const NvMultiFence) -> Result;
}
extern "C" {
    pub fn bqQuery(b: *mut Binder, what: s32, value: *mut s32) -> Result;
}
extern "C" {
    pub fn bqConnect(
        b: *mut Binder,
        api: s32,
        producerControlledByApp: bool,
        output: *mut BqBufferOutput,
    ) -> Result;
}
extern "C" {
    pub fn bqDisconnect(b: *mut Binder, api: s32) -> Result;
}
extern "C" {
    pub fn bqSetPreallocatedBuffer(
        b: *mut Binder,
        buf: s32,
        input: *const BqGraphicBuffer,
    ) -> Result;
}
#[repr(C)]
pub struct NvSurface {
    pub width: u32,
    pub height: u32,
    pub color_format: NvColorFormat,
    pub layout: NvLayout,
    pub pitch: u32,
    pub unused: u32,
    pub offset: u32,
    pub kind: NvKind,
    pub block_height_log2: u32,
    pub scan: NvDisplayScanFormat,
    pub second_field_offset: u32,
    pub flags: u64,
    pub size: u64,
    pub unk: [u32; 6usize],
}
#[test]
fn bindgen_test_layout_NvSurface() {
    assert_eq!(
        ::core::mem::size_of::<NvSurface>(),
        88usize,
        concat!("Size of: ", stringify!(NvSurface))
    );
    assert_eq!(
        ::core::mem::align_of::<NvSurface>(),
        8usize,
        concat!("Alignment of ", stringify!(NvSurface))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvSurface>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvSurface),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvSurface>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvSurface),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvSurface>())).color_format as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvSurface),
            "::",
            stringify!(color_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvSurface>())).layout as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvSurface),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvSurface>())).pitch as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NvSurface),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvSurface>())).unused as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NvSurface),
            "::",
            stringify!(unused)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvSurface>())).offset as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(NvSurface),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvSurface>())).kind as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NvSurface),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvSurface>())).block_height_log2 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(NvSurface),
            "::",
            stringify!(block_height_log2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvSurface>())).scan as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NvSurface),
            "::",
            stringify!(scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvSurface>())).second_field_offset as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(NvSurface),
            "::",
            stringify!(second_field_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvSurface>())).flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NvSurface),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvSurface>())).size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NvSurface),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvSurface>())).unk as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NvSurface),
            "::",
            stringify!(unk)
        )
    );
}
#[repr(C)]
pub struct NvGraphicBuffer {
    pub header: NativeHandle,
    pub unk0: s32,
    pub nvmap_id: s32,
    pub unk2: u32,
    pub magic: u32,
    pub pid: u32,
    pub type_: u32,
    pub usage: u32,
    pub format: u32,
    pub ext_format: u32,
    pub stride: u32,
    pub total_size: u32,
    pub num_planes: u32,
    pub unk12: u32,
    pub planes: [NvSurface; 3usize],
    pub unused: u64,
}
#[test]
fn bindgen_test_layout_NvGraphicBuffer() {
    assert_eq!(
        ::core::mem::size_of::<NvGraphicBuffer>(),
        336usize,
        concat!("Size of: ", stringify!(NvGraphicBuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<NvGraphicBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(NvGraphicBuffer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGraphicBuffer>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGraphicBuffer),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGraphicBuffer>())).unk0 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGraphicBuffer),
            "::",
            stringify!(unk0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGraphicBuffer>())).nvmap_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGraphicBuffer),
            "::",
            stringify!(nvmap_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGraphicBuffer>())).unk2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGraphicBuffer),
            "::",
            stringify!(unk2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGraphicBuffer>())).magic as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGraphicBuffer),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGraphicBuffer>())).pid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGraphicBuffer),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGraphicBuffer>())).type_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGraphicBuffer),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGraphicBuffer>())).usage as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGraphicBuffer),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGraphicBuffer>())).format as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGraphicBuffer),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGraphicBuffer>())).ext_format as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGraphicBuffer),
            "::",
            stringify!(ext_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGraphicBuffer>())).stride as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGraphicBuffer),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGraphicBuffer>())).total_size as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGraphicBuffer),
            "::",
            stringify!(total_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGraphicBuffer>())).num_planes as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGraphicBuffer),
            "::",
            stringify!(num_planes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGraphicBuffer>())).unk12 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGraphicBuffer),
            "::",
            stringify!(unk12)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGraphicBuffer>())).planes as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGraphicBuffer),
            "::",
            stringify!(planes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGraphicBuffer>())).unused as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGraphicBuffer),
            "::",
            stringify!(unused)
        )
    );
}
/// Native window structure.
#[repr(C)]
pub struct NWindow {
    pub magic: u32,
    pub bq: Binder,
    pub event: Event,
    pub mutex: Mutex,
    pub slots_configured: u64,
    pub slots_requested: u64,
    pub cur_slot: s32,
    pub width: u32,
    pub height: u32,
    pub format: u32,
    pub usage: u32,
    pub crop: BqRect,
    pub scaling_mode: u32,
    pub transform: u32,
    pub sticky_transform: u32,
    pub default_width: u32,
    pub default_height: u32,
    pub swap_interval: u32,
    pub is_connected: bool,
    pub producer_controlled_by_app: bool,
    pub consumer_running_behind: bool,
}
#[test]
fn bindgen_test_layout_NWindow() {
    assert_eq!(
        ::core::mem::size_of::<NWindow>(),
        120usize,
        concat!("Size of: ", stringify!(NWindow))
    );
    assert_eq!(
        ::core::mem::align_of::<NWindow>(),
        8usize,
        concat!("Alignment of ", stringify!(NWindow))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NWindow>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NWindow),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NWindow>())).bq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NWindow),
            "::",
            stringify!(bq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NWindow>())).event as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NWindow),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NWindow>())).mutex as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(NWindow),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NWindow>())).slots_configured as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NWindow),
            "::",
            stringify!(slots_configured)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NWindow>())).slots_requested as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NWindow),
            "::",
            stringify!(slots_requested)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NWindow>())).cur_slot as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NWindow),
            "::",
            stringify!(cur_slot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NWindow>())).width as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(NWindow),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NWindow>())).height as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NWindow),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NWindow>())).format as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(NWindow),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NWindow>())).usage as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(NWindow),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NWindow>())).crop as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(NWindow),
            "::",
            stringify!(crop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NWindow>())).scaling_mode as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(NWindow),
            "::",
            stringify!(scaling_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NWindow>())).transform as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(NWindow),
            "::",
            stringify!(transform)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NWindow>())).sticky_transform as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(NWindow),
            "::",
            stringify!(sticky_transform)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NWindow>())).default_width as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(NWindow),
            "::",
            stringify!(default_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NWindow>())).default_height as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(NWindow),
            "::",
            stringify!(default_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NWindow>())).swap_interval as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(NWindow),
            "::",
            stringify!(swap_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NWindow>())).is_connected as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(NWindow),
            "::",
            stringify!(is_connected)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NWindow>())).producer_controlled_by_app as *const _ as usize
        },
        117usize,
        concat!(
            "Offset of field: ",
            stringify!(NWindow),
            "::",
            stringify!(producer_controlled_by_app)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NWindow>())).consumer_running_behind as *const _ as usize
        },
        118usize,
        concat!(
            "Offset of field: ",
            stringify!(NWindow),
            "::",
            stringify!(consumer_running_behind)
        )
    );
}
extern "C" {
    /// Checks whether a pointer refers to a valid \ref NWindow object.
    pub fn nwindowIsValid(nw: *mut NWindow) -> bool;
}
extern "C" {
    /// @brief Retrieves the default \ref NWindow object.
    /// @return Pointer to the default \ref NWindow object.
    /// @note When this function is used/referenced, libnx will initialize VI services
    /// and create a \ref NWindow object from a \ref ViLayer created on the default \ref ViDisplay;
    /// all of this happening automatically during application startup (i.e. before main is called).
    /// If creating the default \ref NWindow fails, libnx will throw a LibnxError_BadGfxInit fatal error.
    /// Likewise, after main returns (or exit is called) libnx will clean up all resources used by it.
    pub fn nwindowGetDefault() -> *mut NWindow;
}
extern "C" {
    /// @brief Creates a \ref NWindow.
    /// @param[out] nw Output \ref NWindow structure.
    /// @param[in] binder_id Android IGraphicBufferProducer binder session ID.
    /// @param[in] producer_controlled_by_app Specifies whether the producer is controlled by the application.
    pub fn nwindowCreate(
        nw: *mut NWindow,
        binder_id: s32,
        producer_controlled_by_app: bool,
    ) -> Result;
}
extern "C" {
    /// @brief Creates a \ref NWindow operating on a \ref ViLayer.
    /// @param[out] nw Output \ref NWindow structure.
    /// @param[in] layer Pointer to \ref ViLayer structure (such as the one returned by \ref viCreateLayer).
    pub fn nwindowCreateFromLayer(nw: *mut NWindow, layer: *const ViLayer) -> Result;
}
extern "C" {
    /// Closes a \ref NWindow, freeing all resources associated with it.
    pub fn nwindowClose(nw: *mut NWindow);
}
extern "C" {
    /// @brief Retrieves the dimensions of a \ref NWindow.
    /// @param[in] nw Pointer to \ref NWindow structure.
    /// @param[out] out_width Output variable containing the width of the \ref NWindow.
    /// @param[out] out_height Output variable containing the height of the \ref NWindow.
    /// @note After creation, a \ref NWindow reports a default size (usually 1280x720).
    /// This size can be overriden by calling \ref nwindowSetDimensions.
    pub fn nwindowGetDimensions(
        nw: *mut NWindow,
        out_width: *mut u32,
        out_height: *mut u32,
    ) -> Result;
}
extern "C" {
    /// @brief Sets the dimensions of a \ref NWindow.
    /// @param[in] nw Pointer to \ref NWindow structure.
    /// @param[in] width Desired width of the \ref NWindow.
    /// @param[in] height Desired width of the \ref NWindow.
    /// @note This function cannot be called when there are buffers registered with the \ref NWindow.
    pub fn nwindowSetDimensions(nw: *mut NWindow, width: u32, height: u32) -> Result;
}
extern "C" {
    /// @brief Configures the crop applied to images presented through a \ref NWindow.
    /// @param[in] nw Pointer to \ref NWindow structure.
    /// @param[in] left X coordinate of the left margin of the crop bounding box.
    /// @param[in] top Y coordinate of the top margin of the crop bounding box.
    /// @param[in] right X coordinate of the right margin of the crop bounding box.
    /// @param[in] bottom Y coordinate of the bottom margin of the crop bounding box.
    /// @note Passing zero to all parameters disables the crop functionality. This is also the default.
    /// @note The bounding box defined by the parameters will be adjusted to fit within the dimensions of the \ref NWindow.
    /// @note \p left must be less or equal than \p right.
    /// @note \p top must be less or equal than \p bottom.
    pub fn nwindowSetCrop(nw: *mut NWindow, left: s32, top: s32, right: s32, bottom: s32)
        -> Result;
}
extern "C" {
    /// @brief Configures the transformation applied to images presented through a \ref NWindow.
    /// @param[in] nw Pointer to \ref NWindow structure.
    /// @param[in] transform Android transformation mode (see NATIVE_WINDOW_TRANSFORM_* enum)
    /// @note The default transformation is 0 (i.e. no transformation applied)
    pub fn nwindowSetTransform(nw: *mut NWindow, transform: u32) -> Result;
}
extern "C" {
    /// @brief Configures the swap interval of a \ref NWindow.
    /// @param[in] nw Pointer to \ref NWindow structure.
    /// @param[in] swap_interval Value specifying the number of display refreshes (VBlanks) that must occur between presenting images.
    /// @note The default swap interval is 1.
    /// @note If the \ref NWindow has three or more buffers configured (with \ref nwindowConfigureBuffer), it is possible to pass 0
    /// to disable the swap interval feature and present images as fast as allowed by the compositor. Otherwise, the system
    /// enforces a minimum of 1 as the swap interval.
    pub fn nwindowSetSwapInterval(nw: *mut NWindow, swap_interval: u32) -> Result;
}
extern "C" {
    /// @brief Registers a \ref NvGraphicBuffer with a \ref NWindow.
    /// @param[in] nw Pointer to \ref NWindow structure.
    /// @param[in] slot ID of the slot to configure (starting from 0).
    /// @param[in] buf Pointer to \ref NvGraphicBuffer structure.
    /// @note When a buffer is registered, it is added to the internal queue of buffers used for presenting.
    /// @note All buffers registered with a \ref NWindow must have the same dimensions, format and usage.
    /// If \ref nwindowSetDimensions has not been previously called, the \ref NWindow will automatically
    /// adopt the dimensions of the first buffer registered with it. Otherwise, said buffer will need
    /// to match the dimensions that were previously configured.
    pub fn nwindowConfigureBuffer(nw: *mut NWindow, slot: s32, buf: *mut NvGraphicBuffer)
        -> Result;
}
extern "C" {
    /// @brief Dequeues a buffer from a \ref NWindow.
    /// @param[in] nw Pointer to \ref NWindow structure.
    /// @param[out] out_slot Output variable containing the ID of the slot that has been dequeued.
    /// @param[out] out_fence Output variable containing a \ref NvMultiFence that will be signalled by
    /// the compositor when the buffer is ready to be written to. Pass NULL to wait instead
    /// on this fence before this function returns.
    /// @note For \p out_fence=NULL to work, \ref nvFenceInit must have been previously called.
    pub fn nwindowDequeueBuffer(
        nw: *mut NWindow,
        out_slot: *mut s32,
        out_fence: *mut NvMultiFence,
    ) -> Result;
}
extern "C" {
    /// @brief Cancels a buffer previously dequeued with \ref nwindowDequeueBuffer.
    /// @param[in] nw Pointer to \ref NWindow structure.
    /// @param[in] slot ID of the slot to cancel. This must match the output of the previous \ref nwindowDequeueBuffer call.
    /// @param[in] fence Pointer to the \ref NvMultiFence that will be waited on by the compositor before cancelling the buffer.
    /// Pass NULL if there is no such fence.
    pub fn nwindowCancelBuffer(nw: *mut NWindow, slot: s32, fence: *const NvMultiFence) -> Result;
}
extern "C" {
    /// @brief Queues a buffer previously dequeued with \ref nwindowDequeueBuffer, making it ready for presentation.
    /// @param[in] nw Pointer to \ref NWindow structure.
    /// @param[in] slot ID of the slot to queue. This must match the output of the previous \ref nwindowDequeueBuffer call.
    /// @param[in] fence Pointer to the \ref NvMultiFence that will be waited on by the compositor before queuing/presenting the buffer.
    /// Pass NULL if there is no such fence.
    pub fn nwindowQueueBuffer(nw: *mut NWindow, slot: s32, fence: *const NvMultiFence) -> Result;
}
extern "C" {
    /// Releases all buffers registered with a \ref NWindow.
    pub fn nwindowReleaseBuffers(nw: *mut NWindow) -> Result;
}
#[repr(C)]
pub struct NvMap {
    pub handle: u32,
    pub id: u32,
    pub size: u32,
    pub cpu_addr: *mut ctypes::c_void,
    pub kind: NvKind,
    pub has_init: bool,
    pub is_cpu_cacheable: bool,
}
#[test]
fn bindgen_test_layout_NvMap() {
    assert_eq!(
        ::core::mem::size_of::<NvMap>(),
        32usize,
        concat!("Size of: ", stringify!(NvMap))
    );
    assert_eq!(
        ::core::mem::align_of::<NvMap>(),
        8usize,
        concat!("Alignment of ", stringify!(NvMap))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvMap>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvMap),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvMap>())).id as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(NvMap), "::", stringify!(id))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvMap>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvMap),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvMap>())).cpu_addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvMap),
            "::",
            stringify!(cpu_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvMap>())).kind as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NvMap),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvMap>())).has_init as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(NvMap),
            "::",
            stringify!(has_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvMap>())).is_cpu_cacheable as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(NvMap),
            "::",
            stringify!(is_cpu_cacheable)
        )
    );
}
extern "C" {
    pub fn nvMapInit() -> Result;
}
extern "C" {
    pub fn nvMapGetFd() -> u32;
}
extern "C" {
    pub fn nvMapExit();
}
extern "C" {
    pub fn nvMapCreate(
        m: *mut NvMap,
        cpu_addr: *mut ctypes::c_void,
        size: u32,
        align: u32,
        kind: NvKind,
        is_cpu_cacheable: bool,
    ) -> Result;
}
extern "C" {
    pub fn nvMapLoadRemote(m: *mut NvMap, id: u32) -> Result;
}
extern "C" {
    pub fn nvMapClose(m: *mut NvMap);
}
/// Framebuffer structure.
#[repr(C)]
pub struct Framebuffer {
    pub win: *mut NWindow,
    pub map: NvMap,
    pub buf: *mut ctypes::c_void,
    pub buf_linear: *mut ctypes::c_void,
    pub stride: u32,
    pub width_aligned: u32,
    pub height_aligned: u32,
    pub num_fbs: u32,
    pub fb_size: u32,
    pub has_init: bool,
}
#[test]
fn bindgen_test_layout_Framebuffer() {
    assert_eq!(
        ::core::mem::size_of::<Framebuffer>(),
        80usize,
        concat!("Size of: ", stringify!(Framebuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<Framebuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(Framebuffer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Framebuffer>())).win as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Framebuffer),
            "::",
            stringify!(win)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Framebuffer>())).map as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Framebuffer),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Framebuffer>())).buf as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Framebuffer),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Framebuffer>())).buf_linear as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Framebuffer),
            "::",
            stringify!(buf_linear)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Framebuffer>())).stride as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Framebuffer),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Framebuffer>())).width_aligned as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(Framebuffer),
            "::",
            stringify!(width_aligned)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Framebuffer>())).height_aligned as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Framebuffer),
            "::",
            stringify!(height_aligned)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Framebuffer>())).num_fbs as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(Framebuffer),
            "::",
            stringify!(num_fbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Framebuffer>())).fb_size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Framebuffer),
            "::",
            stringify!(fb_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Framebuffer>())).has_init as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(Framebuffer),
            "::",
            stringify!(has_init)
        )
    );
}
extern "C" {
    /// @brief Creates a \ref Framebuffer object.
    /// @param[out] fb Output \ref Framebuffer structure.
    /// @param[in] win Pointer to the \ref NWindow to which the \ref Framebuffer will be registered.
    /// @param[in] width Desired width of the framebuffer (usually 1280).
    /// @param[in] height Desired height of the framebuffer (usually 720).
    /// @param[in] format Desired pixel format (see PIXEL_FORMAT_* enum).
    /// @param[in] num_fbs Number of buffers to create. Pass 1 for single-buffering, 2 for double-buffering or 3 for triple-buffering.
    /// @note Framebuffer images are stored in Tegra block linear format with 16Bx2 sector ordering, read TRM chapter 20.1 for more details.
    /// In order to use regular linear layout, consider calling \ref framebufferMakeLinear after the \ref Framebuffer object is created.
    /// @note Presently, only the following pixel formats are supported:
    /// \ref PIXEL_FORMAT_RGBA_8888
    /// \ref PIXEL_FORMAT_RGBX_8888
    /// \ref PIXEL_FORMAT_RGB_565
    /// \ref PIXEL_FORMAT_BGRA_8888
    /// \ref PIXEL_FORMAT_RGBA_4444
    pub fn framebufferCreate(
        fb: *mut Framebuffer,
        win: *mut NWindow,
        width: u32,
        height: u32,
        format: u32,
        num_fbs: u32,
    ) -> Result;
}
extern "C" {
    /// Enables linear framebuffer mode in a \ref Framebuffer, allocating a shadow buffer in the process.
    pub fn framebufferMakeLinear(fb: *mut Framebuffer) -> Result;
}
extern "C" {
    /// Closes a \ref Framebuffer object, freeing all resources associated with it.
    pub fn framebufferClose(fb: *mut Framebuffer);
}
extern "C" {
    /// @brief Begins rendering a frame in a \ref Framebuffer.
    /// @param[in] fb Pointer to \ref Framebuffer structure.
    /// @param[out] out_stride Output variable containing the distance in bytes between rows of pixels in memory.
    /// @return Pointer to buffer to which new graphics data should be written to.
    /// @note When this function is called, a buffer will be dequeued from the corresponding \ref NWindow.
    /// @note This function will return pointers to different buffers, depending on the number of buffers it was initialized with.
    /// @note If \ref framebufferMakeLinear was used, this function will instead return a pointer to the shadow linear buffer.
    /// In this case, the offset of a pixel is \p y * \p out_stride + \p x * \p bytes_per_pixel.
    /// @note Each call to \ref framebufferBegin must be paired with a \ref framebufferEnd call.
    pub fn framebufferBegin(fb: *mut Framebuffer, out_stride: *mut u32) -> *mut ctypes::c_void;
}
extern "C" {
    /// @brief Finishes rendering a frame in a \ref Framebuffer.
    /// @param[in] fb Pointer to \ref Framebuffer structure.
    /// @note When this function is called, the written image data will be flushed and queued (presented) in the corresponding \ref NWindow.
    /// @note If \ref framebufferMakeLinear was used, this function will copy the image from the shadow linear buffer to the actual framebuffer,
    /// converting it in the process to the layout expected by the compositor.
    /// @note Each call to \ref framebufferBegin must be paired with a \ref framebufferEnd call.
    pub fn framebufferEnd(fb: *mut Framebuffer);
}
#[repr(C)]
pub struct NvAddressSpace {
    pub fd: u32,
    pub page_size: u32,
    pub has_init: bool,
}
#[test]
fn bindgen_test_layout_NvAddressSpace() {
    assert_eq!(
        ::core::mem::size_of::<NvAddressSpace>(),
        12usize,
        concat!("Size of: ", stringify!(NvAddressSpace))
    );
    assert_eq!(
        ::core::mem::align_of::<NvAddressSpace>(),
        4usize,
        concat!("Alignment of ", stringify!(NvAddressSpace))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvAddressSpace>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvAddressSpace),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvAddressSpace>())).page_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvAddressSpace),
            "::",
            stringify!(page_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvAddressSpace>())).has_init as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvAddressSpace),
            "::",
            stringify!(has_init)
        )
    );
}
extern "C" {
    pub fn nvAddressSpaceCreate(a: *mut NvAddressSpace, page_size: u32) -> Result;
}
extern "C" {
    pub fn nvAddressSpaceClose(a: *mut NvAddressSpace);
}
extern "C" {
    pub fn nvAddressSpaceAlloc(
        a: *mut NvAddressSpace,
        sparse: bool,
        size: u64,
        iova_out: *mut iova_t,
    ) -> Result;
}
extern "C" {
    pub fn nvAddressSpaceAllocFixed(
        a: *mut NvAddressSpace,
        sparse: bool,
        size: u64,
        iova: iova_t,
    ) -> Result;
}
extern "C" {
    pub fn nvAddressSpaceFree(a: *mut NvAddressSpace, iova: iova_t, size: u64) -> Result;
}
extern "C" {
    pub fn nvAddressSpaceMap(
        a: *mut NvAddressSpace,
        nvmap_handle: u32,
        is_gpu_cacheable: bool,
        kind: NvKind,
        iova_out: *mut iova_t,
    ) -> Result;
}
extern "C" {
    pub fn nvAddressSpaceMapFixed(
        a: *mut NvAddressSpace,
        nvmap_handle: u32,
        is_gpu_cacheable: bool,
        kind: NvKind,
        iova: iova_t,
    ) -> Result;
}
extern "C" {
    pub fn nvAddressSpaceModify(
        a: *mut NvAddressSpace,
        iova: iova_t,
        offset: u64,
        size: u64,
        kind: NvKind,
    ) -> Result;
}
extern "C" {
    pub fn nvAddressSpaceUnmap(a: *mut NvAddressSpace, iova: iova_t) -> Result;
}
#[repr(C)]
pub struct NvChannel {
    pub fd: u32,
    pub has_init: bool,
}
#[test]
fn bindgen_test_layout_NvChannel() {
    assert_eq!(
        ::core::mem::size_of::<NvChannel>(),
        8usize,
        concat!("Size of: ", stringify!(NvChannel))
    );
    assert_eq!(
        ::core::mem::align_of::<NvChannel>(),
        4usize,
        concat!("Alignment of ", stringify!(NvChannel))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvChannel>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvChannel),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvChannel>())).has_init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvChannel),
            "::",
            stringify!(has_init)
        )
    );
}
extern "C" {
    pub fn nvChannelCreate(c: *mut NvChannel, dev: *const ctypes::c_char) -> Result;
}
extern "C" {
    pub fn nvChannelClose(c: *mut NvChannel);
}
extern "C" {
    pub fn nvChannelSetPriority(c: *mut NvChannel, prio: NvChannelPriority) -> Result;
}
extern "C" {
    pub fn nvChannelSetTimeout(c: *mut NvChannel, timeout: u32) -> Result;
}
extern "C" {
    pub fn nvGpuInit() -> Result;
}
extern "C" {
    pub fn nvGpuExit();
}
extern "C" {
    pub fn nvGpuGetCharacteristics() -> *const nvioctl_gpu_characteristics;
}
extern "C" {
    pub fn nvGpuGetZcullCtxSize() -> u32;
}
#[repr(C)]
pub struct NvGpuChannel {
    pub base: NvChannel,
    pub error_event: Event,
    pub object_id: u64,
    pub fence: NvFence,
    pub fence_incr: u32,
    pub entries: [nvioctl_gpfifo_entry; 2048usize],
    pub num_entries: u32,
}
#[test]
fn bindgen_test_layout_NvGpuChannel() {
    assert_eq!(
        ::core::mem::size_of::<NvGpuChannel>(),
        16440usize,
        concat!("Size of: ", stringify!(NvGpuChannel))
    );
    assert_eq!(
        ::core::mem::align_of::<NvGpuChannel>(),
        8usize,
        concat!("Alignment of ", stringify!(NvGpuChannel))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGpuChannel>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGpuChannel),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGpuChannel>())).error_event as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGpuChannel),
            "::",
            stringify!(error_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGpuChannel>())).object_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGpuChannel),
            "::",
            stringify!(object_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGpuChannel>())).fence as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGpuChannel),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGpuChannel>())).fence_incr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGpuChannel),
            "::",
            stringify!(fence_incr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGpuChannel>())).entries as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGpuChannel),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGpuChannel>())).num_entries as *const _ as usize },
        16432usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGpuChannel),
            "::",
            stringify!(num_entries)
        )
    );
}
extern "C" {
    pub fn nvGpuChannelCreate(c: *mut NvGpuChannel, as_: *mut NvAddressSpace) -> Result;
}
extern "C" {
    pub fn nvGpuChannelClose(c: *mut NvGpuChannel);
}
extern "C" {
    pub fn nvGpuChannelZcullBind(c: *mut NvGpuChannel, iova: iova_t) -> Result;
}
extern "C" {
    pub fn nvGpuChannelAppendEntry(
        c: *mut NvGpuChannel,
        start: iova_t,
        num_cmds: usize,
        flags: u32,
        flush_threshold: u32,
    ) -> Result;
}
extern "C" {
    pub fn nvGpuChannelKickoff(c: *mut NvGpuChannel) -> Result;
}
extern "C" {
    pub fn nvGpuChannelGetErrorNotification(c: *mut NvGpuChannel, error: *mut NvError) -> Result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AudioDriverEtc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AudioDriver {
    pub etc: *mut AudioDriverEtc,
    pub config: AudioRendererConfig,
    pub in_mempools: *mut AudioRendererMemPoolInfoIn,
    pub in_channels: *mut AudioRendererChannelInfoIn,
    pub in_voices: *mut AudioRendererVoiceInfoIn,
    pub in_mixes: *mut AudioRendererMixInfoIn,
    pub in_sinks: *mut AudioRendererSinkInfoIn,
}
#[test]
fn bindgen_test_layout_AudioDriver() {
    assert_eq!(
        ::core::mem::size_of::<AudioDriver>(),
        72usize,
        concat!("Size of: ", stringify!(AudioDriver))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioDriver>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioDriver))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDriver>())).etc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriver),
            "::",
            stringify!(etc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDriver>())).config as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriver),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDriver>())).in_mempools as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriver),
            "::",
            stringify!(in_mempools)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDriver>())).in_channels as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriver),
            "::",
            stringify!(in_channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDriver>())).in_voices as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriver),
            "::",
            stringify!(in_voices)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDriver>())).in_mixes as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriver),
            "::",
            stringify!(in_mixes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDriver>())).in_sinks as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriver),
            "::",
            stringify!(in_sinks)
        )
    );
}
extern "C" {
    pub fn audrvCreate(
        d: *mut AudioDriver,
        config: *const AudioRendererConfig,
        num_final_mix_channels: ctypes::c_int,
    ) -> Result;
}
extern "C" {
    pub fn audrvUpdate(d: *mut AudioDriver) -> Result;
}
extern "C" {
    pub fn audrvClose(d: *mut AudioDriver);
}
extern "C" {
    pub fn audrvMemPoolAdd(
        d: *mut AudioDriver,
        buffer: *mut ctypes::c_void,
        size: usize,
    ) -> ctypes::c_int;
}
extern "C" {
    pub fn audrvMemPoolRemove(d: *mut AudioDriver, id: ctypes::c_int) -> bool;
}
extern "C" {
    pub fn audrvMemPoolAttach(d: *mut AudioDriver, id: ctypes::c_int) -> bool;
}
extern "C" {
    pub fn audrvMemPoolDetach(d: *mut AudioDriver, id: ctypes::c_int) -> bool;
}
pub const AudioDriverWaveBufState_AudioDriverWaveBufState_Free: AudioDriverWaveBufState = 0;
pub const AudioDriverWaveBufState_AudioDriverWaveBufState_Waiting: AudioDriverWaveBufState = 1;
pub const AudioDriverWaveBufState_AudioDriverWaveBufState_Queued: AudioDriverWaveBufState = 2;
pub const AudioDriverWaveBufState_AudioDriverWaveBufState_Playing: AudioDriverWaveBufState = 3;
pub const AudioDriverWaveBufState_AudioDriverWaveBufState_Done: AudioDriverWaveBufState = 4;
pub type AudioDriverWaveBufState = u32;
#[repr(C)]
pub struct AudioDriverWaveBuf {
    pub __bindgen_anon_1: AudioDriverWaveBuf__bindgen_ty_1,
    pub size: u64,
    pub start_sample_offset: s32,
    pub end_sample_offset: s32,
    pub context_addr: *const ctypes::c_void,
    pub context_sz: u64,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub is_looping: bool,
    pub sequence_id: u32,
    pub next: *mut AudioDriverWaveBuf,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AudioDriverWaveBuf__bindgen_ty_1 {
    pub data_pcm16: *mut s16,
    pub data_adpcm: *mut u8,
    pub data_raw: *const ctypes::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_AudioDriverWaveBuf__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AudioDriverWaveBuf__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(AudioDriverWaveBuf__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioDriverWaveBuf__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(AudioDriverWaveBuf__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioDriverWaveBuf__bindgen_ty_1>())).data_pcm16 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriverWaveBuf__bindgen_ty_1),
            "::",
            stringify!(data_pcm16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioDriverWaveBuf__bindgen_ty_1>())).data_adpcm as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriverWaveBuf__bindgen_ty_1),
            "::",
            stringify!(data_adpcm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioDriverWaveBuf__bindgen_ty_1>())).data_raw as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriverWaveBuf__bindgen_ty_1),
            "::",
            stringify!(data_raw)
        )
    );
}
#[test]
fn bindgen_test_layout_AudioDriverWaveBuf() {
    assert_eq!(
        ::core::mem::size_of::<AudioDriverWaveBuf>(),
        56usize,
        concat!("Size of: ", stringify!(AudioDriverWaveBuf))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioDriverWaveBuf>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioDriverWaveBuf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDriverWaveBuf>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriverWaveBuf),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioDriverWaveBuf>())).start_sample_offset as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriverWaveBuf),
            "::",
            stringify!(start_sample_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioDriverWaveBuf>())).end_sample_offset as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriverWaveBuf),
            "::",
            stringify!(end_sample_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioDriverWaveBuf>())).context_addr as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriverWaveBuf),
            "::",
            stringify!(context_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDriverWaveBuf>())).context_sz as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriverWaveBuf),
            "::",
            stringify!(context_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDriverWaveBuf>())).is_looping as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriverWaveBuf),
            "::",
            stringify!(is_looping)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDriverWaveBuf>())).sequence_id as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriverWaveBuf),
            "::",
            stringify!(sequence_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDriverWaveBuf>())).next as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriverWaveBuf),
            "::",
            stringify!(next)
        )
    );
}
impl AudioDriverWaveBuf {
    #[inline]
    pub fn state(&self) -> AudioDriverWaveBufState {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: AudioDriverWaveBufState) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state: AudioDriverWaveBufState,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let state: u32 = unsafe { ::core::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn audrvVoiceInit(
        d: *mut AudioDriver,
        id: ctypes::c_int,
        num_channels: ctypes::c_int,
        format: PcmFormat,
        sample_rate: ctypes::c_int,
    ) -> bool;
}
extern "C" {
    pub fn audrvVoiceDrop(d: *mut AudioDriver, id: ctypes::c_int);
}
extern "C" {
    pub fn audrvVoiceStop(d: *mut AudioDriver, id: ctypes::c_int);
}
extern "C" {
    pub fn audrvVoiceIsPlaying(d: *mut AudioDriver, id: ctypes::c_int) -> bool;
}
extern "C" {
    pub fn audrvVoiceAddWaveBuf(
        d: *mut AudioDriver,
        id: ctypes::c_int,
        wavebuf: *mut AudioDriverWaveBuf,
    ) -> bool;
}
extern "C" {
    pub fn audrvVoiceGetWaveBufSeq(d: *mut AudioDriver, id: ctypes::c_int) -> u32;
}
extern "C" {
    pub fn audrvVoiceGetPlayedSampleCount(d: *mut AudioDriver, id: ctypes::c_int) -> u32;
}
extern "C" {
    pub fn audrvVoiceGetVoiceDropsCount(d: *mut AudioDriver, id: ctypes::c_int) -> u32;
}
extern "C" {
    pub fn audrvVoiceSetBiquadFilter(
        d: *mut AudioDriver,
        id: ctypes::c_int,
        biquad_id: ctypes::c_int,
        a0: f32,
        a1: f32,
        a2: f32,
        b0: f32,
        b1: f32,
        b2: f32,
    );
}
extern "C" {
    pub fn audrvMixAdd(
        d: *mut AudioDriver,
        sample_rate: ctypes::c_int,
        num_channels: ctypes::c_int,
    ) -> ctypes::c_int;
}
extern "C" {
    pub fn audrvMixRemove(d: *mut AudioDriver, id: ctypes::c_int);
}
extern "C" {
    pub fn audrvDeviceSinkAdd(
        d: *mut AudioDriver,
        device_name: *const ctypes::c_char,
        num_channels: ctypes::c_int,
        channel_ids: *const u8,
    ) -> ctypes::c_int;
}
extern "C" {
    pub fn audrvSinkRemove(d: *mut AudioDriver, id: ctypes::c_int);
}
/// CommonArguments
#[repr(C)]
pub struct LibAppletArgs {
    pub CommonArgs_version: u32,
    pub CommonArgs_size: u32,
    /// < LibraryApplet API version
    pub LaVersion: u32,
    /// < Set to the output from \ref appletGetThemeColorType by \ref libappletArgsCreate.
    pub ExpectedThemeColor: s32,
    /// < bool flag, default is false.
    pub PlayStartupSound: u8,
    pub pad: [u8; 7usize],
    pub tick: u64,
}
#[test]
fn bindgen_test_layout_LibAppletArgs() {
    assert_eq!(
        ::core::mem::size_of::<LibAppletArgs>(),
        32usize,
        concat!("Size of: ", stringify!(LibAppletArgs))
    );
    assert_eq!(
        ::core::mem::align_of::<LibAppletArgs>(),
        8usize,
        concat!("Alignment of ", stringify!(LibAppletArgs))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LibAppletArgs>())).CommonArgs_version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LibAppletArgs),
            "::",
            stringify!(CommonArgs_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LibAppletArgs>())).CommonArgs_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LibAppletArgs),
            "::",
            stringify!(CommonArgs_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LibAppletArgs>())).LaVersion as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LibAppletArgs),
            "::",
            stringify!(LaVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LibAppletArgs>())).ExpectedThemeColor as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LibAppletArgs),
            "::",
            stringify!(ExpectedThemeColor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LibAppletArgs>())).PlayStartupSound as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LibAppletArgs),
            "::",
            stringify!(PlayStartupSound)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LibAppletArgs>())).pad as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(LibAppletArgs),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LibAppletArgs>())).tick as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LibAppletArgs),
            "::",
            stringify!(tick)
        )
    );
}
extern "C" {
    /// @brief Creates a LibAppletArgs struct.
    /// @param a LibAppletArgs struct.
    /// @param version LaVersion for \ref LibAppletArgs.
    pub fn libappletArgsCreate(a: *mut LibAppletArgs, version: u32);
}
extern "C" {
    /// @brief Sets the PlayStartupSound field in \ref LibAppletArgs.
    /// @param a LibAppletArgs struct.
    /// @param flag Value for \ref LibAppletArgs PlayStartupSound.
    pub fn libappletArgsSetPlayStartupSound(a: *mut LibAppletArgs, flag: bool);
}
extern "C" {
    /// @brief Creates an AppletStorage with the specified size and writes the buffer contents to that storage at offset 0.
    /// @param[out] s Storage object.
    /// @param buffer Input buffer.
    /// @param size Size to write.
    pub fn libappletCreateWriteStorage(
        s: *mut AppletStorage,
        buffer: *const ctypes::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    /// @brief Reads data from offset 0 from the specified storage into the buffer. If the storage-size is smaller than the size param, the storage-size is used instead.
    /// @param s Storage object.
    /// @param buffer Output buffer.
    /// @param size Size to read.
    /// @param transfer_size Optional output size field for the actual size used for the read, can be NULL.
    pub fn libappletReadStorage(
        s: *mut AppletStorage,
        buffer: *mut ctypes::c_void,
        size: usize,
        transfer_size: *mut usize,
    ) -> Result;
}
extern "C" {
    /// @brief Sets the tick field in LibAppletArgs, then creates a storage with it which is pushed to the AppletHolder via \ref appletHolderPushInData.
    /// @param a LibAppletArgs struct.
    /// @param h AppletHolder object.
    pub fn libappletArgsPush(a: *mut LibAppletArgs, h: *mut AppletHolder) -> Result;
}
extern "C" {
    /// @brief Creates a storage using the input buffer which is pushed to the AppletHolder via \ref appletHolderPushInData.
    /// @param h AppletHolder object.
    /// @param buffer Input data buffer.
    /// @param size Input data size.
    pub fn libappletPushInData(
        h: *mut AppletHolder,
        buffer: *const ctypes::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    /// @brief Pops a storage via \ref appletHolderPopOutData, uses \ref libappletReadStorage, then closes the storage.
    /// @param h AppletHolder object.
    /// @param buffer Output buffer.
    /// @param size Size to read.
    /// @param transfer_size Optional output size field for the actual size used for the read, can be NULL.
    pub fn libappletPopOutData(
        h: *mut AppletHolder,
        buffer: *mut ctypes::c_void,
        size: usize,
        transfer_size: *mut usize,
    ) -> Result;
}
extern "C" {
    /// @brief Starts the applet and waits for it to finish, then checks the \ref LibAppletExitReason.
    /// @note Uses \ref appletHolderStart and \ref appletHolderJoin.
    /// @param h AppletHolder object.
    pub fn libappletStart(h: *mut AppletHolder) -> Result;
}
extern "C" {
    /// @brief Creates a LibraryApplet with the specified input storage data, uses \ref libappletStart, and reads the output storage reply data via \ref libappletPopOutData.
    /// @param id \ref AppletId
    /// @param commonargs \ref LibAppletArgs struct.
    /// @param arg Input storage data buffer. Optional, can be NULL.
    /// @param arg_size Size of the arg buffer.
    /// @param reply Output storage data buffer. Optional, can be NULL.
    /// @param reply_size Size to read for the reply buffer.
    /// @param out_reply_size Actual read reply data size, see \ref libappletPopOutData.
    pub fn libappletLaunch(
        id: AppletId,
        commonargs: *mut LibAppletArgs,
        arg: *const ctypes::c_void,
        arg_size: usize,
        reply: *mut ctypes::c_void,
        reply_size: usize,
        out_reply_size: *mut usize,
    ) -> Result;
}
extern "C" {
    /// Wrapper for \ref appletPushToGeneralChannel, see appletPushToGeneralChannel regarding the requirements for using this.
    /// Returns to the main Home Menu, equivalent to pressing the HOME button.
    pub fn libappletRequestHomeMenu() -> Result;
}
extern "C" {
    /// Wrapper for \ref appletPushToGeneralChannel, see appletPushToGeneralChannel regarding the requirements for using this.
    /// Equivalent to entering "System Update" under System Settings. When leaving this, it returns to the main Home Menu.
    pub fn libappletRequestJumpToSystemUpdate() -> Result;
}
/// < ShowParentalAuthentication
pub const PctlAuthType_PctlAuthType_Show: PctlAuthType = 0;
/// < RegisterParentalPasscode
pub const PctlAuthType_PctlAuthType_RegisterPasscode: PctlAuthType = 1;
/// < ChangeParentalPasscode
pub const PctlAuthType_PctlAuthType_ChangePasscode: PctlAuthType = 2;
/// Type values for PctlAuthArg::type.
pub type PctlAuthType = u32;
/// Input arg storage for the applet.
#[repr(C)]
pub struct PctlAuthArg {
    /// < Always set to 0 by the user-process.
    pub unk_x0: u32,
    /// < \ref PctlAuthType
    pub type_: PctlAuthType,
    /// < Arg0
    pub arg0: u8,
    /// < Arg1
    pub arg1: u8,
    /// < Arg2
    pub arg2: u8,
    /// < Padding
    pub pad: u8,
}
#[test]
fn bindgen_test_layout_PctlAuthArg() {
    assert_eq!(
        ::core::mem::size_of::<PctlAuthArg>(),
        12usize,
        concat!("Size of: ", stringify!(PctlAuthArg))
    );
    assert_eq!(
        ::core::mem::align_of::<PctlAuthArg>(),
        4usize,
        concat!("Alignment of ", stringify!(PctlAuthArg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PctlAuthArg>())).unk_x0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PctlAuthArg),
            "::",
            stringify!(unk_x0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PctlAuthArg>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PctlAuthArg),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PctlAuthArg>())).arg0 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PctlAuthArg),
            "::",
            stringify!(arg0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PctlAuthArg>())).arg1 as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(PctlAuthArg),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PctlAuthArg>())).arg2 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(PctlAuthArg),
            "::",
            stringify!(arg2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PctlAuthArg>())).pad as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(PctlAuthArg),
            "::",
            stringify!(pad)
        )
    );
}
extern "C" {
    /// @brief Launches the applet.
    /// @note Should not be used if a PIN is not already registered. See \ref pctlIsRestrictionEnabled.
    /// @param flag Input flag. false = temporarily disable Parental Controls. true = validate the input PIN.
    pub fn pctlauthShow(flag: bool) -> Result;
}
extern "C" {
    /// @brief Launches the applet. Only available with [4.0.0+].
    /// @param arg0 Value for PctlAuthArg.arg0.
    /// @param arg1 Value for PctlAuthArg.arg1.
    /// @param arg2 Value for PctlAuthArg.arg2.
    pub fn pctlauthShowEx(arg0: u8, arg1: u8, arg2: u8) -> Result;
}
extern "C" {
    /// @brief Just calls: pctlauthShowEx(1, 0, 1). Launches the applet for checking the PIN, used when changing system-settings.
    /// @note Should not be used if a PIN is not already registered. See \ref pctlIsRestrictionEnabled.
    pub fn pctlauthShowForConfiguration() -> Result;
}
extern "C" {
    /// @brief Launches the applet for registering the Parental Controls PIN.
    pub fn pctlauthRegisterPasscode() -> Result;
}
extern "C" {
    /// @brief Launches the applet for changing the Parental Controls PIN.
    /// @note Should not be used if a PIN is not already registered. See \ref pctlIsRestrictionEnabled.
    pub fn pctlauthChangePasscode() -> Result;
}
/// < Normal
pub const ErrorType_ErrorType_Normal: ErrorType = 0;
/// < System
pub const ErrorType_ErrorType_System: ErrorType = 1;
/// < Application
pub const ErrorType_ErrorType_Application: ErrorType = 2;
/// < EULA
pub const ErrorType_ErrorType_Eula: ErrorType = 3;
/// < Parental Controls
pub const ErrorType_ErrorType_Pctl: ErrorType = 4;
/// < Record
pub const ErrorType_ErrorType_Record: ErrorType = 5;
/// < SystemUpdateEula
pub const ErrorType_ErrorType_SystemUpdateEula: ErrorType = 8;
/// Error type for ErrorCommonHeader.type.
pub type ErrorType = u32;
/// Stores error-codes which are displayed as XXXX-XXXX, low for the former and desc for the latter.
#[repr(C)]
pub struct ErrorCode {
    /// < The module portion of the error, normally this should be set to module + 2000.
    pub low: u32,
    /// < The error description.
    pub desc: u32,
}
#[test]
fn bindgen_test_layout_ErrorCode() {
    assert_eq!(
        ::core::mem::size_of::<ErrorCode>(),
        8usize,
        concat!("Size of: ", stringify!(ErrorCode))
    );
    assert_eq!(
        ::core::mem::align_of::<ErrorCode>(),
        4usize,
        concat!("Alignment of ", stringify!(ErrorCode))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorCode>())).low as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorCode),
            "::",
            stringify!(low)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorCode>())).desc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorCode),
            "::",
            stringify!(desc)
        )
    );
}
/// Error context.
#[repr(C)]
pub struct ErrorContext {
    /// < Type
    pub type_: u8,
    /// < Padding
    pub pad: [u8; 7usize],
    /// < Data
    pub data: [u8; 500usize],
    /// < Result
    pub res: Result,
}
#[test]
fn bindgen_test_layout_ErrorContext() {
    assert_eq!(
        ::core::mem::size_of::<ErrorContext>(),
        512usize,
        concat!("Size of: ", stringify!(ErrorContext))
    );
    assert_eq!(
        ::core::mem::align_of::<ErrorContext>(),
        4usize,
        concat!("Alignment of ", stringify!(ErrorContext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorContext>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorContext),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorContext>())).pad as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorContext),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorContext>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorContext),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorContext>())).res as *const _ as usize },
        508usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorContext),
            "::",
            stringify!(res)
        )
    );
}
/// Common header for the start of the arg storage.
#[repr(C)]
pub struct ErrorCommonHeader {
    /// < Type, see \ref ErrorType.
    pub type_: u8,
    /// < When clear, this indicates WithoutJump.
    pub jumpFlag: u8,
    /// < Unknown
    pub unk_x2: [u8; 3usize],
    /// < When set with ::ErrorType_Normal, indicates that an additional storage is pushed for \ref ErrorResultBacktrace. [4.0.0+] Otherwise, when set indicates that an additional storage is pushed for \ref ErrorContext.
    pub contextFlag: u8,
    /// < ErrorCommonArg: When clear, errorCode is used, otherwise the applet generates the error-code from res.
    pub resultFlag: u8,
    /// < Similar to contextFlag except for ErrorCommonArg, indicating \ref ErrorContext is used.
    pub contextFlag2: u8,
}
#[test]
fn bindgen_test_layout_ErrorCommonHeader() {
    assert_eq!(
        ::core::mem::size_of::<ErrorCommonHeader>(),
        8usize,
        concat!("Size of: ", stringify!(ErrorCommonHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<ErrorCommonHeader>(),
        1usize,
        concat!("Alignment of ", stringify!(ErrorCommonHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorCommonHeader>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorCommonHeader),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorCommonHeader>())).jumpFlag as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorCommonHeader),
            "::",
            stringify!(jumpFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorCommonHeader>())).unk_x2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorCommonHeader),
            "::",
            stringify!(unk_x2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorCommonHeader>())).contextFlag as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorCommonHeader),
            "::",
            stringify!(contextFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorCommonHeader>())).resultFlag as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorCommonHeader),
            "::",
            stringify!(resultFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorCommonHeader>())).contextFlag2 as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorCommonHeader),
            "::",
            stringify!(contextFlag2)
        )
    );
}
/// Common error arg data.
#[repr(C)]
pub struct ErrorCommonArg {
    /// < Common header.
    pub hdr: ErrorCommonHeader,
    /// < \ref ErrorCode
    pub errorCode: ErrorCode,
    /// < Result
    pub res: Result,
}
#[test]
fn bindgen_test_layout_ErrorCommonArg() {
    assert_eq!(
        ::core::mem::size_of::<ErrorCommonArg>(),
        20usize,
        concat!("Size of: ", stringify!(ErrorCommonArg))
    );
    assert_eq!(
        ::core::mem::align_of::<ErrorCommonArg>(),
        4usize,
        concat!("Alignment of ", stringify!(ErrorCommonArg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorCommonArg>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorCommonArg),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorCommonArg>())).errorCode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorCommonArg),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorCommonArg>())).res as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorCommonArg),
            "::",
            stringify!(res)
        )
    );
}
/// Error arg data for certain errors with module PCTL.
#[repr(C)]
pub struct ErrorPctlArg {
    /// < Common header.
    pub hdr: ErrorCommonHeader,
    /// < Result
    pub res: Result,
}
#[test]
fn bindgen_test_layout_ErrorPctlArg() {
    assert_eq!(
        ::core::mem::size_of::<ErrorPctlArg>(),
        12usize,
        concat!("Size of: ", stringify!(ErrorPctlArg))
    );
    assert_eq!(
        ::core::mem::align_of::<ErrorPctlArg>(),
        4usize,
        concat!("Alignment of ", stringify!(ErrorPctlArg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorPctlArg>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorPctlArg),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorPctlArg>())).res as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorPctlArg),
            "::",
            stringify!(res)
        )
    );
}
/// ResultBacktrace
#[repr(C)]
pub struct ErrorResultBacktrace {
    /// < Total entries in the backtrace array.
    pub count: s32,
    /// < Result backtrace.
    pub backtrace: [Result; 32usize],
}
#[test]
fn bindgen_test_layout_ErrorResultBacktrace() {
    assert_eq!(
        ::core::mem::size_of::<ErrorResultBacktrace>(),
        132usize,
        concat!("Size of: ", stringify!(ErrorResultBacktrace))
    );
    assert_eq!(
        ::core::mem::align_of::<ErrorResultBacktrace>(),
        4usize,
        concat!("Alignment of ", stringify!(ErrorResultBacktrace))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorResultBacktrace>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorResultBacktrace),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorResultBacktrace>())).backtrace as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorResultBacktrace),
            "::",
            stringify!(backtrace)
        )
    );
}
/// Error arg data for EULA.
#[repr(C)]
pub struct ErrorEulaArg {
    /// < Common header.
    pub hdr: ErrorCommonHeader,
    /// < \ref SetRegion
    pub regionCode: SetRegion,
}
#[test]
fn bindgen_test_layout_ErrorEulaArg() {
    assert_eq!(
        ::core::mem::size_of::<ErrorEulaArg>(),
        12usize,
        concat!("Size of: ", stringify!(ErrorEulaArg))
    );
    assert_eq!(
        ::core::mem::align_of::<ErrorEulaArg>(),
        4usize,
        concat!("Alignment of ", stringify!(ErrorEulaArg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorEulaArg>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorEulaArg),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorEulaArg>())).regionCode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorEulaArg),
            "::",
            stringify!(regionCode)
        )
    );
}
/// Additional input storage data for \ref errorSystemUpdateEulaShow.
#[repr(C)]
pub struct ErrorEulaData {
    /// < data
    pub data: [u8; 131072usize],
}
#[test]
fn bindgen_test_layout_ErrorEulaData() {
    assert_eq!(
        ::core::mem::size_of::<ErrorEulaData>(),
        131072usize,
        concat!("Size of: ", stringify!(ErrorEulaData))
    );
    assert_eq!(
        ::core::mem::align_of::<ErrorEulaData>(),
        1usize,
        concat!("Alignment of ", stringify!(ErrorEulaData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorEulaData>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorEulaData),
            "::",
            stringify!(data)
        )
    );
}
/// Error arg data for Record.
#[repr(C)]
pub struct ErrorRecordArg {
    /// < Common header.
    pub hdr: ErrorCommonHeader,
    /// < \ref ErrorCode
    pub errorCode: ErrorCode,
    /// < POSIX timestamp.
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_ErrorRecordArg() {
    assert_eq!(
        ::core::mem::size_of::<ErrorRecordArg>(),
        24usize,
        concat!("Size of: ", stringify!(ErrorRecordArg))
    );
    assert_eq!(
        ::core::mem::align_of::<ErrorRecordArg>(),
        8usize,
        concat!("Alignment of ", stringify!(ErrorRecordArg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorRecordArg>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorRecordArg),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorRecordArg>())).errorCode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorRecordArg),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorRecordArg>())).timestamp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorRecordArg),
            "::",
            stringify!(timestamp)
        )
    );
}
/// SystemErrorArg
#[repr(C)]
pub struct ErrorSystemArg {
    /// < Common header.
    pub hdr: ErrorCommonHeader,
    /// < \ref ErrorCode
    pub errorCode: ErrorCode,
    /// < See set.h.
    pub languageCode: u64,
    /// < UTF-8 Dialog message.
    pub dialogMessage: [ctypes::c_char; 2048usize],
    /// < UTF-8 Fullscreen message (displayed when the user clicks on "Details").
    pub fullscreenMessage: [ctypes::c_char; 2048usize],
}
#[test]
fn bindgen_test_layout_ErrorSystemArg() {
    assert_eq!(
        ::core::mem::size_of::<ErrorSystemArg>(),
        4120usize,
        concat!("Size of: ", stringify!(ErrorSystemArg))
    );
    assert_eq!(
        ::core::mem::align_of::<ErrorSystemArg>(),
        8usize,
        concat!("Alignment of ", stringify!(ErrorSystemArg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorSystemArg>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorSystemArg),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorSystemArg>())).errorCode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorSystemArg),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorSystemArg>())).languageCode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorSystemArg),
            "::",
            stringify!(languageCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorSystemArg>())).dialogMessage as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorSystemArg),
            "::",
            stringify!(dialogMessage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ErrorSystemArg>())).fullscreenMessage as *const _ as usize
        },
        2072usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorSystemArg),
            "::",
            stringify!(fullscreenMessage)
        )
    );
}
/// Error system config.
#[repr(C)]
pub struct ErrorSystemConfig {
    /// < Arg data.
    pub arg: ErrorSystemArg,
    /// < Optional error context.
    pub ctx: ErrorContext,
}
#[test]
fn bindgen_test_layout_ErrorSystemConfig() {
    assert_eq!(
        ::core::mem::size_of::<ErrorSystemConfig>(),
        4632usize,
        concat!("Size of: ", stringify!(ErrorSystemConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<ErrorSystemConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(ErrorSystemConfig))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorSystemConfig>())).arg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorSystemConfig),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorSystemConfig>())).ctx as *const _ as usize },
        4120usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorSystemConfig),
            "::",
            stringify!(ctx)
        )
    );
}
/// ApplicationErrorArg
#[repr(C, packed)]
pub struct ErrorApplicationArg {
    /// < Common header.
    pub hdr: ErrorCommonHeader,
    /// < Raw decimal error number which is displayed in the dialog.
    pub errorNumber: u32,
    /// < See set.h.
    pub languageCode: u64,
    /// < UTF-8 Dialog message.
    pub dialogMessage: [ctypes::c_char; 2048usize],
    /// < UTF-8 Fullscreen message (displayed when the user clicks on "Details").
    pub fullscreenMessage: [ctypes::c_char; 2048usize],
}
#[test]
fn bindgen_test_layout_ErrorApplicationArg() {
    assert_eq!(
        ::core::mem::size_of::<ErrorApplicationArg>(),
        4116usize,
        concat!("Size of: ", stringify!(ErrorApplicationArg))
    );
    assert_eq!(
        ::core::mem::align_of::<ErrorApplicationArg>(),
        1usize,
        concat!("Alignment of ", stringify!(ErrorApplicationArg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorApplicationArg>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorApplicationArg),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ErrorApplicationArg>())).errorNumber as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorApplicationArg),
            "::",
            stringify!(errorNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ErrorApplicationArg>())).languageCode as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorApplicationArg),
            "::",
            stringify!(languageCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ErrorApplicationArg>())).dialogMessage as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorApplicationArg),
            "::",
            stringify!(dialogMessage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ErrorApplicationArg>())).fullscreenMessage as *const _ as usize
        },
        2068usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorApplicationArg),
            "::",
            stringify!(fullscreenMessage)
        )
    );
}
/// Error application config.
#[repr(C)]
pub struct ErrorApplicationConfig {
    /// < Arg data.
    pub arg: ErrorApplicationArg,
}
#[test]
fn bindgen_test_layout_ErrorApplicationConfig() {
    assert_eq!(
        ::core::mem::size_of::<ErrorApplicationConfig>(),
        4116usize,
        concat!("Size of: ", stringify!(ErrorApplicationConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<ErrorApplicationConfig>(),
        1usize,
        concat!("Alignment of ", stringify!(ErrorApplicationConfig))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ErrorApplicationConfig>())).arg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorApplicationConfig),
            "::",
            stringify!(arg)
        )
    );
}
extern "C" {
    /// @brief Launches the applet for displaying the specified Result.
    /// @param res Result
    /// @param jumpFlag Jump flag, normally this is true.
    /// @param ctx Optional \ref ErrorContext, can be NULL. Unused when jumpFlag=false. Ignored on pre-4.0.0, since it's only available for [4.0.0+].
    /// @note Sets the following fields: jumpFlag and contextFlag2. Uses ::ErrorType_Normal normally.
    /// @note For module=PCTL errors with desc 100-119 this sets uses ::ErrorType_Pctl, in which case the applet will display the following special dialog: "This software is restricted by Parental Controls".
    /// @note If the input Result is 0xC8A2, the applet will display a special dialog regarding the current application requiring a software update, with buttons "Later" and "Restart".
    /// @note [3.0.0+] If the input Result is 0xCAA2, the applet will display a special dialog related to DLC version.
    /// @warning This applet creates an error report that is logged in the system, when not handling the above special dialogs. Proceed at your own risk!
    pub fn errorResultShow(res: Result, jumpFlag: bool, ctx: *const ErrorContext) -> Result;
}
extern "C" {
    /// @brief Launches the applet for displaying the specified ErrorCode.
    /// @param errorCode \ref ErrorCode
    /// @param jumpFlag Jump flag, normally this is true.
    /// @param ctx Optional \ref ErrorContext, can be NULL. Unused when jumpFlag=false. Ignored on pre-4.0.0, since it's only available for [4.0.0+].
    /// @note Sets the following fields: jumpFlag and contextFlag2. resultFlag=1. Uses ::ErrorType_Normal.
    /// @warning This applet creates an error report that is logged in the system. Proceed at your own risk!
    pub fn errorCodeShow(errorCode: ErrorCode, jumpFlag: bool, ctx: *const ErrorContext) -> Result;
}
extern "C" {
    /// @brief Creates an ErrorResultBacktrace struct.
    /// @param backtrace \ref ErrorResultBacktrace struct.
    /// @param count Total number of entries.
    /// @param entries Input array of Result.
    pub fn errorResultBacktraceCreate(
        backtrace: *mut ErrorResultBacktrace,
        count: s32,
        entries: *const Result,
    ) -> Result;
}
extern "C" {
    /// @brief Launches the applet for \ref ErrorResultBacktrace.
    /// @param backtrace ErrorResultBacktrace struct.
    /// @param res Result
    /// @note Sets the following fields: jumpFlag=1, contextFlag=1, and uses ::ErrorType_Normal.
    /// @warning This applet creates an error report that is logged in the system. Proceed at your own risk!
    pub fn errorResultBacktraceShow(res: Result, backtrace: *const ErrorResultBacktrace) -> Result;
}
extern "C" {
    /// @brief Launches the applet for displaying the EULA.
    /// @param RegionCode \ref SetRegion
    /// @note Sets the following fields: jumpFlag=1, regionCode, and uses ::ErrorType_Eula.
    pub fn errorEulaShow(RegionCode: SetRegion) -> Result;
}
extern "C" {
    /// @brief Launches the applet for displaying the system-update EULA.
    /// @param RegionCode \ref SetRegion
    /// @param eula EULA data. Address must be 0x1000-byte aligned.
    /// @note Sets the following fields: jumpFlag=1, regionCode, and uses ::ErrorType_SystemUpdateEula.
    pub fn errorSystemUpdateEulaShow(RegionCode: SetRegion, eula: *const ErrorEulaData) -> Result;
}
extern "C" {
    /// @brief Launches the applet for displaying an error full-screen, using the specified ErrorCode and timestamp.
    /// @param errorCode \ref ErrorCode
    /// @param timestamp POSIX timestamp.
    /// @note Sets the following fields: jumpFlag=1, errorCode, timestamp, and uses ::ErrorType_Record.
    /// @note The applet does not log an error report for this. error*RecordShow is used by qlaunch for displaying previously logged error reports.
    pub fn errorCodeRecordShow(errorCode: ErrorCode, timestamp: u64) -> Result;
}
extern "C" {
    /// @brief Creates an ErrorSystemConfig struct.
    /// @param c ErrorSystemConfig struct.
    /// @param dialog_message UTF-8 dialog message.
    /// @param fullscreen_message UTF-8 fullscreen message, displayed when the user clicks on "Details". Optional, can be NULL (which disables displaying Details).
    /// @note Sets the following fields: {strings}, and uses ::ErrorType_System. The rest are cleared.
    /// @note On pre-5.0.0 this will initialize languageCode by using: setInitialize(), setMakeLanguageCode(SetLanguage_ENUS, ...), and setExit(). This is needed since an empty languageCode wasn't supported until [5.0.0+] (which would also use SetLanguage_ENUS).
    /// @warning This applet creates an error report that is logged in the system. Proceed at your own risk!
    pub fn errorSystemCreate(
        c: *mut ErrorSystemConfig,
        dialog_message: *const ctypes::c_char,
        fullscreen_message: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    /// @brief Launches the applet with the specified config.
    /// @param c ErrorSystemConfig struct.
    pub fn errorSystemShow(c: *mut ErrorSystemConfig) -> Result;
}
extern "C" {
    /// @brief Sets the ErrorContext.
    /// @note Only available on [4.0.0+], on older versions this will return without setting the context.
    /// @param c   ErrorSystemConfig struct.
    /// @param ctx ErrorContext, NULL to clear it.
    pub fn errorSystemSetContext(c: *mut ErrorSystemConfig, ctx: *const ErrorContext);
}
extern "C" {
    /// @brief Creates an ErrorApplicationConfig struct.
    /// @param c ErrorApplicationConfig struct.
    /// @param dialog_message UTF-8 dialog message.
    /// @param fullscreen_message UTF-8 fullscreen message, displayed when the user clicks on "Details". Optional, can be NULL (which disables displaying Details).
    /// @note Sets the following fields: jumpFlag=1, {strings}, and uses ::ErrorType_Application. The rest are cleared.
    /// @note On pre-5.0.0 this will initialize languageCode by using: setInitialize(), setMakeLanguageCode(SetLanguage_ENUS, ...), and setExit(). This is needed since an empty languageCode wasn't supported until [5.0.0+] (which would also use SetLanguage_ENUS).
    /// @warning This applet creates an error report that is logged in the system. Proceed at your own risk!
    pub fn errorApplicationCreate(
        c: *mut ErrorApplicationConfig,
        dialog_message: *const ctypes::c_char,
        fullscreen_message: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    /// @brief Launches the applet with the specified config.
    /// @param c ErrorApplicationConfig struct.
    pub fn errorApplicationShow(c: *mut ErrorApplicationConfig) -> Result;
}
/// < Success, valid string.
pub const SwkbdTextCheckResult_SwkbdTextCheckResult_OK: SwkbdTextCheckResult = 0;
/// < Failure, invalid string. Error message is displayed in a message-box, pressing OK will return to swkbd again.
pub const SwkbdTextCheckResult_SwkbdTextCheckResult_Bad: SwkbdTextCheckResult = 1;
/// < Failure, invalid string. Error message is displayed in a message-box, pressing Cancel will return to swkbd again, while pressing OK will continue as if the text was valid.
pub const SwkbdTextCheckResult_SwkbdTextCheckResult_Prompt: SwkbdTextCheckResult = 2;
/// < Failure, invalid string. With value 3 and above, swkbd will silently not accept the string, without displaying any error.
pub const SwkbdTextCheckResult_SwkbdTextCheckResult_Silent: SwkbdTextCheckResult = 3;
/// Output result returned by \ref SwkbdTextCheckCb.
pub type SwkbdTextCheckResult = u32;
/// < Normal keyboard.
pub const SwkbdType_SwkbdType_Normal: SwkbdType = 0;
/// < Number pad. The buttons at the bottom left/right are only available when they're set by \ref swkbdConfigSetLeftOptionalSymbolKey / \ref swkbdConfigSetRightOptionalSymbolKey.
pub const SwkbdType_SwkbdType_NumPad: SwkbdType = 1;
/// < QWERTY (and variants) keyboard only.
pub const SwkbdType_SwkbdType_QWERTY: SwkbdType = 2;
/// Type of keyboard.
pub type SwkbdType = u32;
/// < Disable space-bar.
pub const SwkbdKeyDisableBitmask_Space: _bindgen_ty_12 = 2;
/// < Disable '@'.
pub const SwkbdKeyDisableBitmask_At: _bindgen_ty_12 = 4;
/// < Disable '%'.
pub const SwkbdKeyDisableBitmask_Percent: _bindgen_ty_12 = 8;
/// < Disable '/'.
pub const SwkbdKeyDisableBitmask_ForwardSlash: _bindgen_ty_12 = 16;
/// < Disable '\'.
pub const SwkbdKeyDisableBitmask_Backslash: _bindgen_ty_12 = 32;
/// < Disable numbers.
pub const SwkbdKeyDisableBitmask_Numbers: _bindgen_ty_12 = 64;
/// < Used for \ref swkbdConfigMakePresetDownloadCode.
pub const SwkbdKeyDisableBitmask_DownloadCode: _bindgen_ty_12 = 128;
/// < Used for \ref swkbdConfigMakePresetUserName. Disables '@', '%', and '\'.
pub const SwkbdKeyDisableBitmask_UserName: _bindgen_ty_12 = 256;
/// Bitmask for \ref SwkbdArgV0 keySetDisableBitmask. This disables keys on the keyboard when the corresponding bit(s) are set.
pub type _bindgen_ty_12 = u32;
/// < The text will be displayed on a line. Also enables displaying the Header and Sub text.
pub const SwkbdTextDrawType_SwkbdTextDrawType_Line: SwkbdTextDrawType = 0;
/// < The text will be displayed in a box.
pub const SwkbdTextDrawType_SwkbdTextDrawType_Box: SwkbdTextDrawType = 1;
/// < Used by \ref swkbdConfigMakePresetDownloadCode on 5.0.0+. Enables using \ref SwkbdArgV7 unk_x3e0.
pub const SwkbdTextDrawType_SwkbdTextDrawType_DownloadCode: SwkbdTextDrawType = 2;
/// Value for \ref SwkbdArgV0 textDrawType. Only applies when stringLenMax is 1..32, otherwise swkbd will only use SwkbdTextDrawType_Box.
pub type SwkbdTextDrawType = u32;
pub const SwkbdRequestCommand_SwkbdRequestCommand_Finalize: SwkbdRequestCommand = 4;
pub const SwkbdRequestCommand_SwkbdRequestCommand_SetUserWordInfo: SwkbdRequestCommand = 6;
pub const SwkbdRequestCommand_SwkbdRequestCommand_SetCustomizeDic: SwkbdRequestCommand = 7;
pub const SwkbdRequestCommand_SwkbdRequestCommand_Calc: SwkbdRequestCommand = 10;
/// SwkbdInline Interactive input storage request ID.
pub type SwkbdRequestCommand = u32;
pub const SwkbdReplyType_SwkbdReplyType_FinishedInitialize: SwkbdReplyType = 0;
pub const SwkbdReplyType_SwkbdReplyType_ChangedString: SwkbdReplyType = 2;
pub const SwkbdReplyType_SwkbdReplyType_MovedCursor: SwkbdReplyType = 3;
pub const SwkbdReplyType_SwkbdReplyType_MovedTab: SwkbdReplyType = 4;
pub const SwkbdReplyType_SwkbdReplyType_DecidedEnter: SwkbdReplyType = 5;
pub const SwkbdReplyType_SwkbdReplyType_DecidedCancel: SwkbdReplyType = 6;
pub const SwkbdReplyType_SwkbdReplyType_ChangedStringUtf8: SwkbdReplyType = 7;
pub const SwkbdReplyType_SwkbdReplyType_MovedCursorUtf8: SwkbdReplyType = 8;
pub const SwkbdReplyType_SwkbdReplyType_DecidedEnterUtf8: SwkbdReplyType = 9;
pub const SwkbdReplyType_SwkbdReplyType_UnsetCustomizeDic: SwkbdReplyType = 10;
pub const SwkbdReplyType_SwkbdReplyType_ReleasedUserWordInfo: SwkbdReplyType = 11;
/// SwkbdInline Interactive output storage reply ID.
pub type SwkbdReplyType = u32;
/// < Default state from \ref swkbdInlineCreate, before a state is set by \ref swkbdInlineUpdate when a reply is received. Also indicates that the applet is no longer running.
pub const SwkbdState_SwkbdState_Inactive: SwkbdState = 0;
/// < Applet is initialized.
pub const SwkbdState_SwkbdState_Initialized: SwkbdState = 1;
pub const SwkbdState_SwkbdState_Unknown2: SwkbdState = 2;
/// < Text is available since a ChangedString* reply was received.
pub const SwkbdState_SwkbdState_TextAvailable: SwkbdState = 3;
/// < The user pressed the ok-button, submitting the text and closing the applet.
pub const SwkbdState_SwkbdState_Submitted: SwkbdState = 4;
pub const SwkbdState_SwkbdState_Unknown5: SwkbdState = 5;
/// SwkbdInline State
pub type SwkbdState = u32;
/// < LibAppletMode_Unknown3. This is the default. The user-process must handle displaying the swkbd gfx on the screen. Attempting to get the swkbd gfx data for this currently throws an error (unknown why), SwkbdInlineMode_AppletDisplay should be used instead.
pub const SwkbdInlineMode_SwkbdInlineMode_UserDisplay: SwkbdInlineMode = 0;
/// < LibAppletMode_Background. The applet will handle displaying gfx on the screen.
pub const SwkbdInlineMode_SwkbdInlineMode_AppletDisplay: SwkbdInlineMode = 1;
/// Value for \ref SwkbdInitializeArg mode. Controls the LibAppletMode when launching the applet.
pub type SwkbdInlineMode = u32;
/// TextCheck callback set by \ref swkbdConfigSetTextCheckCallback, for validating the input string when the swkbd ok-button is pressed. This buffer contains an UTF-8 string. This callback should validate the input string, then return a \ref SwkbdTextCheckResult indicating success/failure. On failure, this function must write an error message to the tmp_string buffer, which will then be displayed by swkbd.
pub type SwkbdTextCheckCb = ::core::option::Option<
    unsafe extern "C" fn(
        tmp_string: *mut ctypes::c_char,
        tmp_string_size: usize,
    ) -> SwkbdTextCheckResult,
>;
/// Base swkbd arg struct.
#[repr(C)]
pub struct SwkbdArgV0 {
    /// < See \ref SwkbdType.
    pub type_: SwkbdType,
    pub okButtonText: [u16; 9usize],
    pub leftButtonText: u16,
    pub rightButtonText: u16,
    /// < Enables dictionary usage when non-zero (including the system dictionary).
    pub dicFlag: u8,
    pub pad_x1b: u8,
    /// < See SwkbdKeyDisableBitmask_*.
    pub keySetDisableBitmask: u32,
    /// < Initial cursor position in the string: 0 = start, 1 = end.
    pub initialCursorPos: u32,
    pub headerText: [u16; 65usize],
    pub subText: [u16; 129usize],
    pub guideText: [u16; 257usize],
    pub pad_x3aa: u16,
    /// < When non-zero, specifies the max string length. When the input is too long, swkbd will stop accepting more input until text is deleted via the B button (Backspace). See also \ref SwkbdTextDrawType.
    pub stringLenMax: u32,
    /// < When non-zero, specifies the max string length. When the input is too long, swkbd will display an icon and disable the ok-button.
    pub stringLenMaxExt: u32,
    /// < Use password: 0 = disable, 1 = enable.
    pub passwordFlag: u32,
    /// < See \ref SwkbdTextDrawType.
    pub textDrawType: SwkbdTextDrawType,
    /// < Controls whether the Return button is enabled, for newlines input. 0 = disabled, non-zero = enabled.
    pub returnButtonFlag: u16,
    /// < When enabled with value 1, the background is blurred.
    pub blurBackground: u8,
    pub pad_x3bf: u8,
    pub initialStringOffset: u32,
    pub initialStringSize: u32,
    pub userDicOffset: u32,
    pub userDicEntries: s32,
    pub textCheckFlag: u8,
    pub pad_x3d1: [u8; 7usize],
    /// < This really doesn't belong in a struct sent to another process, but official sw does this.
    pub textCheckCb: SwkbdTextCheckCb,
}
#[test]
fn bindgen_test_layout_SwkbdArgV0() {
    assert_eq!(
        ::core::mem::size_of::<SwkbdArgV0>(),
        992usize,
        concat!("Size of: ", stringify!(SwkbdArgV0))
    );
    assert_eq!(
        ::core::mem::align_of::<SwkbdArgV0>(),
        8usize,
        concat!("Alignment of ", stringify!(SwkbdArgV0))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).okButtonText as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(okButtonText)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).leftButtonText as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(leftButtonText)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).rightButtonText as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(rightButtonText)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).dicFlag as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(dicFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).pad_x1b as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(pad_x1b)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdArgV0>())).keySetDisableBitmask as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(keySetDisableBitmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).initialCursorPos as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(initialCursorPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).headerText as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(headerText)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).subText as *const _ as usize },
        166usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(subText)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).guideText as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(guideText)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).pad_x3aa as *const _ as usize },
        938usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(pad_x3aa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).stringLenMax as *const _ as usize },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(stringLenMax)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).stringLenMaxExt as *const _ as usize },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(stringLenMaxExt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).passwordFlag as *const _ as usize },
        948usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(passwordFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).textDrawType as *const _ as usize },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(textDrawType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).returnButtonFlag as *const _ as usize },
        956usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(returnButtonFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).blurBackground as *const _ as usize },
        958usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(blurBackground)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).pad_x3bf as *const _ as usize },
        959usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(pad_x3bf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).initialStringOffset as *const _ as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(initialStringOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).initialStringSize as *const _ as usize },
        964usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(initialStringSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).userDicOffset as *const _ as usize },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(userDicOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).userDicEntries as *const _ as usize },
        972usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(userDicEntries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).textCheckFlag as *const _ as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(textCheckFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).pad_x3d1 as *const _ as usize },
        977usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(pad_x3d1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV0>())).textCheckCb as *const _ as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV0),
            "::",
            stringify!(textCheckCb)
        )
    );
}
/// Arg struct for version 0x30007+.
#[repr(C)]
pub struct SwkbdArgV7 {
    pub arg: SwkbdArgV0,
    /// < When set and enabled via \ref SwkbdTextDrawType, controls displayed text grouping (inserts spaces, without affecting output string).
    pub unk_x3e0: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_SwkbdArgV7() {
    assert_eq!(
        ::core::mem::size_of::<SwkbdArgV7>(),
        1024usize,
        concat!("Size of: ", stringify!(SwkbdArgV7))
    );
    assert_eq!(
        ::core::mem::align_of::<SwkbdArgV7>(),
        8usize,
        concat!("Alignment of ", stringify!(SwkbdArgV7))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV7>())).arg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV7),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdArgV7>())).unk_x3e0 as *const _ as usize },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdArgV7),
            "::",
            stringify!(unk_x3e0)
        )
    );
}
#[repr(C)]
pub struct SwkbdConfig {
    pub arg: SwkbdArgV7,
    pub workbuf: *mut u8,
    pub workbuf_size: usize,
    pub max_dictwords: s32,
    pub version: u32,
}
#[test]
fn bindgen_test_layout_SwkbdConfig() {
    assert_eq!(
        ::core::mem::size_of::<SwkbdConfig>(),
        1048usize,
        concat!("Size of: ", stringify!(SwkbdConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<SwkbdConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(SwkbdConfig))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdConfig>())).arg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdConfig),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdConfig>())).workbuf as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdConfig),
            "::",
            stringify!(workbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdConfig>())).workbuf_size as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdConfig),
            "::",
            stringify!(workbuf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdConfig>())).max_dictwords as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdConfig),
            "::",
            stringify!(max_dictwords)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdConfig>())).version as *const _ as usize },
        1044usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdConfig),
            "::",
            stringify!(version)
        )
    );
}
/// User dictionary word.
#[repr(C)]
pub struct SwkbdDictWord {
    pub unk_x0: [u8; 100usize],
}
#[test]
fn bindgen_test_layout_SwkbdDictWord() {
    assert_eq!(
        ::core::mem::size_of::<SwkbdDictWord>(),
        100usize,
        concat!("Size of: ", stringify!(SwkbdDictWord))
    );
    assert_eq!(
        ::core::mem::align_of::<SwkbdDictWord>(),
        1usize,
        concat!("Alignment of ", stringify!(SwkbdDictWord))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdDictWord>())).unk_x0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdDictWord),
            "::",
            stringify!(unk_x0)
        )
    );
}
/// Input data for SwkbdInline request SetCustomizeDic.
#[repr(C)]
pub struct SwkbdCustomizeDicInfo {
    pub unk_x0: [u8; 112usize],
}
#[test]
fn bindgen_test_layout_SwkbdCustomizeDicInfo() {
    assert_eq!(
        ::core::mem::size_of::<SwkbdCustomizeDicInfo>(),
        112usize,
        concat!("Size of: ", stringify!(SwkbdCustomizeDicInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SwkbdCustomizeDicInfo>(),
        1usize,
        concat!("Alignment of ", stringify!(SwkbdCustomizeDicInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdCustomizeDicInfo>())).unk_x0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdCustomizeDicInfo),
            "::",
            stringify!(unk_x0)
        )
    );
}
#[repr(C)]
pub struct SwkbdInitializeArg {
    pub unk_x0: u32,
    /// < See \ref SwkbdInlineMode.
    pub mode: u8,
    /// < Only set on 5.0.0+.
    pub unk_x5: u8,
    pub pad: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_SwkbdInitializeArg() {
    assert_eq!(
        ::core::mem::size_of::<SwkbdInitializeArg>(),
        8usize,
        concat!("Size of: ", stringify!(SwkbdInitializeArg))
    );
    assert_eq!(
        ::core::mem::align_of::<SwkbdInitializeArg>(),
        4usize,
        concat!("Alignment of ", stringify!(SwkbdInitializeArg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInitializeArg>())).unk_x0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInitializeArg),
            "::",
            stringify!(unk_x0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInitializeArg>())).mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInitializeArg),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInitializeArg>())).unk_x5 as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInitializeArg),
            "::",
            stringify!(unk_x5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInitializeArg>())).pad as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInitializeArg),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C, packed)]
pub struct SwkbdAppearArg {
    /// < See \ref SwkbdType.
    pub type_: SwkbdType,
    pub okButtonText: [u16; 9usize],
    pub leftButtonText: u16,
    pub rightButtonText: u16,
    /// < Enables dictionary usage when non-zero (including the system dictionary).
    pub dicFlag: u8,
    pub unk_x1b: u8,
    /// < See SwkbdKeyDisableBitmask_*.
    pub keySetDisableBitmask: u32,
    pub unk_x20: s32,
    pub unk_x24: s32,
    /// < Controls whether the Return button is enabled, for newlines input. 0 = disabled, non-zero = enabled.
    pub returnButtonFlag: u8,
    pub unk_x29: u16,
    pub unk_x2b: u8,
    /// < Bitmask 0x4: unknown.
    pub flags: u32,
    pub unk_x30: u8,
    pub unk_x31: [u8; 23usize],
}
#[test]
fn bindgen_test_layout_SwkbdAppearArg() {
    assert_eq!(
        ::core::mem::size_of::<SwkbdAppearArg>(),
        72usize,
        concat!("Size of: ", stringify!(SwkbdAppearArg))
    );
    assert_eq!(
        ::core::mem::align_of::<SwkbdAppearArg>(),
        1usize,
        concat!("Alignment of ", stringify!(SwkbdAppearArg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdAppearArg>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdAppearArg),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdAppearArg>())).okButtonText as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdAppearArg),
            "::",
            stringify!(okButtonText)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdAppearArg>())).leftButtonText as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdAppearArg),
            "::",
            stringify!(leftButtonText)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdAppearArg>())).rightButtonText as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdAppearArg),
            "::",
            stringify!(rightButtonText)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdAppearArg>())).dicFlag as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdAppearArg),
            "::",
            stringify!(dicFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdAppearArg>())).unk_x1b as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdAppearArg),
            "::",
            stringify!(unk_x1b)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdAppearArg>())).keySetDisableBitmask as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdAppearArg),
            "::",
            stringify!(keySetDisableBitmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdAppearArg>())).unk_x20 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdAppearArg),
            "::",
            stringify!(unk_x20)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdAppearArg>())).unk_x24 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdAppearArg),
            "::",
            stringify!(unk_x24)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdAppearArg>())).returnButtonFlag as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdAppearArg),
            "::",
            stringify!(returnButtonFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdAppearArg>())).unk_x29 as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdAppearArg),
            "::",
            stringify!(unk_x29)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdAppearArg>())).unk_x2b as *const _ as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdAppearArg),
            "::",
            stringify!(unk_x2b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdAppearArg>())).flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdAppearArg),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdAppearArg>())).unk_x30 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdAppearArg),
            "::",
            stringify!(unk_x30)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdAppearArg>())).unk_x31 as *const _ as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdAppearArg),
            "::",
            stringify!(unk_x31)
        )
    );
}
#[repr(C, packed)]
pub struct SwkbdInlineCalcArg {
    pub unk_x0: u32,
    /// < Size of this struct.
    pub size: u16,
    pub unk_x6: u8,
    pub unk_x7: u8,
    pub flags: u64,
    /// < Flags bitmask 0x1.
    pub initArg: SwkbdInitializeArg,
    /// < Flags bitmask 0x2.
    pub volume: f32,
    /// < Flags bitmask 0x10.
    pub cursorPos: s32,
    pub appearArg: SwkbdAppearArg,
    /// < Flags bitmask 0x8.
    pub inputText: [u16; 506usize],
    /// < Flags bitmask 0x20.
    pub utf8Mode: u8,
    pub unk_x45d: u8,
    /// < Flags bitmask 0x8000. Only available with 5.0.0+.
    pub enableBackspace: u8,
    pub unk_x45f: [u8; 3usize],
    /// < Flags bitmask 0x200.
    pub keytopAsFloating: u8,
    /// < Flags bitmask 0x100.
    pub footerScalable: u8,
    /// < Flags bitmask 0x100.
    pub alphaEnabledInInputMode: u8,
    /// < Flags bitmask 0x100.
    pub inputModeFadeType: u8,
    /// < Flags bitmask 0x200.
    pub disableTouch: u8,
    /// < Flags bitmask 0x800.
    pub disableUSBKeyboard: u8,
    pub unk_x468: [u8; 5usize],
    pub unk_x46d: u16,
    pub unk_x46f: u8,
    /// < Flags bitmask 0x200.
    pub keytopScaleX: f32,
    /// < Flags bitmask 0x200.
    pub keytopScaleY: f32,
    /// < Flags bitmask 0x200.
    pub keytopTranslateX: f32,
    /// < Flags bitmask 0x200.
    pub keytopTranslateY: f32,
    /// < Flags bitmask 0x100.
    pub keytopBgAlpha: f32,
    /// < Flags bitmask 0x100.
    pub footerBgAlpha: f32,
    /// < Flags bitmask 0x200.
    pub balloonScale: f32,
    pub unk_x48c: f32,
    pub unk_x490: [u8; 12usize],
    pub seGroup: u8,
    /// < Flags bitmask: enable=0x2000, disable=0x4000. Only available with 5.0.0+.
    pub pad_x49d: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_SwkbdInlineCalcArg() {
    assert_eq!(
        ::core::mem::size_of::<SwkbdInlineCalcArg>(),
        1184usize,
        concat!("Size of: ", stringify!(SwkbdInlineCalcArg))
    );
    assert_eq!(
        ::core::mem::align_of::<SwkbdInlineCalcArg>(),
        1usize,
        concat!("Alignment of ", stringify!(SwkbdInlineCalcArg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).unk_x0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(unk_x0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).unk_x6 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(unk_x6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).unk_x7 as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(unk_x7)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).initArg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(initArg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).volume as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(volume)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).cursorPos as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(cursorPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).appearArg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(appearArg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).inputText as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(inputText)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).utf8Mode as *const _ as usize },
        1116usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(utf8Mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).unk_x45d as *const _ as usize },
        1117usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(unk_x45d)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).enableBackspace as *const _ as usize
        },
        1118usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(enableBackspace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).unk_x45f as *const _ as usize },
        1119usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(unk_x45f)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).keytopAsFloating as *const _ as usize
        },
        1122usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(keytopAsFloating)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).footerScalable as *const _ as usize
        },
        1123usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(footerScalable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).alphaEnabledInInputMode as *const _
                as usize
        },
        1124usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(alphaEnabledInInputMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).inputModeFadeType as *const _ as usize
        },
        1125usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(inputModeFadeType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).disableTouch as *const _ as usize
        },
        1126usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(disableTouch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).disableUSBKeyboard as *const _ as usize
        },
        1127usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(disableUSBKeyboard)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).unk_x468 as *const _ as usize },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(unk_x468)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).unk_x46d as *const _ as usize },
        1133usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(unk_x46d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).unk_x46f as *const _ as usize },
        1135usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(unk_x46f)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).keytopScaleX as *const _ as usize
        },
        1136usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(keytopScaleX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).keytopScaleY as *const _ as usize
        },
        1140usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(keytopScaleY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).keytopTranslateX as *const _ as usize
        },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(keytopTranslateX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).keytopTranslateY as *const _ as usize
        },
        1148usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(keytopTranslateY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).keytopBgAlpha as *const _ as usize
        },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(keytopBgAlpha)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).footerBgAlpha as *const _ as usize
        },
        1156usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(footerBgAlpha)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).balloonScale as *const _ as usize
        },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(balloonScale)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).unk_x48c as *const _ as usize },
        1164usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(unk_x48c)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).unk_x490 as *const _ as usize },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(unk_x490)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).seGroup as *const _ as usize },
        1180usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(seGroup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInlineCalcArg>())).pad_x49d as *const _ as usize },
        1181usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInlineCalcArg),
            "::",
            stringify!(pad_x49d)
        )
    );
}
/// Struct data for SwkbdInline Interactive reply storage ChangedString*, at the end following the string.
#[repr(C)]
pub struct SwkbdChangedStringArg {
    /// < String length in characters, without NUL-terminator.
    pub stringLen: u32,
    /// < Starting cursorPos for the current dictionary word in the current text string. -1 for none.
    pub dicStartCursorPos: s32,
    /// < Ending cursorPos for the current dictionary word in the current text string. -1 for none.
    pub dicEndCursorPos: s32,
    /// < Cursor position.
    pub cursorPos: s32,
}
#[test]
fn bindgen_test_layout_SwkbdChangedStringArg() {
    assert_eq!(
        ::core::mem::size_of::<SwkbdChangedStringArg>(),
        16usize,
        concat!("Size of: ", stringify!(SwkbdChangedStringArg))
    );
    assert_eq!(
        ::core::mem::align_of::<SwkbdChangedStringArg>(),
        4usize,
        concat!("Alignment of ", stringify!(SwkbdChangedStringArg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdChangedStringArg>())).stringLen as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdChangedStringArg),
            "::",
            stringify!(stringLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdChangedStringArg>())).dicStartCursorPos as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdChangedStringArg),
            "::",
            stringify!(dicStartCursorPos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdChangedStringArg>())).dicEndCursorPos as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdChangedStringArg),
            "::",
            stringify!(dicEndCursorPos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdChangedStringArg>())).cursorPos as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdChangedStringArg),
            "::",
            stringify!(cursorPos)
        )
    );
}
/// Struct data for SwkbdInline Interactive reply storage MovedCursor*, at the end following the string.
#[repr(C)]
pub struct SwkbdMovedCursorArg {
    /// < String length in characters, without NUL-terminator.
    pub stringLen: u32,
    /// < Cursor position.
    pub cursorPos: s32,
}
#[test]
fn bindgen_test_layout_SwkbdMovedCursorArg() {
    assert_eq!(
        ::core::mem::size_of::<SwkbdMovedCursorArg>(),
        8usize,
        concat!("Size of: ", stringify!(SwkbdMovedCursorArg))
    );
    assert_eq!(
        ::core::mem::align_of::<SwkbdMovedCursorArg>(),
        4usize,
        concat!("Alignment of ", stringify!(SwkbdMovedCursorArg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdMovedCursorArg>())).stringLen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdMovedCursorArg),
            "::",
            stringify!(stringLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdMovedCursorArg>())).cursorPos as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdMovedCursorArg),
            "::",
            stringify!(cursorPos)
        )
    );
}
/// Struct data for SwkbdInline Interactive reply storage MovedTab*, at the end following the string.
#[repr(C)]
pub struct SwkbdMovedTabArg {
    pub unk_x0: u32,
    pub unk_x4: u32,
}
#[test]
fn bindgen_test_layout_SwkbdMovedTabArg() {
    assert_eq!(
        ::core::mem::size_of::<SwkbdMovedTabArg>(),
        8usize,
        concat!("Size of: ", stringify!(SwkbdMovedTabArg))
    );
    assert_eq!(
        ::core::mem::align_of::<SwkbdMovedTabArg>(),
        4usize,
        concat!("Alignment of ", stringify!(SwkbdMovedTabArg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdMovedTabArg>())).unk_x0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdMovedTabArg),
            "::",
            stringify!(unk_x0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdMovedTabArg>())).unk_x4 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdMovedTabArg),
            "::",
            stringify!(unk_x4)
        )
    );
}
/// Struct data for SwkbdInline Interactive reply storage DecidedEnter*, at the end following the string.
#[repr(C)]
pub struct SwkbdDecidedEnterArg {
    /// < String length in characters, without NUL-terminator.
    pub stringLen: u32,
}
#[test]
fn bindgen_test_layout_SwkbdDecidedEnterArg() {
    assert_eq!(
        ::core::mem::size_of::<SwkbdDecidedEnterArg>(),
        4usize,
        concat!("Size of: ", stringify!(SwkbdDecidedEnterArg))
    );
    assert_eq!(
        ::core::mem::align_of::<SwkbdDecidedEnterArg>(),
        4usize,
        concat!("Alignment of ", stringify!(SwkbdDecidedEnterArg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdDecidedEnterArg>())).stringLen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdDecidedEnterArg),
            "::",
            stringify!(stringLen)
        )
    );
}
/// This callback is used by \ref swkbdInlineUpdate when handling ChangedString* replies (text changed by the user or by \ref swkbdInlineSetInputText).
/// str is the UTF-8 string for the current text.
pub type SwkbdChangedStringCb = ::core::option::Option<
    unsafe extern "C" fn(str: *const ctypes::c_char, arg: *mut SwkbdChangedStringArg),
>;
/// This callback is used by \ref swkbdInlineUpdate when handling MovedCursor* replies.
/// str is the UTF-8 string for the current text.
pub type SwkbdMovedCursorCb = ::core::option::Option<
    unsafe extern "C" fn(str: *const ctypes::c_char, arg: *mut SwkbdMovedCursorArg),
>;
/// This callback is used by \ref swkbdInlineUpdate when handling MovedTab* replies.
/// str is the UTF-8 string for the current text.
pub type SwkbdMovedTabCb = ::core::option::Option<
    unsafe extern "C" fn(str: *const ctypes::c_char, arg: *mut SwkbdMovedTabArg),
>;
/// This callback is used by \ref swkbdInlineUpdate when handling DecidedEnter* replies (when the final text was submitted via the button).
/// str is the UTF-8 string for the current text.
pub type SwkbdDecidedEnterCb = ::core::option::Option<
    unsafe extern "C" fn(str: *const ctypes::c_char, arg: *mut SwkbdDecidedEnterArg),
>;
/// InlineKeyboard
#[repr(C)]
pub struct SwkbdInline {
    pub version: u32,
    pub holder: AppletHolder,
    pub calcArg: SwkbdInlineCalcArg,
    pub directionalButtonAssignFlag: bool,
    pub state: SwkbdState,
    pub dicCustomInitialized: bool,
    pub dicStorage: AppletStorage,
    pub wordInfoInitialized: bool,
    pub wordInfoStorage: AppletStorage,
    pub interactive_tmpbuf: *mut u8,
    pub interactive_tmpbuf_size: usize,
    pub interactive_strbuf: *mut ctypes::c_char,
    pub interactive_strbuf_size: usize,
    pub finishedInitializeCb: VoidFn,
    pub changedStringCb: SwkbdChangedStringCb,
    pub movedCursorCb: SwkbdMovedCursorCb,
    pub movedTabCb: SwkbdMovedTabCb,
    pub decidedEnterCb: SwkbdDecidedEnterCb,
    pub releasedUserWordInfoCb: VoidFn,
}
#[test]
fn bindgen_test_layout_SwkbdInline() {
    assert_eq!(
        ::core::mem::size_of::<SwkbdInline>(),
        1464usize,
        concat!("Size of: ", stringify!(SwkbdInline))
    );
    assert_eq!(
        ::core::mem::align_of::<SwkbdInline>(),
        8usize,
        concat!("Alignment of ", stringify!(SwkbdInline))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInline>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInline),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInline>())).holder as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInline),
            "::",
            stringify!(holder)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInline>())).calcArg as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInline),
            "::",
            stringify!(calcArg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdInline>())).directionalButtonAssignFlag as *const _
                as usize
        },
        1248usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInline),
            "::",
            stringify!(directionalButtonAssignFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInline>())).state as *const _ as usize },
        1252usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInline),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdInline>())).dicCustomInitialized as *const _ as usize
        },
        1256usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInline),
            "::",
            stringify!(dicCustomInitialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInline>())).dicStorage as *const _ as usize },
        1264usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInline),
            "::",
            stringify!(dicStorage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdInline>())).wordInfoInitialized as *const _ as usize
        },
        1320usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInline),
            "::",
            stringify!(wordInfoInitialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInline>())).wordInfoStorage as *const _ as usize },
        1328usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInline),
            "::",
            stringify!(wordInfoStorage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInline>())).interactive_tmpbuf as *const _ as usize },
        1384usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInline),
            "::",
            stringify!(interactive_tmpbuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdInline>())).interactive_tmpbuf_size as *const _ as usize
        },
        1392usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInline),
            "::",
            stringify!(interactive_tmpbuf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInline>())).interactive_strbuf as *const _ as usize },
        1400usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInline),
            "::",
            stringify!(interactive_strbuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdInline>())).interactive_strbuf_size as *const _ as usize
        },
        1408usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInline),
            "::",
            stringify!(interactive_strbuf_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdInline>())).finishedInitializeCb as *const _ as usize
        },
        1416usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInline),
            "::",
            stringify!(finishedInitializeCb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInline>())).changedStringCb as *const _ as usize },
        1424usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInline),
            "::",
            stringify!(changedStringCb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInline>())).movedCursorCb as *const _ as usize },
        1432usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInline),
            "::",
            stringify!(movedCursorCb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInline>())).movedTabCb as *const _ as usize },
        1440usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInline),
            "::",
            stringify!(movedTabCb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SwkbdInline>())).decidedEnterCb as *const _ as usize },
        1448usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInline),
            "::",
            stringify!(decidedEnterCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SwkbdInline>())).releasedUserWordInfoCb as *const _ as usize
        },
        1456usize,
        concat!(
            "Offset of field: ",
            stringify!(SwkbdInline),
            "::",
            stringify!(releasedUserWordInfoCb)
        )
    );
}
extern "C" {
    /// @brief Creates a SwkbdConfig struct.
    /// @param c SwkbdConfig struct.
    /// @param max_dictwords Max \ref SwkbdDictWord entries, 0 for none.
    pub fn swkbdCreate(c: *mut SwkbdConfig, max_dictwords: s32) -> Result;
}
extern "C" {
    /// @brief Closes a SwkbdConfig struct.
    /// @param c SwkbdConfig struct.
    pub fn swkbdClose(c: *mut SwkbdConfig);
}
extern "C" {
    /// @brief Clears the args in the SwkbdConfig struct and initializes it with the Default Preset.
    /// @note Do not use this before \ref swkbdCreate.
    /// @note Sets the following fields: type = \ref SwkbdType_QWERTY, initialCursorPos = 1, returnButtonFlag = 1, blurBackground = 1. Pre-5.0.0: textDrawType = SwkbdTextDrawType_Box.
    /// @param c SwkbdConfig struct.
    pub fn swkbdConfigMakePresetDefault(c: *mut SwkbdConfig);
}
extern "C" {
    /// @brief Clears the args in the SwkbdConfig struct and initializes it with the Password Preset.
    /// @note Do not use this before \ref swkbdCreate.
    /// @note Sets the following fields: type = \ref SwkbdType_QWERTY, initialCursorPos = 1, passwordFlag = 1, blurBackground = 1.
    /// @param c SwkbdConfig struct.
    pub fn swkbdConfigMakePresetPassword(c: *mut SwkbdConfig);
}
extern "C" {
    /// @brief Clears the args in the SwkbdConfig struct and initializes it with the UserName Preset.
    /// @note Do not use this before \ref swkbdCreate.
    /// @note Sets the following fields: type = \ref SwkbdType_Normal, keySetDisableBitmask = SwkbdKeyDisableBitmask_UserName, initialCursorPos = 1, blurBackground = 1.
    /// @param c SwkbdConfig struct.
    pub fn swkbdConfigMakePresetUserName(c: *mut SwkbdConfig);
}
extern "C" {
    /// @brief Clears the args in the SwkbdConfig struct and initializes it with the DownloadCode Preset.
    /// @note Do not use this before \ref swkbdCreate.
    /// @note Sets the following fields: type = \ref SwkbdType_Normal (\ref SwkbdType_QWERTY on 5.0.0+), keySetDisableBitmask = SwkbdKeyDisableBitmask_DownloadCode, initialCursorPos = 1, blurBackground = 1. 5.0.0+: stringLenMax = 16, stringLenMaxExt = 1, textDrawType = SwkbdTextDrawType_DownloadCode. unk_x3e0[0-2] = 0x3, 0x7, and 0xb.
    /// @param c SwkbdConfig struct.
    pub fn swkbdConfigMakePresetDownloadCode(c: *mut SwkbdConfig);
}
extern "C" {
    /// @brief Sets the Ok button text. The default is "".
    /// @param c SwkbdConfig struct.
    /// @param str UTF-8 input string.
    pub fn swkbdConfigSetOkButtonText(c: *mut SwkbdConfig, str: *const ctypes::c_char);
}
extern "C" {
    /// @brief Sets the LeftOptionalSymbolKey, for \ref SwkbdType_NumPad. The default is "".
    /// @param c SwkbdConfig struct.
    /// @param str UTF-8 input string.
    pub fn swkbdConfigSetLeftOptionalSymbolKey(c: *mut SwkbdConfig, str: *const ctypes::c_char);
}
extern "C" {
    /// @brief Sets the RightOptionalSymbolKey, for \ref SwkbdType_NumPad. The default is "".
    /// @param c SwkbdConfig struct.
    /// @param str UTF-8 input string.
    pub fn swkbdConfigSetRightOptionalSymbolKey(c: *mut SwkbdConfig, str: *const ctypes::c_char);
}
extern "C" {
    /// @brief Sets the Header text. The default is "".
    /// @note See \ref SwkbdArgV0 stringLenMax.
    /// @param c SwkbdConfig struct.
    /// @param str UTF-8 input string.
    pub fn swkbdConfigSetHeaderText(c: *mut SwkbdConfig, str: *const ctypes::c_char);
}
extern "C" {
    /// @brief Sets the Sub text. The default is "".
    /// @note See \ref SwkbdArgV0 stringLenMax.
    /// @param c SwkbdConfig struct.
    /// @param str UTF-8 input string.
    pub fn swkbdConfigSetSubText(c: *mut SwkbdConfig, str: *const ctypes::c_char);
}
extern "C" {
    /// @brief Sets the Guide text. The default is "".
    /// @note The swkbd applet only displays this when the current displayed cursor position is 0.
    /// @param c SwkbdConfig struct.
    /// @param str UTF-8 input string.
    pub fn swkbdConfigSetGuideText(c: *mut SwkbdConfig, str: *const ctypes::c_char);
}
extern "C" {
    /// @brief Sets the Initial text. The default is "".
    /// @param c SwkbdConfig struct.
    /// @param str UTF-8 input string.
    pub fn swkbdConfigSetInitialText(c: *mut SwkbdConfig, str: *const ctypes::c_char);
}
extern "C" {
    /// @brief Sets the user dictionary.
    /// @param c SwkbdConfig struct.
    /// @param input Input data.
    /// @param entries Total entries in the buffer.
    pub fn swkbdConfigSetDictionary(c: *mut SwkbdConfig, input: *const SwkbdDictWord, entries: s32);
}
extern "C" {
    /// @brief Sets the TextCheck callback.
    /// @param c SwkbdConfig struct.
    /// @param cb \ref SwkbdTextCheckCb callback.
    pub fn swkbdConfigSetTextCheckCallback(c: *mut SwkbdConfig, cb: SwkbdTextCheckCb);
}
extern "C" {
    /// @brief Launch swkbd with the specified config. This will return once swkbd is finished running.
    /// @note The string buffer is also used for the buffer passed to the \ref SwkbdTextCheckCb, when it's set. Hence, in that case this buffer should be large enough to handle TextCheck string input/output. The size passed to the callback is the same size passed here, -1.
    /// @param c SwkbdConfig struct.
    /// @param out_string UTF-8 Output string buffer.
    /// @param out_string_size UTF-8 Output string buffer size, including NUL-terminator.
    pub fn swkbdShow(
        c: *mut SwkbdConfig,
        out_string: *mut ctypes::c_char,
        out_string_size: usize,
    ) -> Result;
}
extern "C" {
    /// @brief Creates a SwkbdInline object. Only available on 2.0.0+.
    /// @note This is essentially an asynchronous version of the regular swkbd.
    /// @note This calls \ref swkbdInlineSetUtf8Mode internally with flag=true.
    /// @param s SwkbdInline object.
    pub fn swkbdInlineCreate(s: *mut SwkbdInline) -> Result;
}
extern "C" {
    /// @brief Closes a SwkbdInline object. If the applet is running, this will tell the applet to exit, then wait for the applet to exit + applet exit handling.
    /// @param s SwkbdInline object.
    pub fn swkbdInlineClose(s: *mut SwkbdInline) -> Result;
}
extern "C" {
    /// @brief Launches the applet with the SwkbdInline object.
    /// @param s SwkbdInline object.
    pub fn swkbdInlineLaunch(s: *mut SwkbdInline) -> Result;
}
extern "C" {
    /// @brief Handles updating SwkbdInline state, this should be called periodically.
    /// @note Handles applet exit if needed, and also sends the \ref SwkbdInlineCalcArg to the applet if needed. Hence, this should be called at some point after writing to \ref SwkbdInlineCalcArg.
    /// @note Handles applet Interactive storage output when needed.
    /// @param s SwkbdInline object.
    /// @param out_state Optional output \ref SwkbdState.
    pub fn swkbdInlineUpdate(s: *mut SwkbdInline, out_state: *mut SwkbdState) -> Result;
}
extern "C" {
    /// @brief Sets the FinishedInitialize callback, used by \ref swkbdInlineUpdate. The default is NULL for none.
    /// @param s SwkbdInline object.
    /// @param cb Callback
    pub fn swkbdInlineSetFinishedInitializeCallback(s: *mut SwkbdInline, cb: VoidFn);
}
extern "C" {
    /// @brief Sets the ChangedString callback, used by \ref swkbdInlineUpdate. The default is NULL for none.
    /// @param s SwkbdInline object.
    /// @param cb \ref SwkbdChangedStringCb Callback
    pub fn swkbdInlineSetChangedStringCallback(s: *mut SwkbdInline, cb: SwkbdChangedStringCb);
}
extern "C" {
    /// @brief Sets the MovedCursor callback, used by \ref swkbdInlineUpdate. The default is NULL for none.
    /// @param s SwkbdInline object.
    /// @param cb \ref SwkbdMovedCursorCb Callback
    pub fn swkbdInlineSetMovedCursorCallback(s: *mut SwkbdInline, cb: SwkbdMovedCursorCb);
}
extern "C" {
    /// @brief Sets the MovedTab callback, used by \ref swkbdInlineUpdate. The default is NULL for none.
    /// @param s SwkbdInline object.
    /// @param cb \ref SwkbdMovedTabCb Callback
    pub fn swkbdInlineSetMovedTabCallback(s: *mut SwkbdInline, cb: SwkbdMovedTabCb);
}
extern "C" {
    /// @brief Sets the DecidedEnter callback, used by \ref swkbdInlineUpdate. The default is NULL for none.
    /// @param s SwkbdInline object.
    /// @param cb \ref SwkbdDecidedEnterCb Callback
    pub fn swkbdInlineSetDecidedEnterCallback(s: *mut SwkbdInline, cb: SwkbdDecidedEnterCb);
}
extern "C" {
    /// @brief Sets the ReleasedUserWordInfo callback, used by \ref swkbdInlineUpdate. The default is NULL for none.
    /// @param s SwkbdInline object.
    /// @param cb Callback
    pub fn swkbdInlineSetReleasedUserWordInfoCallback(s: *mut SwkbdInline, cb: VoidFn);
}
extern "C" {
    /// @brief Appear the kbd and set \ref SwkbdAppearArg.
    /// @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
    /// @param s SwkbdInline object.
    /// @param arg Input SwkbdAppearArg.
    pub fn swkbdInlineAppear(s: *mut SwkbdInline, arg: *mut SwkbdAppearArg);
}
extern "C" {
    /// @brief Disappear the kbd.
    /// @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
    /// @param s SwkbdInline object.
    pub fn swkbdInlineDisappear(s: *mut SwkbdInline);
}
extern "C" {
    /// @brief Creates a \ref SwkbdAppearArg which can then be passed to \ref swkbdInlineAppear. arg is initialized with the defaults, with type being set to the input type.
    /// @param arg Output \ref SwkbdAppearArg.
    /// @param type \ref SwkbdType type
    pub fn swkbdInlineMakeAppearArg(arg: *mut SwkbdAppearArg, type_: SwkbdType);
}
extern "C" {
    /// @brief Sets okButtonText for the specified SwkbdAppearArg, which was previously initialized with \ref swkbdInlineMakeAppearArg.
    /// @param arg \ref SwkbdAppearArg
    /// @param str Input UTF-8 string for the Ok button text, this can be empty/NULL to use the default.
    pub fn swkbdInlineAppearArgSetOkButtonText(
        arg: *mut SwkbdAppearArg,
        str: *const ctypes::c_char,
    );
}
extern "C" {
    /// @brief Sets the LeftButtonText, for \ref SwkbdType_NumPad. The default is "". Equivalent to \ref swkbdConfigSetLeftOptionalSymbolKey.
    /// @param arg \ref SwkbdAppearArg, previously initialized by \ref swkbdInlineMakeAppearArg.
    /// @param str UTF-8 input string.
    pub fn swkbdInlineAppearArgSetLeftButtonText(
        arg: *mut SwkbdAppearArg,
        str: *const ctypes::c_char,
    );
}
extern "C" {
    /// @brief Sets the RightButtonText, for \ref SwkbdType_NumPad. The default is "". Equivalent to \ref swkbdConfigSetRightOptionalSymbolKey.
    /// @param arg \ref SwkbdAppearArg, previously initialized by \ref swkbdInlineMakeAppearArg.
    /// @param str UTF-8 input string.
    pub fn swkbdInlineAppearArgSetRightButtonText(
        arg: *mut SwkbdAppearArg,
        str: *const ctypes::c_char,
    );
}
extern "C" {
    /// @brief Sets the audio volume.
    /// @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
    /// @param s SwkbdInline object.
    /// @param volume Volume
    pub fn swkbdInlineSetVolume(s: *mut SwkbdInline, volume: f32);
}
extern "C" {
    /// @brief Sets the current input text string. Overrides the entire user input string if the user previously entered any text.
    /// @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
    /// @note This will not affect the cursor position, see \ref swkbdInlineSetCursorPos for that.
    /// @param s SwkbdInline object.
    /// @param str UTF-8 input string.
    pub fn swkbdInlineSetInputText(s: *mut SwkbdInline, str: *const ctypes::c_char);
}
extern "C" {
    /// @brief Sets the cursor character position in the string.
    /// @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
    /// @param s SwkbdInline object.
    /// @param pos Position
    pub fn swkbdInlineSetCursorPos(s: *mut SwkbdInline, pos: s32);
}
extern "C" {
    /// @brief Sets the UserWordInfo.
    /// @note Not avilable when \ref SwkbdState is above ::SwkbdState_Initialized. Can't be used if this was already used previously.
    /// @note The specified buffer must not be used after this, until \ref swkbdInlineClose is used.
    /// @note \ref swkbdInlineUpdate must be called at some point afterwards.
    /// @note If input==NULL or total_entries==0, this will just call \ref swkbdInlineUnsetUserWordInfo internally.
    /// @param s SwkbdInline object.
    /// @param input Input data.
    /// @param entries Total entries in the buffer.
    pub fn swkbdInlineSetUserWordInfo(
        s: *mut SwkbdInline,
        input: *const SwkbdDictWord,
        entries: s32,
    ) -> Result;
}
extern "C" {
    /// @brief Request UnsetUserWordInfo.
    /// @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
    /// @note Not avilable when \ref SwkbdState is above ::SwkbdState_Initialized.
    /// @param s SwkbdInline object.
    pub fn swkbdInlineUnsetUserWordInfo(s: *mut SwkbdInline) -> Result;
}
extern "C" {
    /// @brief Sets the utf8Mode.
    /// @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
    /// @note Automatically used internally by \ref swkbdInlineCreate.
    /// @param s SwkbdInline object.
    /// @param flag Flag
    pub fn swkbdInlineSetUtf8Mode(s: *mut SwkbdInline, flag: bool);
}
extern "C" {
    /// @brief Sets the CustomizeDic.
    /// @note Not avilable when \ref SwkbdState is above ::SwkbdState_Initialized. Can't be used if this was already used previously.
    /// @note The specified buffer must not be used after this, until \ref swkbdInlineClose is used. However, it will also become available once \ref swkbdInlineUpdate handles SwkbdReplyType_UnsetCustomizeDic internally.
    /// @param s SwkbdInline object.
    /// @param buffer 0x1000-byte aligned buffer.
    /// @param size 0x1000-byte aligned buffer size.
    /// @param info Input \ref SwkbdCustomizeDicInfo
    pub fn swkbdInlineSetCustomizeDic(
        s: *mut SwkbdInline,
        buffer: *mut ctypes::c_void,
        size: usize,
        info: *mut SwkbdCustomizeDicInfo,
    ) -> Result;
}
extern "C" {
    /// @brief Request UnsetCustomizeDic.
    /// @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
    /// @note Not avilable when \ref SwkbdState is above ::SwkbdState_Initialized.
    /// @param s SwkbdInline object.
    pub fn swkbdInlineUnsetCustomizeDic(s: *mut SwkbdInline);
}
extern "C" {
    /// @brief Sets InputModeFadeType.
    /// @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
    /// @param s SwkbdInline object.
    /// @param type Type
    pub fn swkbdInlineSetInputModeFadeType(s: *mut SwkbdInline, type_: u8);
}
extern "C" {
    /// @brief Sets AlphaEnabledInInputMode.
    /// @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
    /// @param s SwkbdInline object.
    /// @param flag Flag
    pub fn swkbdInlineSetAlphaEnabledInInputMode(s: *mut SwkbdInline, flag: bool);
}
extern "C" {
    /// @brief Sets KeytopBgAlpha.
    /// @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
    /// @param s SwkbdInline object.
    /// @param alpha Alpha, clamped to range 0.0f..1.0f.
    pub fn swkbdInlineSetKeytopBgAlpha(s: *mut SwkbdInline, alpha: f32);
}
extern "C" {
    /// @brief Sets FooterBgAlpha.
    /// @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
    /// @param s SwkbdInline object.
    /// @param alpha Alpha, clamped to range 0.0f..1.0f.
    pub fn swkbdInlineSetFooterBgAlpha(s: *mut SwkbdInline, alpha: f32);
}
extern "C" {
    /// @brief Sets gfx scaling. Configures KeytopScale* and BalloonScale based on the input value.
    /// @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
    /// @param s SwkbdInline object.
    /// @param scale Scale
    pub fn swkbdInlineSetKeytopScale(s: *mut SwkbdInline, scale: f32);
}
extern "C" {
    /// @brief Sets gfx translation for the displayed swkbd image position.
    /// @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
    /// @param s SwkbdInline object.
    /// @param x X
    /// @param y Y
    pub fn swkbdInlineSetKeytopTranslate(s: *mut SwkbdInline, x: f32, y: f32);
}
extern "C" {
    /// @brief Sets KeytopAsFloating.
    /// @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
    /// @param s SwkbdInline object.
    /// @param flag Flag
    pub fn swkbdInlineSetKeytopAsFloating(s: *mut SwkbdInline, flag: bool);
}
extern "C" {
    /// @brief Sets FooterScalable.
    /// @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
    /// @param s SwkbdInline object.
    /// @param flag Flag
    pub fn swkbdInlineSetFooterScalable(s: *mut SwkbdInline, flag: bool);
}
extern "C" {
    /// @brief Sets whether touch is enabled. The default is enabled.
    /// @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
    /// @param s SwkbdInline object.
    /// @param flag Flag
    pub fn swkbdInlineSetTouchFlag(s: *mut SwkbdInline, flag: bool);
}
extern "C" {
    /// @brief Sets whether USB-keyboard is enabled. The default is enabled.
    /// @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
    /// @param s SwkbdInline object.
    /// @param flag Flag
    pub fn swkbdInlineSetUSBKeyboardFlag(s: *mut SwkbdInline, flag: bool);
}
extern "C" {
    /// @brief Sets whether DirectionalButtonAssign is enabled. The default is disabled. Only available on 4.0.0+.
    /// @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
    /// @param s SwkbdInline object.
    /// @param flag Flag
    pub fn swkbdInlineSetDirectionalButtonAssignFlag(s: *mut SwkbdInline, flag: bool);
}
extern "C" {
    /// @brief Sets whether the specified SeGroup (sound effect) is enabled. The default is enabled. Only available on 5.0.0+.
    /// @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect. If called again with a different seGroup, \ref swkbdInlineUpdate must be called prior to calling this again.
    /// @param s SwkbdInline object.
    /// @param seGroup SeGroup
    /// @param flag Flag
    pub fn swkbdInlineSetSeGroup(s: *mut SwkbdInline, seGroup: u8, flag: bool);
}
extern "C" {
    /// @brief Sets whether the backspace button is enabled. The default is enabled. Only available on 5.0.0+.
    /// @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
    /// @param s SwkbdInline object.
    /// @param flag Flag
    pub fn swkbdInlineSetBackspaceFlag(s: *mut SwkbdInline, flag: bool);
}
pub const WebShimKind_WebShimKind_Shop: WebShimKind = 1;
pub const WebShimKind_WebShimKind_Login: WebShimKind = 2;
pub const WebShimKind_WebShimKind_Offline: WebShimKind = 3;
pub const WebShimKind_WebShimKind_Share: WebShimKind = 4;
pub const WebShimKind_WebShimKind_Web: WebShimKind = 5;
pub const WebShimKind_WebShimKind_Wifi: WebShimKind = 6;
pub const WebShimKind_WebShimKind_Lobby: WebShimKind = 7;
/// This indicates the type of web-applet.
pub type WebShimKind = u32;
/// < User pressed the X button to exit.
pub const WebExitReason_WebExitReason_ExitButton: WebExitReason = 0;
/// < User pressed the B button to exit, on the initial page.
pub const WebExitReason_WebExitReason_BackButton: WebExitReason = 1;
/// < The applet exited since \ref webConfigRequestExit was used.
pub const WebExitReason_WebExitReason_Requested: WebExitReason = 2;
/// < The applet exited due to LastUrl handling, see \ref webReplyGetLastUrl.
pub const WebExitReason_WebExitReason_LastUrl: WebExitReason = 3;
/// < The applet exited after displaying an error dialog.
pub const WebExitReason_WebExitReason_ErrorDialog: WebExitReason = 7;
/// ExitReason
pub type WebExitReason = u32;
/// Struct for the WebWifi applet input storage.
#[repr(C, packed)]
pub struct WebWifiPageArg {
    /// < Official sw sets this to 0 with appletStorageWrite, separately from the rest of the config struct.
    pub unk_x0: u32,
    /// < Connection-test URL.
    pub conntest_url: [ctypes::c_char; 256usize],
    /// < Initial URL navigated to by the applet.
    pub initial_url: [ctypes::c_char; 1024usize],
    /// < NIFM Network UUID. Only used by the applet when conntest_url is set.
    pub uuid: u128,
    /// < Input value for nifm cmd SetRequirementByRevision. Only used by the applet when conntest_url is set.
    pub rev: u32,
}
#[test]
fn bindgen_test_layout_WebWifiPageArg() {
    assert_eq!(
        ::core::mem::size_of::<WebWifiPageArg>(),
        1304usize,
        concat!("Size of: ", stringify!(WebWifiPageArg))
    );
    assert_eq!(
        ::core::mem::align_of::<WebWifiPageArg>(),
        1usize,
        concat!("Alignment of ", stringify!(WebWifiPageArg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WebWifiPageArg>())).unk_x0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WebWifiPageArg),
            "::",
            stringify!(unk_x0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WebWifiPageArg>())).conntest_url as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WebWifiPageArg),
            "::",
            stringify!(conntest_url)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WebWifiPageArg>())).initial_url as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(WebWifiPageArg),
            "::",
            stringify!(initial_url)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WebWifiPageArg>())).uuid as *const _ as usize },
        1284usize,
        concat!(
            "Offset of field: ",
            stringify!(WebWifiPageArg),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WebWifiPageArg>())).rev as *const _ as usize },
        1300usize,
        concat!(
            "Offset of field: ",
            stringify!(WebWifiPageArg),
            "::",
            stringify!(rev)
        )
    );
}
/// Struct for the WebWifi applet output storage.
#[repr(C, packed)]
pub struct WebWifiReturnValue {
    /// < Unknown.
    pub unk_x0: u32,
    /// < Result
    pub res: Result,
}
#[test]
fn bindgen_test_layout_WebWifiReturnValue() {
    assert_eq!(
        ::core::mem::size_of::<WebWifiReturnValue>(),
        8usize,
        concat!("Size of: ", stringify!(WebWifiReturnValue))
    );
    assert_eq!(
        ::core::mem::align_of::<WebWifiReturnValue>(),
        1usize,
        concat!("Alignment of ", stringify!(WebWifiReturnValue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WebWifiReturnValue>())).unk_x0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WebWifiReturnValue),
            "::",
            stringify!(unk_x0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WebWifiReturnValue>())).res as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WebWifiReturnValue),
            "::",
            stringify!(res)
        )
    );
}
/// Config for WebWifi.
#[repr(C)]
pub struct WebWifiConfig {
    /// < Arg data.
    pub arg: WebWifiPageArg,
}
#[test]
fn bindgen_test_layout_WebWifiConfig() {
    assert_eq!(
        ::core::mem::size_of::<WebWifiConfig>(),
        1304usize,
        concat!("Size of: ", stringify!(WebWifiConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<WebWifiConfig>(),
        1usize,
        concat!("Alignment of ", stringify!(WebWifiConfig))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WebWifiConfig>())).arg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WebWifiConfig),
            "::",
            stringify!(arg)
        )
    );
}
/// TLV storage, starts with \ref WebArgHeader followed by \ref WebArgTLV entries.
#[repr(C)]
pub struct WebCommonTLVStorage {
    /// < Raw TLV data storage.
    pub data: [u8; 8192usize],
}
#[test]
fn bindgen_test_layout_WebCommonTLVStorage() {
    assert_eq!(
        ::core::mem::size_of::<WebCommonTLVStorage>(),
        8192usize,
        concat!("Size of: ", stringify!(WebCommonTLVStorage))
    );
    assert_eq!(
        ::core::mem::align_of::<WebCommonTLVStorage>(),
        1usize,
        concat!("Alignment of ", stringify!(WebCommonTLVStorage))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WebCommonTLVStorage>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WebCommonTLVStorage),
            "::",
            stringify!(data)
        )
    );
}
/// Common struct for the applet output storage, for non-TLV-storage.
#[repr(C, packed)]
pub struct WebCommonReturnValue {
    /// < ExitReason
    pub exitReason: WebExitReason,
    /// < Padding
    pub pad: u32,
    /// < LastUrl string
    pub lastUrl: [ctypes::c_char; 4096usize],
    /// < Size of LastUrl, including NUL-terminator.
    pub lastUrlSize: u64,
}
#[test]
fn bindgen_test_layout_WebCommonReturnValue() {
    assert_eq!(
        ::core::mem::size_of::<WebCommonReturnValue>(),
        4112usize,
        concat!("Size of: ", stringify!(WebCommonReturnValue))
    );
    assert_eq!(
        ::core::mem::align_of::<WebCommonReturnValue>(),
        1usize,
        concat!("Alignment of ", stringify!(WebCommonReturnValue))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<WebCommonReturnValue>())).exitReason as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WebCommonReturnValue),
            "::",
            stringify!(exitReason)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WebCommonReturnValue>())).pad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WebCommonReturnValue),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WebCommonReturnValue>())).lastUrl as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WebCommonReturnValue),
            "::",
            stringify!(lastUrl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<WebCommonReturnValue>())).lastUrlSize as *const _ as usize
        },
        4104usize,
        concat!(
            "Offset of field: ",
            stringify!(WebCommonReturnValue),
            "::",
            stringify!(lastUrlSize)
        )
    );
}
/// Header struct at offset 0 in the web Arg storage (non-webWifi).
#[repr(C, packed)]
pub struct WebArgHeader {
    /// < Total \ref WebArgTLV entries following this struct.
    pub total_entries: u16,
    /// < Padding
    pub pad: u16,
    /// < ShimKind
    pub shimKind: WebShimKind,
}
#[test]
fn bindgen_test_layout_WebArgHeader() {
    assert_eq!(
        ::core::mem::size_of::<WebArgHeader>(),
        8usize,
        concat!("Size of: ", stringify!(WebArgHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<WebArgHeader>(),
        1usize,
        concat!("Alignment of ", stringify!(WebArgHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WebArgHeader>())).total_entries as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WebArgHeader),
            "::",
            stringify!(total_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WebArgHeader>())).pad as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(WebArgHeader),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WebArgHeader>())).shimKind as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WebArgHeader),
            "::",
            stringify!(shimKind)
        )
    );
}
/// Web TLV used in the web Arg storage.
#[repr(C, packed)]
pub struct WebArgTLV {
    /// < Type of this arg.
    pub type_: u16,
    /// < Size of the arg data following this struct.
    pub size: u16,
    /// < Padding
    pub pad: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_WebArgTLV() {
    assert_eq!(
        ::core::mem::size_of::<WebArgTLV>(),
        8usize,
        concat!("Size of: ", stringify!(WebArgTLV))
    );
    assert_eq!(
        ::core::mem::align_of::<WebArgTLV>(),
        1usize,
        concat!("Alignment of ", stringify!(WebArgTLV))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WebArgTLV>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WebArgTLV),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WebArgTLV>())).size as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(WebArgTLV),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WebArgTLV>())).pad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WebArgTLV),
            "::",
            stringify!(pad)
        )
    );
}
/// Config struct for web applets, non-WebWifi.
#[repr(C)]
pub struct WebCommonConfig {
    /// < TLV storage.
    pub arg: WebCommonTLVStorage,
    /// < AppletId
    pub appletid: AppletId,
    /// < CommonArgs applet version.
    pub version: u32,
    /// < AppletHolder
    pub holder: AppletHolder,
}
#[test]
fn bindgen_test_layout_WebCommonConfig() {
    assert_eq!(
        ::core::mem::size_of::<WebCommonConfig>(),
        8256usize,
        concat!("Size of: ", stringify!(WebCommonConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<WebCommonConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(WebCommonConfig))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WebCommonConfig>())).arg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WebCommonConfig),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WebCommonConfig>())).appletid as *const _ as usize },
        8192usize,
        concat!(
            "Offset of field: ",
            stringify!(WebCommonConfig),
            "::",
            stringify!(appletid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WebCommonConfig>())).version as *const _ as usize },
        8196usize,
        concat!(
            "Offset of field: ",
            stringify!(WebCommonConfig),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WebCommonConfig>())).holder as *const _ as usize },
        8200usize,
        concat!(
            "Offset of field: ",
            stringify!(WebCommonConfig),
            "::",
            stringify!(holder)
        )
    );
}
/// Common container struct for applets' reply data, from the output storage.
#[repr(C)]
pub struct WebCommonReply {
    /// < Type of reply: false = ret, true = storage.
    pub type_: bool,
    /// < Reply data for reply=false.
    pub ret: WebCommonReturnValue,
    /// < Reply data for reply=true.
    pub storage: WebCommonTLVStorage,
}
#[test]
fn bindgen_test_layout_WebCommonReply() {
    assert_eq!(
        ::core::mem::size_of::<WebCommonReply>(),
        12305usize,
        concat!("Size of: ", stringify!(WebCommonReply))
    );
    assert_eq!(
        ::core::mem::align_of::<WebCommonReply>(),
        1usize,
        concat!("Alignment of ", stringify!(WebCommonReply))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WebCommonReply>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WebCommonReply),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WebCommonReply>())).ret as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(WebCommonReply),
            "::",
            stringify!(ret)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WebCommonReply>())).storage as *const _ as usize },
        4113usize,
        concat!(
            "Offset of field: ",
            stringify!(WebCommonReply),
            "::",
            stringify!(storage)
        )
    );
}
/// < [1.0.0+] String, size 0xC00. Initial URL.
pub const WebArgType_WebArgType_Url: WebArgType = 1;
/// < [1.0.0+] String, size 0x400.
pub const WebArgType_WebArgType_CallbackUrl: WebArgType = 3;
/// < [1.0.0+] String, size 0x400.
pub const WebArgType_WebArgType_CallbackableUrl: WebArgType = 4;
/// < [1.0.0+] Offline-applet, u64 titleID
pub const WebArgType_WebArgType_ApplicationId: WebArgType = 5;
/// < [1.0.0+] Offline-applet, string with size 0xC00.
pub const WebArgType_WebArgType_DocumentPath: WebArgType = 6;
/// < [1.0.0+] Offline-applet, u32 enum \WebDocumentKind.
pub const WebArgType_WebArgType_DocumentKind: WebArgType = 7;
/// < [1.0.0+] Offline-applet, u64 titleID
pub const WebArgType_WebArgType_SystemDataId: WebArgType = 8;
/// < [1.0.0+] u32 enum \WebShareStartPage
pub const WebArgType_WebArgType_ShareStartPage: WebArgType = 9;
/// < [1.0.0+] String, size 0x1000.
pub const WebArgType_WebArgType_Whitelist: WebArgType = 10;
/// < [1.0.0+] u8 bool
pub const WebArgType_WebArgType_NewsFlag: WebArgType = 11;
/// < [1.0.0+] u8
pub const WebArgType_WebArgType_UnknownC: WebArgType = 12;
/// < [1.0.0+] u8
pub const WebArgType_WebArgType_UnknownD: WebArgType = 13;
/// < [1.0.0+] u128 userID, controls which user-specific savedata to mount.
pub const WebArgType_WebArgType_UserID: WebArgType = 14;
/// < [1.0.0+] Share-applet caps AlbumEntry
pub const WebArgType_WebArgType_AlbumEntry: WebArgType = 15;
/// < [1.0.0+] u8 bool
pub const WebArgType_WebArgType_ScreenShot: WebArgType = 16;
/// < [1.0.0+] u8 bool
pub const WebArgType_WebArgType_EcClientCert: WebArgType = 17;
/// < [1.0.0+] u8
pub const WebArgType_WebArgType_Unknown12: WebArgType = 18;
/// < [1.0.0+] u8 bool
pub const WebArgType_WebArgType_PlayReport: WebArgType = 19;
/// < [1.0.0+] u8
pub const WebArgType_WebArgType_Unknown14: WebArgType = 20;
/// < [1.0.0+] u8
pub const WebArgType_WebArgType_Unknown15: WebArgType = 21;
/// < [1.0.0+] u32 enum \ref WebBootDisplayKind
pub const WebArgType_WebArgType_BootDisplayKind: WebArgType = 23;
/// < [1.0.0+] u32 enum \ref WebBackgroundKind
pub const WebArgType_WebArgType_BackgroundKind: WebArgType = 24;
/// < [1.0.0+] u8 bool
pub const WebArgType_WebArgType_Footer: WebArgType = 25;
/// < [1.0.0+] u8 bool
pub const WebArgType_WebArgType_Pointer: WebArgType = 26;
/// < [1.0.0+] u32 enum \ref WebLeftStickMode
pub const WebArgType_WebArgType_LeftStickMode: WebArgType = 27;
/// < [1.0.0+] s32 KeyRepeatFrame, first param
pub const WebArgType_WebArgType_KeyRepeatFrame0: WebArgType = 28;
/// < [1.0.0+] s32 KeyRepeatFrame, second param
pub const WebArgType_WebArgType_KeyRepeatFrame1: WebArgType = 29;
/// < [1.0.0+] u8 bool. With News on [3.0.0+] this is set after BootAsMediaPlayer with the value inverted.
pub const WebArgType_WebArgType_BootAsMediaPlayerInverted: WebArgType = 30;
/// < [1.0.0+] u8 bool, DisplayUrlKind (value = (input_enumval==0x1)).
pub const WebArgType_WebArgType_DisplayUrlKind: WebArgType = 31;
/// < [2.0.0+] u8 bool
pub const WebArgType_WebArgType_BootAsMediaPlayer: WebArgType = 33;
/// < [2.0.0+] u8 bool
pub const WebArgType_WebArgType_ShopJump: WebArgType = 34;
/// < [2.0.0+] u8 bool
pub const WebArgType_WebArgType_MediaPlayerUserGestureRestriction: WebArgType = 35;
/// < [2.0.0+] String, size 0x100.
pub const WebArgType_WebArgType_LobbyParameter: WebArgType = 36;
/// < [3.0.0+] Share-applet caps ApplicationAlbumEntry
pub const WebArgType_WebArgType_ApplicationAlbumEntry: WebArgType = 38;
/// < [3.0.0+] u8 bool
pub const WebArgType_WebArgType_JsExtension: WebArgType = 39;
/// < [4.0.0+] String, size 0x100. Share-applet AdditionalCommentText.
pub const WebArgType_WebArgType_AdditionalCommentText: WebArgType = 40;
/// < [4.0.0+] u8 bool
pub const WebArgType_WebArgType_TouchEnabledOnContents: WebArgType = 41;
/// < [4.0.0+] String, size 0x80.
pub const WebArgType_WebArgType_UserAgentAdditionalString: WebArgType = 42;
/// < [4.0.0+] Share-applet 0x10-byte u8 array, AdditionalMediaData. If the user-input size is less than 0x10, the remaining data used for the TLV is cleared.
pub const WebArgType_WebArgType_AdditionalMediaData: WebArgType = 43;
/// < [4.0.0+] u8 bool
pub const WebArgType_WebArgType_MediaPlayerAutoClose: WebArgType = 44;
/// < [4.0.0+] u8 bool
pub const WebArgType_WebArgType_PageCache: WebArgType = 45;
/// < [4.0.0+] u8 bool
pub const WebArgType_WebArgType_WebAudio: WebArgType = 46;
/// < [5.0.0+] u8
pub const WebArgType_WebArgType_2F: WebArgType = 47;
/// < [5.0.0+] u8 bool Indicates that the built-in whitelist for YouTubeVideo should be used.
pub const WebArgType_WebArgType_YouTubeVideoFlag: WebArgType = 49;
/// < [5.0.0+] u32 enum \ref WebFooterFixedKind
pub const WebArgType_WebArgType_FooterFixedKind: WebArgType = 50;
/// < [5.0.0+] u8 bool
pub const WebArgType_WebArgType_PageFade: WebArgType = 51;
/// < [5.0.0+] Share-applet 0x20-byte s8 array, MediaCreatorApplicationRatingAge.
pub const WebArgType_WebArgType_MediaCreatorApplicationRatingAge: WebArgType = 52;
/// < [5.0.0+] u8 bool
pub const WebArgType_WebArgType_BootLoadingIcon: WebArgType = 53;
/// < [5.0.0+] u8 bool
pub const WebArgType_WebArgType_PageScrollIndicator: WebArgType = 54;
/// Types for \ref WebArgTLV, input storage.
pub type WebArgType = u32;
/// < [3.0.0+] u32 ShareExitReason
pub const WebReplyType_WebReplyType_ExitReason: WebReplyType = 1;
/// < [3.0.0+] string
pub const WebReplyType_WebReplyType_LastUrl: WebReplyType = 2;
/// < [3.0.0+] u64
pub const WebReplyType_WebReplyType_LastUrlSize: WebReplyType = 3;
/// < [3.0.0+] u32 SharePostResult
pub const WebReplyType_WebReplyType_SharePostResult: WebReplyType = 4;
/// < [3.0.0+] string
pub const WebReplyType_WebReplyType_PostServiceName: WebReplyType = 5;
/// < [3.0.0+] u64
pub const WebReplyType_WebReplyType_PostServiceNameSize: WebReplyType = 6;
/// < [3.0.0+] string
pub const WebReplyType_WebReplyType_PostId: WebReplyType = 7;
/// < [3.0.0+] u64
pub const WebReplyType_WebReplyType_PostIdSize: WebReplyType = 8;
/// Types for \ref WebArgTLV, output storage.
pub type WebReplyType = u32;
/// < Use the HtmlDocument NCA content from the application.
pub const WebDocumentKind_WebDocumentKind_OfflineHtmlPage: WebDocumentKind = 1;
/// < Use the LegalInformation NCA content from the application.
pub const WebDocumentKind_WebDocumentKind_ApplicationLegalInformation: WebDocumentKind = 2;
/// < Use the Data NCA content from the specified title, see also: https://switchbrew.org/wiki/Title_list#System_Data_Archives
pub const WebDocumentKind_WebDocumentKind_SystemDataPage: WebDocumentKind = 3;
/// This controls the kind of content to mount with Offline-applet.
pub type WebDocumentKind = u32;
/// < The default "/" page.
pub const WebShareStartPage_WebShareStartPage_Default: WebShareStartPage = 0;
/// < The "/settings/" page.
pub const WebShareStartPage_WebShareStartPage_Settings: WebShareStartPage = 1;
/// This controls the initial page for ShareApplet, used by \ref webShareCreate.
pub type WebShareStartPage = u32;
/// < Default. BackgroundKind is controlled by \ref WebBackgroundKind.
pub const WebBootDisplayKind_WebBootDisplayKind_Default: WebBootDisplayKind = 0;
/// < White background. Used by \ref webOfflineCreate for docKind ::WebDocumentKind_ApplicationLegalInformation/::WebDocumentKind_SystemDataPage.
pub const WebBootDisplayKind_WebBootDisplayKind_White: WebBootDisplayKind = 1;
/// < Black background.
pub const WebBootDisplayKind_WebBootDisplayKind_Black: WebBootDisplayKind = 2;
/// < Unknown. Used by \ref webShareCreate.
pub const WebBootDisplayKind_WebBootDisplayKind_Unknown3: WebBootDisplayKind = 3;
/// < Unknown. Used by \ref webLobbyCreate.
pub const WebBootDisplayKind_WebBootDisplayKind_Unknown4: WebBootDisplayKind = 4;
/// Kind values for \ref webConfigSetBootDisplayKind. Controls the background color while displaying the loading screen during applet boot. Also controls the BackgroundKind when value is non-zero.
pub type WebBootDisplayKind = u32;
/// < Default. Same as ::WebBootDisplayKind_White/::WebBootDisplayKind_Black, determined via ::WebArgType_BootAsMediaPlayer.
pub const WebBackgroundKind_WebBackgroundKind_Default: WebBackgroundKind = 0;
/// < Unknown. Same as ::WebBootDisplayKind_Unknown3.
pub const WebBackgroundKind_WebBackgroundKind_Unknown1: WebBackgroundKind = 1;
/// < Unknown. Same as ::WebBootDisplayKind_Unknown4. Used by \ref webLobbyCreate.
pub const WebBackgroundKind_WebBackgroundKind_Unknown2: WebBackgroundKind = 2;
/// Kind values for \ref webConfigSetBackgroundKind. Controls the background color while displaying the loading screen during applet boot. Only used when \ref WebBootDisplayKind is ::WebBootDisplayKind_Default. If the applet was not launched by an Application, the applet will only use WebBackgroundKind_Default.
pub type WebBackgroundKind = u32;
/// < The user can directly control the pointer via the left-stick.
pub const WebLeftStickMode_WebLeftStickMode_Pointer: WebLeftStickMode = 0;
/// < The user can only select elements on the page via the left-stick.
pub const WebLeftStickMode_WebLeftStickMode_Cursor: WebLeftStickMode = 1;
/// Mode values for \ref webConfigSetLeftStickMode. Controls the initial mode, this can be toggled by the user via the pressing the left-stick button. If the Pointer flag is set to false (\ref webConfigSetPointer), only ::WebLeftStickMode_Cursor will be used and mode toggle by the user is disabled (input value ignored).
pub type WebLeftStickMode = u32;
/// < Default. Footer is hidden while scrolling.
pub const WebFooterFixedKind_WebFooterFixedKind_Default: WebFooterFixedKind = 0;
/// < Footer is always displayed regardless of scrolling.
pub const WebFooterFixedKind_WebFooterFixedKind_Always: WebFooterFixedKind = 1;
/// < Footer is hidden regardless of scrolling.
pub const WebFooterFixedKind_WebFooterFixedKind_Hidden: WebFooterFixedKind = 2;
/// Kind values for \ref webConfigSetFooterFixedKind. Controls UI footer display behaviour.
pub type WebFooterFixedKind = u32;
extern "C" {
    /// @brief Creates the config for WifiWebAuthApplet. This is the captive portal applet.
    /// @param config WebWifiConfig object.
    /// @param conntest_url URL used for the connection-test requests. When empty/NULL the applet will test the connection with nifm and throw an error on failure.
    /// @param initial_url Initial URL navigated to by the applet.
    /// @param uuid NIFM Network UUID, for nifm cmd SetNetworkProfileId. Value 0 can be used. Only used by the applet when conntest_url is set.
    /// @param rev Input value for nifm cmd SetRequirementByRevision. Value 0 can be used. Only used by the applet when conntest_url is set.
    pub fn webWifiCreate(
        config: *mut WebWifiConfig,
        conntest_url: *const ctypes::c_char,
        initial_url: *const ctypes::c_char,
        uuid: u128,
        rev: u32,
    );
}
extern "C" {
    /// @brief Launches WifiWebAuthApplet with the specified config and waits for it to exit.
    /// @param config WebWifiConfig object.
    /// @param out Optional output applet reply data, can be NULL.
    pub fn webWifiShow(config: *mut WebWifiConfig, out: *mut WebWifiReturnValue) -> Result;
}
extern "C" {
    /// @brief Creates the config for WebApplet. This applet uses an URL whitelist loaded from the user-process host title, which is only loaded when running under an Application.
    /// @note Sets ::WebArgType_UnknownD, and ::WebArgType_Unknown12 on pre-3.0.0, to value 1.
    /// @param config WebCommonConfig object.
    /// @param url Initial URL navigated to by the applet.
    pub fn webPageCreate(config: *mut WebCommonConfig, url: *const ctypes::c_char) -> Result;
}
extern "C" {
    /// @brief Creates the config for WebApplet. This is based on \ref webPageCreate, for News. Hence other functions referencing \ref webPageCreate also apply to this.
    /// @note The domain from the input URL is automatically whitelisted, in addition to any already loaded whitelist.
    /// @note Sets ::WebArgType_UnknownD to value 1, and sets ::WebArgType_NewsFlag to true. Also uses \ref webConfigSetEcClientCert and \ref webConfigSetShopJump with flag=true.
    /// @param config WebCommonConfig object.
    /// @param url Initial URL navigated to by the applet.
    pub fn webNewsCreate(config: *mut WebCommonConfig, url: *const ctypes::c_char) -> Result;
}
extern "C" {
    /// @brief Creates the config for WebApplet. This is based on \ref webPageCreate, for YouTubeVideo. Hence other functions referencing \ref webPageCreate also apply to this. This uses a whitelist which essentially only allows youtube embed/ URLs (without mounting content from the host title).
    /// @note This is only available on [5.0.0+].
    /// @note Sets ::WebArgType_UnknownD to value 1, and sets ::WebArgType_YouTubeVideoFlag to true. Also uses \ref webConfigSetBootAsMediaPlayer with flag=true.
    /// @param config WebCommonConfig object.
    /// @param url Initial URL navigated to by the applet.
    pub fn webYouTubeVideoCreate(
        config: *mut WebCommonConfig,
        url: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    /// @brief Creates the config for Offline-applet. This applet uses local content loaded from titles.
    /// @note Uses \ref webConfigSetLeftStickMode with ::WebLeftStickMode_Cursor and sets ::WebArgType_BootAsMediaPlayerInverted to false. Uses \ref webConfigSetPointer with flag = docKind == ::WebDocumentKind_OfflineHtmlPage.
    /// @note For docKind ::WebDocumentKind_ApplicationLegalInformation / ::WebDocumentKind_SystemDataPage, uses \ref webConfigSetFooter with flag=true and \ref webConfigSetBackgroundKind with ::WebBackgroundKind_Default.
    /// @note For docKind ::WebDocumentKind_SystemDataPage, uses \ref webConfigSetBootDisplayKind with ::WebBootDisplayKind_White.
    /// @note Sets ::WebArgType_Unknown14/::WebArgType_Unknown15 to value 1. With docKind ::WebDocumentKind_ApplicationLegalInformation, uses \ref webConfigSetBootDisplayKind with ::WebBootDisplayKind_White.
    /// @note Sets ::WebArgType_UnknownC to value 1.
    /// @note With docKind ::WebDocumentKind_ApplicationLegalInformation, uses \ref webConfigSetEcClientCert with flag=true.
    /// @note With docKind ::WebDocumentKind_OfflineHtmlPage on pre-3.0.0, sets ::WebArgType_Unknown12 to value 1.
    /// @note Lastly, sets the TLVs as needed for the input params.
    /// @param config WebCommonConfig object.
    /// @param docKind \ref WebDocumentKind
    /// @param titleID Title to load the content from. With docKind = ::WebDocumentKind_OfflineHtmlPage, titleID=0 should be used to specify the user-process titleID (non-zero is ignored with this docKind).
    /// @param docPath Initial document path in RomFS, without the leading '/'. For ::WebDocumentKind_OfflineHtmlPage, this is relative to "html-document/" in RomFS. For the other docKind values, this is relative to "/" in RomFS. This path must contain ".htdocs/".
    pub fn webOfflineCreate(
        config: *mut WebCommonConfig,
        docKind: WebDocumentKind,
        titleID: u64,
        docPath: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    /// @brief Creates the config for ShareApplet. This applet is for social media posting/settings.
    /// @note If a non-zero userID isn't set with \ref webConfigSetUserID prior to using \ref webConfigShow, the applet will launch the profile-selector applet to select an account.
    /// @note An error will be displayed if neither \ref webConfigSetAlbumEntry or \ref webConfigSetApplicationAlbumEntry are used prior to using \ref webConfigShow, with ::WebShareStartPage_Default.
    /// @note Uses \ref webConfigSetLeftStickMode with ::WebLeftStickMode_Cursor, \ref webConfigSetUserID with userID=0, \ref webConfigSetDisplayUrlKind with kind=true, and sets ::WebArgType_Unknown14/::WebArgType_Unknown15 to value 1. Uses \ref webConfigSetBootDisplayKind with ::WebBootDisplayKind_Unknown3.
    /// @param config WebCommonConfig object.
    /// @param page \ref WebShareStartPage
    pub fn webShareCreate(config: *mut WebCommonConfig, page: WebShareStartPage) -> Result;
}
extern "C" {
    /// @brief Creates the config for LobbyApplet. This applet is for "Nintendo Switch Online Lounge".
    /// @note Only available on [2.0.0+].
    /// @note If a non-zero userID isn't set with \ref webConfigSetUserID prior to using \ref webConfigShow, the applet will launch the profile-selector applet to select an account.
    /// @note Uses \ref webConfigSetLeftStickMode with ::WebLeftStickMode_Cursor, \ref webConfigSetPointer with flag=false on [3.0.0+], \ref webConfigSetUserID with userID=0, and sets ::WebArgType_Unknown14/::WebArgType_Unknown15 to value 1. Uses \ref webConfigSetBootDisplayKind with ::WebBootDisplayKind_Unknown4, \ref webConfigSetBackgroundKind with ::WebBackgroundKind_Unknown2, and sets ::WebArgType_BootAsMediaPlayerInverted to false.
    /// @param config WebCommonConfig object.
    pub fn webLobbyCreate(config: *mut WebCommonConfig) -> Result;
}
extern "C" {
    /// @brief Sets the CallbackUrl. See also \ref webReplyGetLastUrl.
    /// @note With Offline-applet for LastUrl handling, it compares the domain with "localhost" instead.
    /// @note Only available with config created by \ref webPageCreate or with Share-applet.
    /// @param config WebCommonConfig object.
    /// @param url URL
    pub fn webConfigSetCallbackUrl(
        config: *mut WebCommonConfig,
        url: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    /// @brief Sets the CallbackableUrl.
    /// @note Only available with config created by \ref webPageCreate.
    /// @param config WebCommonConfig object.
    /// @param url URL
    pub fn webConfigSetCallbackableUrl(
        config: *mut WebCommonConfig,
        url: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    /// @brief Sets the whitelist.
    /// @note Only available with config created by \ref webPageCreate.
    /// @note If the whitelist isn't formatted properly, the applet will exit briefly after the applet is launched.
    /// @param config WebCommonConfig object.
    /// @param whitelist Whitelist string, each line is a regex for each whitelisted URL.
    pub fn webConfigSetWhitelist(
        config: *mut WebCommonConfig,
        whitelist: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    /// @brief Sets the account UserID. Controls which user-specific savedata to mount.
    /// @note Only available with config created by \ref webPageCreate, \ref webLobbyCreate, or with Share-applet.
    /// @note Used automatically by \ref webShareCreate and \ref webLobbyCreate with userID=0.
    /// @param config WebCommonConfig object.
    /// @param userID Account userID
    pub fn webConfigSetUserID(config: *mut WebCommonConfig, userID: u128) -> Result;
}
extern "C" {
    /// @brief Sets the Share CapsAlbumEntry.
    /// @note Only available with config created by \ref webShareCreate.
    /// @param config WebCommonConfig object.
    /// @param entry \ref CapsAlbumEntry
    pub fn webConfigSetAlbumEntry(
        config: *mut WebCommonConfig,
        entry: *mut CapsAlbumEntry,
    ) -> Result;
}
extern "C" {
    /// @brief Sets the ScreenShot flag, which controls whether screen-shot capture is allowed.
    /// @note Only available with config created by \ref webPageCreate.
    /// @param config WebCommonConfig object.
    /// @param flag Flag
    pub fn webConfigSetScreenShot(config: *mut WebCommonConfig, flag: bool) -> Result;
}
extern "C" {
    /// @brief Sets the EcClientCert flag.
    /// @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate.
    /// @note Used automatically by \ref webOfflineCreate, depending on the docKind.
    /// @note Used automatically by \ref webNewsCreate with flag=true.
    /// @param config WebCommonConfig object.
    /// @param flag Flag
    pub fn webConfigSetEcClientCert(config: *mut WebCommonConfig, flag: bool) -> Result;
}
extern "C" {
    /// @brief Sets whether PlayReport is enabled.
    /// @note Only available with config created by \ref webOfflineCreate.
    /// @param config WebCommonConfig object.
    /// @param flag Flag
    pub fn webConfigSetPlayReport(config: *mut WebCommonConfig, flag: bool) -> Result;
}
extern "C" {
    /// @brief Sets the BootDisplayKind.
    /// @note Only available with config created by \ref webOfflineCreate, \ref webShareCreate, \ref webPageCreate, or \ref webLobbyCreate..
    /// @note Used automatically by \ref webOfflineCreate, depending on the docKind.
    /// @note Used automatically by \ref webShareCreate with kind=::WebBootDisplayKind_Unknown3.
    /// @note Used automatically by \ref webLobbyCreate with kind=::WebBootDisplayKind_Unknown4.
    /// @param config WebCommonConfig object.
    /// @param kind \ref WebBootDisplayKind
    pub fn webConfigSetBootDisplayKind(
        config: *mut WebCommonConfig,
        kind: WebBootDisplayKind,
    ) -> Result;
}
extern "C" {
    /// @brief Sets the BackgroundKind.
    /// @note Only available with config created by \ref webOfflineCreate, \ref webPageCreate, or \ref webLobbyCreate.
    /// @note Used automatically by \ref webOfflineCreate, depending on the docKind.
    /// @note Used automatically by \ref webLobbyCreate with kind=2.
    /// @param config WebCommonConfig object.
    /// @param kind \ref WebBackgroundKind
    pub fn webConfigSetBackgroundKind(
        config: *mut WebCommonConfig,
        kind: WebBackgroundKind,
    ) -> Result;
}
extern "C" {
    /// @brief Sets the whether the UI footer is enabled.
    /// @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate.
    /// @note Used automatically by \ref webOfflineCreate, depending on the docKind.
    /// @param config WebCommonConfig object.
    /// @param flag Flag
    pub fn webConfigSetFooter(config: *mut WebCommonConfig, flag: bool) -> Result;
}
extern "C" {
    /// @brief Sets the whether the Pointer is enabled. See also \ref WebLeftStickMode.
    /// @note Only available with config created by \ref webOfflineCreate, \ref webPageCreate, or \ref webLobbyCreate.
    /// @note Used automatically by \ref webOfflineCreate.
    /// @note Used automatically by \ref webLobbyCreate with flag=false on [3.0.0+].
    /// @param config WebCommonConfig object.
    /// @param flag Flag
    pub fn webConfigSetPointer(config: *mut WebCommonConfig, flag: bool) -> Result;
}
extern "C" {
    /// @brief Sets the LeftStickMode.
    /// @note Only available with config created by \ref webOfflineCreate, \ref webShareCreate, \ref webPageCreate, or \ref webLobbyCreate.
    /// @note Used automatically by \ref webOfflineCreate, \ref webShareCreate, and \ref webLobbyCreate with ::WebLeftStickMode_Cursor.
    /// @param config WebCommonConfig object.
    /// @param mode Mode, different enums for Web and Offline.
    pub fn webConfigSetLeftStickMode(
        config: *mut WebCommonConfig,
        mode: WebLeftStickMode,
    ) -> Result;
}
extern "C" {
    /// @brief Sets the KeyRepeatFrame.
    /// @note Only available with config created by \ref webOfflineCreate.
    /// @param config WebCommonConfig object.
    /// @param inval0 First input param.
    /// @param inval1 Second input param.
    pub fn webConfigSetKeyRepeatFrame(
        config: *mut WebCommonConfig,
        inval0: s32,
        inval1: s32,
    ) -> Result;
}
extern "C" {
    /// @brief Sets the DisplayUrlKind.
    /// @note Only available with config created by \ref webShareCreate or \ref webPageCreate.
    /// @param config WebCommonConfig object.
    /// @note Used automatically by \ref webShareCreate with kind=true.
    /// @param kind Kind
    pub fn webConfigSetDisplayUrlKind(config: *mut WebCommonConfig, kind: bool) -> Result;
}
extern "C" {
    /// @brief Sets the BootAsMediaPlayer flag.
    /// @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate, on [2.0.0+].
    /// @note With config created by \ref webNewsCreate on [3.0.0+], this also sets ::WebArgType_BootAsMediaPlayerInverted to !flag.
    /// @param config WebCommonConfig object.
    /// @param flag Flag. true = BootAsMediaPlayer, false = BootAsWebPage.
    pub fn webConfigSetBootAsMediaPlayer(config: *mut WebCommonConfig, flag: bool) -> Result;
}
extern "C" {
    /// @brief Sets the ShopJump flag.
    /// @note Only available with config created by \ref webPageCreate on [2.0.0+].
    /// @note Used automatically by \ref webNewsCreate with flag=true.
    /// @param config WebCommonConfig object.
    /// @param flag Flag
    pub fn webConfigSetShopJump(config: *mut WebCommonConfig, flag: bool) -> Result;
}
extern "C" {
    /// @brief Sets the MediaPlayerUserGestureRestriction flag.
    /// @note Only available with config created by \ref webPageCreate on [2.0.0+].
    /// @param config WebCommonConfig object.
    /// @param flag Flag
    pub fn webConfigSetMediaPlayerUserGestureRestriction(
        config: *mut WebCommonConfig,
        flag: bool,
    ) -> Result;
}
extern "C" {
    /// @brief Sets the LobbyParameter.
    /// @note Only available with config created by \ref webLobbyCreate.
    /// @param config WebCommonConfig object.
    /// @param str String
    pub fn webConfigSetLobbyParameter(
        config: *mut WebCommonConfig,
        str: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    /// @brief Sets the Share CapsApplicationAlbumEntry.
    /// @note Only available with config created by \ref webShareCreate on [3.0.0+].
    /// @param config WebCommonConfig object.
    /// @param entry \ref CapsApplicationAlbumEntry, see also capssu.h.
    pub fn webConfigSetApplicationAlbumEntry(
        config: *mut WebCommonConfig,
        entry: *mut CapsApplicationAlbumEntry,
    ) -> Result;
}
extern "C" {
    /// @brief Sets whether JsExtension is enabled.
    /// @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate, on [3.0.0+].
    /// @param config WebCommonConfig object.
    /// @param flag Flag
    pub fn webConfigSetJsExtension(config: *mut WebCommonConfig, flag: bool) -> Result;
}
extern "C" {
    /// @brief Sets the Share AdditionalCommentText.
    /// @note Only available with config created by \ref webShareCreate on [4.0.0+].
    /// @param config WebCommonConfig object.
    /// @param str String
    pub fn webConfigSetAdditionalCommentText(
        config: *mut WebCommonConfig,
        str: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    /// @brief Sets the TouchEnabledOnContents flag.
    /// @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate, on [4.0.0+].
    /// @param config WebCommonConfig object.
    /// @param flag Flag
    pub fn webConfigSetTouchEnabledOnContents(config: *mut WebCommonConfig, flag: bool) -> Result;
}
extern "C" {
    /// @brief Sets the UserAgentAdditionalString. " " followed by this string are appended to the normal User-Agent string.
    /// @note Only available with config created by \ref webPageCreate on [4.0.0+].
    /// @param config WebCommonConfig object.
    /// @param str String
    pub fn webConfigSetUserAgentAdditionalString(
        config: *mut WebCommonConfig,
        str: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    /// @brief Sets the Share AdditionalMediaData.
    /// @note Only available with config created by \ref webShareCreate on [4.0.0+].
    /// @param config WebCommonConfig object.
    /// @param data Input data
    /// @param size Size of the input data, max size is 0x10.
    pub fn webConfigSetAdditionalMediaData(
        config: *mut WebCommonConfig,
        data: *const u8,
        size: usize,
    ) -> Result;
}
extern "C" {
    /// @brief Sets the MediaPlayerAutoClose flag.
    /// @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate, on [4.0.0+].
    /// @param config WebCommonConfig object.
    /// @param flag Flag
    pub fn webConfigSetMediaPlayerAutoClose(config: *mut WebCommonConfig, flag: bool) -> Result;
}
extern "C" {
    /// @brief Sets whether PageCache is enabled.
    /// @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate, on [4.0.0+].
    /// @param config WebCommonConfig object.
    /// @param flag Flag
    pub fn webConfigSetPageCache(config: *mut WebCommonConfig, flag: bool) -> Result;
}
extern "C" {
    /// @brief Sets whether WebAudio is enabled.
    /// @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate, on [4.0.0+].
    /// @param config WebCommonConfig object.
    /// @param flag Flag
    pub fn webConfigSetWebAudio(config: *mut WebCommonConfig, flag: bool) -> Result;
}
extern "C" {
    /// @brief Sets the FooterFixedKind.
    /// @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate, on [5.0.0+].
    /// @param config WebCommonConfig object.
    /// @param kind \ref WebFooterFixedKind
    pub fn webConfigSetFooterFixedKind(
        config: *mut WebCommonConfig,
        kind: WebFooterFixedKind,
    ) -> Result;
}
extern "C" {
    /// @brief Sets the PageFade flag.
    /// @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate, on [5.0.0+].
    /// @param config WebCommonConfig object.
    /// @param flag Flag
    pub fn webConfigSetPageFade(config: *mut WebCommonConfig, flag: bool) -> Result;
}
extern "C" {
    /// @brief Sets the Share MediaCreatorApplicationRatingAge.
    /// @note Only available with config created by \ref webShareCreate on [5.0.0+].
    /// @param config WebCommonConfig object.
    /// @param data 0x20-byte input data
    pub fn webConfigSetMediaCreatorApplicationRatingAge(
        config: *mut WebCommonConfig,
        data: *const s8,
    ) -> Result;
}
extern "C" {
    /// @brief Sets the BootLoadingIcon flag.
    /// @note Only available with config created by \ref webOfflineCreate on [5.0.0+].
    /// @param config WebCommonConfig object.
    /// @param flag Flag
    pub fn webConfigSetBootLoadingIcon(config: *mut WebCommonConfig, flag: bool) -> Result;
}
extern "C" {
    /// @brief Sets the PageScrollIndicator flag.
    /// @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate, on [5.0.0+].
    /// @param config WebCommonConfig object.
    /// @param flag Flag
    pub fn webConfigSetPageScrollIndicator(config: *mut WebCommonConfig, flag: bool) -> Result;
}
extern "C" {
    /// @brief Launches the {web applet} with the specified config and waits for it to exit.
    /// @param config WebCommonConfig object.
    /// @param out Optional output applet reply data, can be NULL.
    pub fn webConfigShow(config: *mut WebCommonConfig, out: *mut WebCommonReply) -> Result;
}
extern "C" {
    /// @brief Request the applet to exit after \ref webConfigShow was used, while the applet is still running. This is for use from another thread.
    /// @param config WebCommonConfig object.
    pub fn webConfigRequestExit(config: *mut WebCommonConfig) -> Result;
}
extern "C" {
    /// @brief Gets the ExitReason from the specified reply.
    /// @param reply WebCommonReply object.
    /// @param exitReason Output \ref WebExitReason
    pub fn webReplyGetExitReason(
        reply: *mut WebCommonReply,
        exitReason: *mut WebExitReason,
    ) -> Result;
}
extern "C" {
    /// @brief Gets the LastUrl from the specified reply. When the applet loads a page where the beginning of the URL matches the URL from \ref webConfigSetCallbackUrl, the applet will exit and set LastUrl to that URL (exit doesn't occur when \ref webConfigSetCallbackableUrl was used).
    /// @note This is only available with ::WebExitReason_LastUrl (string is empty otherwise).
    /// @note If you want to allocate a string buffer on heap, you can call this with outstr=NULL/outstr_maxsize=0 to get the out_size, then call it again with the allocated buffer.
    /// @param reply WebCommonReply object.
    /// @param outstr Output string buffer. If NULL, the string is not loaded.
    /// @param outstr_maxsize Size of the buffer, including NUL-terminator. If outstr is set, this size must be >1. The size used for the actual string-copy is this size-1, to make sure the output is NUL-terminated (the entire buffer is cleared first).
    /// @param out_size Output string length including NUL-terminator, for the original input string in the reply loaded from a separate size field.
    pub fn webReplyGetLastUrl(
        reply: *mut WebCommonReply,
        outstr: *mut ctypes::c_char,
        outstr_maxsize: usize,
        out_size: *mut usize,
    ) -> Result;
}
extern "C" {
    /// @brief Gets the SharePostResult from the specified reply.
    /// @note Only available with reply data from ShareApplet on [3.0.0+].
    /// @param reply WebCommonReply object.
    /// @param sharePostResult Output sharePostResult
    pub fn webReplyGetSharePostResult(
        reply: *mut WebCommonReply,
        sharePostResult: *mut u32,
    ) -> Result;
}
extern "C" {
    /// @brief Gets the PostServiceName from the specified reply.
    /// @note Only available with reply data from ShareApplet on [3.0.0+].
    /// @note If you want to allocate a string buffer on heap, you can call this with outstr=NULL/outstr_maxsize=0 to get the out_size, then call it again with the allocated buffer.
    /// @param reply WebCommonReply object.
    /// @param outstr Output string buffer. If NULL, the string is not loaded.
    /// @param outstr_maxsize Size of the buffer, including NUL-terminator. If outstr is set, this size must be >1. The size used for the actual string-copy is this size-1, to make sure the output is NUL-terminated (the entire buffer is cleared first).
    /// @param out_size Output string length including NUL-terminator, for the original input string in the reply loaded from a separate size field.
    pub fn webReplyGetPostServiceName(
        reply: *mut WebCommonReply,
        outstr: *mut ctypes::c_char,
        outstr_maxsize: usize,
        out_size: *mut usize,
    ) -> Result;
}
extern "C" {
    /// @brief Gets the PostId from the specified reply.
    /// @note Only available with reply data from ShareApplet on [3.0.0+].
    /// @note If you want to allocate a string buffer on heap, you can call this with outstr=NULL/outstr_maxsize=0 to get the out_size, then call it again with the allocated buffer.
    /// @param reply WebCommonReply object.
    /// @param outstr Output string buffer. If NULL, the string is not loaded.
    /// @param outstr_maxsize Size of the buffer, including NUL-terminator. If outstr is set, this size must be >1. The size used for the actual string-copy is this size-1, to make sure the output is NUL-terminated (the entire buffer is cleared first).
    /// @param out_size Output string length including NUL-terminator, for the original input string in the reply loaded from a separate size field.
    pub fn webReplyGetPostId(
        reply: *mut WebCommonReply,
        outstr: *mut ctypes::c_char,
        outstr_maxsize: usize,
        out_size: *mut usize,
    ) -> Result;
}
/// Structure representing an entry in the homebrew environment configuration.
#[repr(C)]
pub struct ConfigEntry {
    /// < Type of entry
    pub Key: u32,
    /// < Entry flags
    pub Flags: u32,
    /// < Entry arguments (type-specific)
    pub Value: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_ConfigEntry() {
    assert_eq!(
        ::core::mem::size_of::<ConfigEntry>(),
        24usize,
        concat!("Size of: ", stringify!(ConfigEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<ConfigEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(ConfigEntry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConfigEntry>())).Key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ConfigEntry),
            "::",
            stringify!(Key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConfigEntry>())).Flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ConfigEntry),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConfigEntry>())).Value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ConfigEntry),
            "::",
            stringify!(Value)
        )
    );
}
/// < Specifies that the entry **must** be processed by the homebrew application.
pub const EntryFlag_IsMandatory: _bindgen_ty_13 = 1;
/// Entry flags
pub type _bindgen_ty_13 = u32;
/// < Entry list terminator.
pub const EntryType_EndOfList: _bindgen_ty_14 = 0;
/// < Provides the handle to the main thread.
pub const EntryType_MainThreadHandle: _bindgen_ty_14 = 1;
/// < Provides a buffer containing information about the next homebrew application to load.
pub const EntryType_NextLoadPath: _bindgen_ty_14 = 2;
/// < Provides heap override information.
pub const EntryType_OverrideHeap: _bindgen_ty_14 = 3;
/// < Provides service override information.
pub const EntryType_OverrideService: _bindgen_ty_14 = 4;
/// < Provides argv.
pub const EntryType_Argv: _bindgen_ty_14 = 5;
/// < Provides syscall availability hints.
pub const EntryType_SyscallAvailableHint: _bindgen_ty_14 = 6;
/// < Provides APT applet type.
pub const EntryType_AppletType: _bindgen_ty_14 = 7;
/// < Indicates that APT is broken and should not be used.
pub const EntryType_AppletWorkaround: _bindgen_ty_14 = 8;
/// < Unused/reserved entry type, formerly used by StdioSockets.
pub const EntryType_Reserved9: _bindgen_ty_14 = 9;
/// < Provides the process handle.
pub const EntryType_ProcessHandle: _bindgen_ty_14 = 10;
/// < Provides the last load result.
pub const EntryType_LastLoadResult: _bindgen_ty_14 = 11;
/// < Provides random data used to seed the pseudo-random number generator.
pub const EntryType_RandomSeed: _bindgen_ty_14 = 14;
pub type _bindgen_ty_14 = u32;
/// < Use AppletType_Application instead of AppletType_SystemApplication.
pub const EnvAppletFlags_ApplicationOverride: _bindgen_ty_15 = 1;
pub type _bindgen_ty_15 = u32;
/// Loader return function.
pub type LoaderReturnFn = ::core::option::Option<unsafe extern "C" fn(result_code: ctypes::c_int)>;
extern "C" {
    /// @brief Parses the homebrew loader environment block (internally called).
    /// @param ctx Reserved.
    /// @param main_thread Reserved.
    /// @param saved_lr Reserved.
    pub fn envSetup(ctx: *mut ctypes::c_void, main_thread: Handle, saved_lr: LoaderReturnFn);
}
extern "C" {
    /// Retrieves the handle to the main thread.
    pub fn envGetMainThreadHandle() -> Handle;
}
extern "C" {
    /// Returns true if the application is running as NSO, otherwise NRO.
    pub fn envIsNso() -> bool;
}
extern "C" {
    /// Returns true if the environment has a heap override.
    pub fn envHasHeapOverride() -> bool;
}
extern "C" {
    /// Returns the address of the overriden heap.
    pub fn envGetHeapOverrideAddr() -> *mut ctypes::c_void;
}
extern "C" {
    /// Returns the size of the overriden heap.
    pub fn envGetHeapOverrideSize() -> u64;
}
extern "C" {
    /// Returns true if the environment has an argv array.
    pub fn envHasArgv() -> bool;
}
extern "C" {
    /// Returns the pointer to the argv array.
    pub fn envGetArgv() -> *mut ctypes::c_void;
}
extern "C" {
    /// @brief Returns whether a syscall is hinted to be available.
    /// @param svc Syscall number to test.
    /// @returns true if the syscall is available.
    pub fn envIsSyscallHinted(svc: u8) -> bool;
}
extern "C" {
    /// Returns the handle to the running homebrew process.
    pub fn envGetOwnProcessHandle() -> Handle;
}
extern "C" {
    /// Returns the loader's return function, to be called on program exit.
    pub fn envGetExitFuncPtr() -> LoaderReturnFn;
}
extern "C" {
    /// Sets the return function to be called on program exit.
    pub fn envSetExitFuncPtr(addr: LoaderReturnFn);
}
extern "C" {
    /// @brief Configures the next homebrew application to load.
    /// @param path Path to the next homebrew application to load (.nro).
    /// @param argv Argument string to pass.
    pub fn envSetNextLoad(path: *const ctypes::c_char, argv: *const ctypes::c_char) -> Result;
}
extern "C" {
    /// Returns true if the environment supports envSetNextLoad.
    pub fn envHasNextLoad() -> bool;
}
extern "C" {
    /// Returns the Result from the last NRO.
    pub fn envGetLastLoadResult() -> Result;
}
extern "C" {
    /// Returns true if the environment provides a random seed.
    pub fn envHasRandomSeed() -> bool;
}
extern "C" {
    /// @brief Retrieves the random seed provided by the environment.
    /// @param out Pointer to a u64[2] buffer which will contain the random seed on return.
    pub fn envGetRandomSeed(out: *mut u64);
}
extern "C" {
    /// Returns the current HOS version that was previously set with \ref hosversionSet. If version initialization fails during startup (such as in the case set:sys is not available), this function returns zero.
    pub fn hosversionGet() -> u32;
}
extern "C" {
    /// Sets or overrides the current HOS version. This function is normally called automatically by libnx on startup with the version info obtained with \ref setsysGetFirmwareVersion.
    pub fn hosversionSet(version: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut __nxlink_host: in_addr;
}
extern "C" {
    pub fn nxlinkStdio() -> ctypes::c_int;
}
pub type _ssize_t = ctypes::c_long;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ctypes::c_int;
pub type __blkcnt_t = ctypes::c_long;
pub type __blksize_t = ctypes::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = ctypes::c_long;
pub type __pid_t = ctypes::c_int;
pub type __dev_t = ctypes::c_short;
pub type __uid_t = ctypes::c_ushort;
pub type __gid_t = ctypes::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = ctypes::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = ctypes::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = ctypes::c_long;
pub type _fpos_t = ctypes::c_long;
pub type __size_t = ctypes::c_ulonglong;
pub type __ssize_t = _ssize_t;
pub type wint_t = ctypes::c_ushort;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ctypes::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [ctypes::c_uchar; 4usize],
    _bindgen_union_align: [u16; 2usize],
}
#[test]
fn bindgen_test_layout__mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout__mbstate_t() {
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(_mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type _flock_t = _LOCK_RECURSIVE_T;
pub type _iconv_t = *mut ctypes::c_void;
pub type __clock_t = ctypes::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = ctypes::c_ulong;
pub type __timer_t = ctypes::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = ctypes::c_int;
pub type __nlink_t = ctypes::c_ushort;
pub type __suseconds_t = ctypes::c_long;
pub type __useconds_t = ctypes::c_ulong;
pub type __va_list = __builtin_va_list;
pub type __sigset_t = ctypes::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = __int_least64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::core::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::core::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ctypes::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
extern "C" {
    pub fn timespec2nsec(ts: *const timespec) -> __uint64_t;
}
extern "C" {
    pub fn abstimespec2nsec(clock_id: __clockid_t, ts: *const timespec) -> __uint64_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::core::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::core::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
pub type sigset_t = __sigset_t;
pub type fd_mask = ctypes::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _types_fd_set {
    pub fds_bits: [fd_mask; 2usize],
}
#[test]
fn bindgen_test_layout__types_fd_set() {
    assert_eq!(
        ::core::mem::size_of::<_types_fd_set>(),
        8usize,
        concat!("Size of: ", stringify!(_types_fd_set))
    );
    assert_eq!(
        ::core::mem::align_of::<_types_fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(_types_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_types_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_types_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn select(
        __n: ctypes::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *mut timeval,
    ) -> ctypes::c_int;
}
extern "C" {
    pub fn pselect(
        __n: ctypes::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> ctypes::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_char = ctypes::c_uchar;
pub type u_short = ctypes::c_ushort;
pub type u_int = ctypes::c_uint;
pub type u_long = ctypes::c_ulong;
pub type ushort = ctypes::c_ushort;
pub type uint = ctypes::c_uint;
pub type ulong = ctypes::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = ctypes::c_ulong;
pub type daddr_t = ctypes::c_long;
pub type caddr_t = *mut ctypes::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ctypes::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::core::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_t {
    _unused: [u8; 0],
}
pub type pthread_t = *mut __pthread_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub stackaddr: *mut ctypes::c_void,
    pub stacksize: ctypes::c_int,
    pub schedparam: sched_param,
    pub detachstate: ctypes::c_int,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_attr_t>(),
        24usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).stackaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stackaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).stacksize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stacksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).schedparam as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(schedparam)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).detachstate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(detachstate)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_mutex_t {
    pub type_: ctypes::c_int,
    pub __bindgen_anon_1: pthread_mutex_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t__bindgen_ty_1 {
    pub normal: _LOCK_T,
    pub recursive: _LOCK_RECURSIVE_T,
    _bindgen_union_align: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<pthread_mutex_t__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(pthread_mutex_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutex_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_mutex_t__bindgen_ty_1>())).normal as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t__bindgen_ty_1),
            "::",
            stringify!(normal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_mutex_t__bindgen_ty_1>())).recursive as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t__bindgen_ty_1),
            "::",
            stringify!(recursive)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_mutex_t>(),
        16usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutex_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutexattr_t {}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_mutexattr_t>(),
        0usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutexattr_t>(),
        1usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_t {
    pub clock_id: clockid_t,
    pub cond: _COND_T,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_cond_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_cond_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_cond_t>())).clock_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(clock_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_cond_t>())).cond as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(cond)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_condattr_t {
    pub clock_id: clockid_t,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_condattr_t>())).clock_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(clock_id)
        )
    );
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_once_t {
    pub status: ctypes::c_int,
}
#[test]
fn bindgen_test_layout_pthread_once_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_once_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_once_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_once_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_once_t>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once_t),
            "::",
            stringify!(status)
        )
    );
}
extern "C" {
    /// Convert a UTF-8 sequence into a UTF-32 codepoint
    ///
    /// @param[out] out Output codepoint
    /// @param[in]  in  Input sequence
    ///
    /// @returns number of input code units consumed
    /// @returns -1 for error
    pub fn decode_utf8(out: *mut u32, in_: *const u8) -> isize;
}
extern "C" {
    /// Convert a UTF-16 sequence into a UTF-32 codepoint
    ///
    /// @param[out] out Output codepoint
    /// @param[in]  in  Input sequence
    ///
    /// @returns number of input code units consumed
    /// @returns -1 for error
    pub fn decode_utf16(out: *mut u32, in_: *const u16) -> isize;
}
extern "C" {
    /// Convert a UTF-32 codepoint into a UTF-8 sequence
    ///
    /// @param[out] out Output sequence
    /// @param[in]  in  Input codepoint
    ///
    /// @returns number of output code units produced
    /// @returns -1 for error
    ///
    /// @note \a out must be able to store 4 code units
    pub fn encode_utf8(out: *mut u8, in_: u32) -> isize;
}
extern "C" {
    /// Convert a UTF-32 codepoint into a UTF-16 sequence
    ///
    /// @param[out] out Output sequence
    /// @param[in]  in  Input codepoint
    ///
    /// @returns number of output code units produced
    /// @returns -1 for error
    ///
    /// @note \a out must be able to store 2 code units
    pub fn encode_utf16(out: *mut u16, in_: u32) -> isize;
}
extern "C" {
    /// Convert a UTF-8 sequence into a UTF-16 sequence
    ///
    /// Fills the output buffer up to \a len code units.
    /// Returns the number of code units that the input would produce;
    /// if it returns greater than \a len, the output has been
    /// truncated.
    ///
    /// @param[out] out Output sequence
    /// @param[in]  in  Input sequence (null-terminated)
    /// @param[in]  len Output length
    ///
    /// @returns number of output code units produced
    /// @returns -1 for error
    ///
    /// @note \a out is not null-terminated
    pub fn utf8_to_utf16(out: *mut u16, in_: *const u8, len: usize) -> isize;
}
extern "C" {
    /// Convert a UTF-8 sequence into a UTF-32 sequence
    ///
    /// Fills the output buffer up to \a len code units.
    /// Returns the number of code units that the input would produce;
    /// if it returns greater than \a len, the output has been
    /// truncated.
    ///
    /// @param[out] out Output sequence
    /// @param[in]  in  Input sequence (null-terminated)
    /// @param[in]  len Output length
    ///
    /// @returns number of output code units produced
    /// @returns -1 for error
    ///
    /// @note \a out is not null-terminated
    pub fn utf8_to_utf32(out: *mut u32, in_: *const u8, len: usize) -> isize;
}
extern "C" {
    /// Convert a UTF-16 sequence into a UTF-8 sequence
    ///
    /// Fills the output buffer up to \a len code units.
    /// Returns the number of code units that the input would produce;
    /// if it returns greater than \a len, the output has been
    /// truncated.
    ///
    /// @param[out] out Output sequence
    /// @param[in]  in  Input sequence (null-terminated)
    /// @param[in]  len Output length
    ///
    /// @returns number of output code units produced
    /// @returns -1 for error
    ///
    /// @note \a out is not null-terminated
    pub fn utf16_to_utf8(out: *mut u8, in_: *const u16, len: usize) -> isize;
}
extern "C" {
    /// Convert a UTF-16 sequence into a UTF-32 sequence
    ///
    /// Fills the output buffer up to \a len code units.
    /// Returns the number of code units that the input would produce;
    /// if it returns greater than \a len, the output has been
    /// truncated.
    ///
    /// @param[out] out Output sequence
    /// @param[in]  in  Input sequence (null-terminated)
    /// @param[in]  len Output length
    ///
    /// @returns number of output code units produced
    /// @returns -1 for error
    ///
    /// @note \a out is not null-terminated
    pub fn utf16_to_utf32(out: *mut u32, in_: *const u16, len: usize) -> isize;
}
extern "C" {
    /// Convert a UTF-32 sequence into a UTF-8 sequence
    ///
    /// Fills the output buffer up to \a len code units.
    /// Returns the number of code units that the input would produce;
    /// if it returns greater than \a len, the output has been
    /// truncated.
    ///
    /// @param[out] out Output sequence
    /// @param[in]  in  Input sequence (null-terminated)
    /// @param[in]  len Output length
    ///
    /// @returns number of output code units produced
    /// @returns -1 for error
    ///
    /// @note \a out is not null-terminated
    pub fn utf32_to_utf8(out: *mut u8, in_: *const u32, len: usize) -> isize;
}
extern "C" {
    /// Convert a UTF-32 sequence into a UTF-16 sequence
    ///
    /// @param[out] out Output sequence
    /// @param[in]  in  Input sequence (null-terminated)
    /// @param[in]  len Output length
    ///
    /// @returns number of output code units produced
    /// @returns -1 for error
    ///
    /// @note \a out is not null-terminated
    pub fn utf32_to_utf16(out: *mut u16, in_: *const u32, len: usize) -> isize;
}
/// Renderer interface for the console.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConsoleRenderer {
    pub init: ::core::option::Option<unsafe extern "C" fn(con: *mut PrintConsole) -> bool>,
    pub deinit: ::core::option::Option<unsafe extern "C" fn(con: *mut PrintConsole)>,
    pub drawChar: ::core::option::Option<
        unsafe extern "C" fn(
            con: *mut PrintConsole,
            x: ctypes::c_int,
            y: ctypes::c_int,
            c: ctypes::c_int,
        ),
    >,
    pub scrollWindow: ::core::option::Option<unsafe extern "C" fn(con: *mut PrintConsole)>,
    pub flushAndSwap: ::core::option::Option<unsafe extern "C" fn(con: *mut PrintConsole)>,
}
#[test]
fn bindgen_test_layout_ConsoleRenderer() {
    assert_eq!(
        ::core::mem::size_of::<ConsoleRenderer>(),
        40usize,
        concat!("Size of: ", stringify!(ConsoleRenderer))
    );
    assert_eq!(
        ::core::mem::align_of::<ConsoleRenderer>(),
        8usize,
        concat!("Alignment of ", stringify!(ConsoleRenderer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleRenderer>())).init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleRenderer),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleRenderer>())).deinit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleRenderer),
            "::",
            stringify!(deinit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleRenderer>())).drawChar as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleRenderer),
            "::",
            stringify!(drawChar)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleRenderer>())).scrollWindow as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleRenderer),
            "::",
            stringify!(scrollWindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleRenderer>())).flushAndSwap as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleRenderer),
            "::",
            stringify!(flushAndSwap)
        )
    );
}
/// A font struct for the console.
#[repr(C)]
pub struct ConsoleFont {
    /// < A pointer to the font graphics
    pub gfx: *const ctypes::c_void,
    /// < Offset to the first valid character in the font table
    pub asciiOffset: u16,
    /// < Number of characters in the font graphics
    pub numChars: u16,
    pub tileWidth: u16,
    pub tileHeight: u16,
}
#[test]
fn bindgen_test_layout_ConsoleFont() {
    assert_eq!(
        ::core::mem::size_of::<ConsoleFont>(),
        16usize,
        concat!("Size of: ", stringify!(ConsoleFont))
    );
    assert_eq!(
        ::core::mem::align_of::<ConsoleFont>(),
        8usize,
        concat!("Alignment of ", stringify!(ConsoleFont))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleFont>())).gfx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleFont),
            "::",
            stringify!(gfx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleFont>())).asciiOffset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleFont),
            "::",
            stringify!(asciiOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleFont>())).numChars as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleFont),
            "::",
            stringify!(numChars)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleFont>())).tileWidth as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleFont),
            "::",
            stringify!(tileWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleFont>())).tileHeight as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleFont),
            "::",
            stringify!(tileHeight)
        )
    );
}
/// @brief Console structure used to store the state of a console render context.
///
/// Default values from consoleGetDefault();
/// @code
/// PrintConsole defaultConsole =
/// {
/// //Font:
/// {
/// default_font_bin, //font gfx
/// 0, //first ascii character in the set
/// 256, //number of characters in the font set
/// 16, //tile width
/// 16, //tile height
/// },
/// NULL, //renderer
/// 0,0, //cursorX cursorY
/// 0,0, //prevcursorX prevcursorY
/// 80, //console width
/// 45, //console height
/// 0,  //window x
/// 0,  //window y
/// 80, //window width
/// 45, //window height
/// 3, //tab size
/// 7, // foreground color
/// 0, // background color
/// 0, // flags
/// false //console initialized
/// };
/// @endcode
#[repr(C)]
pub struct PrintConsole {
    /// < Font of the console
    pub font: ConsoleFont,
    /// < Renderer of the console
    pub renderer: *mut ConsoleRenderer,
    /// < Current X location of the cursor (as a tile offset by default)
    pub cursorX: ctypes::c_int,
    /// < Current Y location of the cursor (as a tile offset by default)
    pub cursorY: ctypes::c_int,
    /// < Internal state
    pub prevCursorX: ctypes::c_int,
    /// < Internal state
    pub prevCursorY: ctypes::c_int,
    /// < Width of the console hardware layer in characters
    pub consoleWidth: ctypes::c_int,
    /// < Height of the console hardware layer in characters
    pub consoleHeight: ctypes::c_int,
    /// < Window X location in characters
    pub windowX: ctypes::c_int,
    /// < Window Y location in characters
    pub windowY: ctypes::c_int,
    /// < Window width in characters
    pub windowWidth: ctypes::c_int,
    /// < Window height in characters
    pub windowHeight: ctypes::c_int,
    /// < Size of a tab
    pub tabSize: ctypes::c_int,
    /// < Foreground color
    pub fg: ctypes::c_int,
    /// < Background color
    pub bg: ctypes::c_int,
    /// < Reverse/bright flags
    pub flags: ctypes::c_int,
    /// < True if the console is initialized
    pub consoleInitialised: bool,
}
#[test]
fn bindgen_test_layout_PrintConsole() {
    assert_eq!(
        ::core::mem::size_of::<PrintConsole>(),
        88usize,
        concat!("Size of: ", stringify!(PrintConsole))
    );
    assert_eq!(
        ::core::mem::align_of::<PrintConsole>(),
        8usize,
        concat!("Alignment of ", stringify!(PrintConsole))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).font as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(font)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).renderer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(renderer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).cursorX as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(cursorX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).cursorY as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(cursorY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).prevCursorX as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(prevCursorX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).prevCursorY as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(prevCursorY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).consoleWidth as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(consoleWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).consoleHeight as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(consoleHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).windowX as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(windowX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).windowY as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(windowY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).windowWidth as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(windowWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).windowHeight as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(windowHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).tabSize as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(tabSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).fg as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(fg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).bg as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(bg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).flags as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PrintConsole>())).consoleInitialised as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(consoleInitialised)
        )
    );
}
/// < Swallows prints to stderr
pub const debugDevice_debugDevice_NULL: debugDevice = 0;
/// < Outputs stderr debug statements using svcOutputDebugString, which can then be captured by interactive debuggers
pub const debugDevice_debugDevice_SVC: debugDevice = 1;
/// < Directs stderr debug statements to Switch console window
pub const debugDevice_debugDevice_CONSOLE: debugDevice = 2;
pub const debugDevice_debugDevice_3DMOO: debugDevice = 1;
/// Console debug devices supported by libnx.
pub type debugDevice = u32;
extern "C" {
    /// @brief Loads the font into the console.
    /// @param console Pointer to the console to update, if NULL it will update the current console.
    /// @param font The font to load.
    pub fn consoleSetFont(console: *mut PrintConsole, font: *mut ConsoleFont);
}
extern "C" {
    /// @brief Sets the print window.
    /// @param console Console to set, if NULL it will set the current console window.
    /// @param x X location of the window.
    /// @param y Y location of the window.
    /// @param width Width of the window.
    /// @param height Height of the window.
    pub fn consoleSetWindow(
        console: *mut PrintConsole,
        x: ctypes::c_int,
        y: ctypes::c_int,
        width: ctypes::c_int,
        height: ctypes::c_int,
    );
}
extern "C" {
    /// @brief Gets a pointer to the console with the default values.
    /// This should only be used when using a single console or without changing the console that is returned, otherwise use consoleInit().
    /// @return A pointer to the console with the default values.
    pub fn consoleGetDefault() -> *mut PrintConsole;
}
extern "C" {
    /// @brief Make the specified console the render target.
    /// @param console A pointer to the console struct (must have been initialized with consoleInit(PrintConsole* console)).
    /// @return A pointer to the previous console.
    pub fn consoleSelect(console: *mut PrintConsole) -> *mut PrintConsole;
}
extern "C" {
    /// @brief Initialise the console.
    /// @param console A pointer to the console data to initialize (if it's NULL, the default console will be used).
    /// @return A pointer to the current console.
    pub fn consoleInit(console: *mut PrintConsole) -> *mut PrintConsole;
}
extern "C" {
    /// @brief Deinitialise the console.
    /// @param console A pointer to the console data to initialize (if it's NULL, the default console will be used).
    pub fn consoleExit(console: *mut PrintConsole);
}
extern "C" {
    /// @brief Updates the console, submitting a new frame to the display.
    /// @param console A pointer to the console data to initialize (if it's NULL, the default console will be used).
    /// @remark This function should be called periodically. Failure to call this function will result in lack of screen updating.
    pub fn consoleUpdate(console: *mut PrintConsole);
}
extern "C" {
    /// @brief Initializes debug console output on stderr to the specified device.
    /// @param device The debug device (or devices) to output debug print statements to.
    pub fn consoleDebugInit(device: debugDevice);
}
extern "C" {
    /// Clears the screan by using printf("\x1b[2J");
    pub fn consoleClear();
}
#[repr(C)]
pub struct UsbCommsInterfaceInfo {
    pub bInterfaceClass: u8,
    pub bInterfaceSubClass: u8,
    pub bInterfaceProtocol: u8,
}
#[test]
fn bindgen_test_layout_UsbCommsInterfaceInfo() {
    assert_eq!(
        ::core::mem::size_of::<UsbCommsInterfaceInfo>(),
        3usize,
        concat!("Size of: ", stringify!(UsbCommsInterfaceInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbCommsInterfaceInfo>(),
        1usize,
        concat!("Alignment of ", stringify!(UsbCommsInterfaceInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbCommsInterfaceInfo>())).bInterfaceClass as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbCommsInterfaceInfo),
            "::",
            stringify!(bInterfaceClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbCommsInterfaceInfo>())).bInterfaceSubClass as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbCommsInterfaceInfo),
            "::",
            stringify!(bInterfaceSubClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbCommsInterfaceInfo>())).bInterfaceProtocol as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbCommsInterfaceInfo),
            "::",
            stringify!(bInterfaceProtocol)
        )
    );
}
extern "C" {
    /// Initializes usbComms with the default number of interfaces (1)
    pub fn usbCommsInitialize() -> Result;
}
extern "C" {
    /// Initializes usbComms with a specific number of interfaces.
    pub fn usbCommsInitializeEx(num_interfaces: u32, infos: *const UsbCommsInterfaceInfo)
        -> Result;
}
extern "C" {
    /// Exits usbComms.
    pub fn usbCommsExit();
}
extern "C" {
    /// Sets whether to throw a fatal error in usbComms{Read/Write}* on failure, or just return the transferred size. By default (false) the latter is used.
    pub fn usbCommsSetErrorHandling(flag: bool);
}
extern "C" {
    /// Read data with the default interface.
    pub fn usbCommsRead(buffer: *mut ctypes::c_void, size: usize) -> usize;
}
extern "C" {
    /// Write data with the default interface.
    pub fn usbCommsWrite(buffer: *const ctypes::c_void, size: usize) -> usize;
}
extern "C" {
    /// Same as usbCommsRead except with the specified interface.
    pub fn usbCommsReadEx(buffer: *mut ctypes::c_void, size: usize, interface: u32) -> usize;
}
extern "C" {
    /// Same as usbCommsWrite except with the specified interface.
    pub fn usbCommsWriteEx(buffer: *const ctypes::c_void, size: usize, interface: u32) -> usize;
}
/// Open directory struct
#[repr(C)]
pub struct fsdev_dir_t {
    /// < "fsdv"
    pub magic: u32,
    /// < File descriptor
    pub fd: FsDir,
    /// < Current entry index
    pub index: isize,
    /// < Current batch size
    pub size: usize,
    /// < Temporary storage for reading entries
    pub entry_data: [FsDirectoryEntry; 32usize],
}
#[test]
fn bindgen_test_layout_fsdev_dir_t() {
    assert_eq!(
        ::core::mem::size_of::<fsdev_dir_t>(),
        25120usize,
        concat!("Size of: ", stringify!(fsdev_dir_t))
    );
    assert_eq!(
        ::core::mem::align_of::<fsdev_dir_t>(),
        8usize,
        concat!("Alignment of ", stringify!(fsdev_dir_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fsdev_dir_t>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fsdev_dir_t),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fsdev_dir_t>())).fd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fsdev_dir_t),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fsdev_dir_t>())).index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fsdev_dir_t),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fsdev_dir_t>())).size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fsdev_dir_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fsdev_dir_t>())).entry_data as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fsdev_dir_t),
            "::",
            stringify!(entry_data)
        )
    );
}
extern "C" {
    /// Initializes and mounts the sdmc device if accessible. Also initializes current working directory to point to the folder containing the path to the executable (argv[0]), if it is provided by the environment.
    pub fn fsdevMountSdmc() -> Result;
}
extern "C" {
    /// Mounts the input fs with the specified device name. fsdev will handle closing the fs when required, including when fsdevMountDevice() fails.
    /// Returns -1 when any errors occur.
    pub fn fsdevMountDevice(name: *const ctypes::c_char, fs: FsFileSystem) -> ctypes::c_int;
}
extern "C" {
    /// Unmounts the specified device.
    pub fn fsdevUnmountDevice(name: *const ctypes::c_char) -> ctypes::c_int;
}
extern "C" {
    /// Uses fsFsCommit() with the specified device. This must be used after any savedata-write operations(not just file-write). This should be used after each file-close where file-writing was done.
    /// This is not used automatically at device unmount.
    pub fn fsdevCommitDevice(name: *const ctypes::c_char) -> Result;
}
extern "C" {
    /// Returns the FsFileSystem for the specified device. Returns NULL when the specified device isn't found.
    pub fn fsdevGetDeviceFileSystem(name: *const ctypes::c_char) -> *mut FsFileSystem;
}
extern "C" {
    /// Returns the FsFileSystem for the default device (SD card), if mounted. Used internally by romfs_dev.
    pub fn fsdevGetDefaultFileSystem() -> *mut FsFileSystem;
}
extern "C" {
    /// Writes the FS-path to outpath (which has buffer size FS_MAX_PATH), for the input device path. The FsFileSystem is also written to device when not NULL.
    pub fn fsdevTranslatePath(
        path: *const ctypes::c_char,
        device: *mut *mut FsFileSystem,
        outpath: *mut ctypes::c_char,
    ) -> ctypes::c_int;
}
extern "C" {
    /// This calls fsFsSetArchiveBit on the filesystem specified by the input absolute path.
    pub fn fsdevSetArchiveBit(path: *const ctypes::c_char) -> Result;
}
extern "C" {
    /// Unmounts all devices and cleans up any resources used by the FS driver.
    pub fn fsdevUnmountAll() -> Result;
}
/// RomFS header.
#[repr(C)]
pub struct romfs_header {
    /// < Size of the header.
    pub headerSize: u64,
    /// < Offset of the directory hash table.
    pub dirHashTableOff: u64,
    /// < Size of the directory hash table.
    pub dirHashTableSize: u64,
    /// < Offset of the directory table.
    pub dirTableOff: u64,
    /// < Size of the directory table.
    pub dirTableSize: u64,
    /// < Offset of the file hash table.
    pub fileHashTableOff: u64,
    /// < Size of the file hash table.
    pub fileHashTableSize: u64,
    /// < Offset of the file table.
    pub fileTableOff: u64,
    /// < Size of the file table.
    pub fileTableSize: u64,
    /// < Offset of the file data.
    pub fileDataOff: u64,
}
#[test]
fn bindgen_test_layout_romfs_header() {
    assert_eq!(
        ::core::mem::size_of::<romfs_header>(),
        80usize,
        concat!("Size of: ", stringify!(romfs_header))
    );
    assert_eq!(
        ::core::mem::align_of::<romfs_header>(),
        8usize,
        concat!("Alignment of ", stringify!(romfs_header))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<romfs_header>())).headerSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(romfs_header),
            "::",
            stringify!(headerSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<romfs_header>())).dirHashTableOff as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(romfs_header),
            "::",
            stringify!(dirHashTableOff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<romfs_header>())).dirHashTableSize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(romfs_header),
            "::",
            stringify!(dirHashTableSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<romfs_header>())).dirTableOff as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(romfs_header),
            "::",
            stringify!(dirTableOff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<romfs_header>())).dirTableSize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(romfs_header),
            "::",
            stringify!(dirTableSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<romfs_header>())).fileHashTableOff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(romfs_header),
            "::",
            stringify!(fileHashTableOff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<romfs_header>())).fileHashTableSize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(romfs_header),
            "::",
            stringify!(fileHashTableSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<romfs_header>())).fileTableOff as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(romfs_header),
            "::",
            stringify!(fileTableOff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<romfs_header>())).fileTableSize as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(romfs_header),
            "::",
            stringify!(fileTableSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<romfs_header>())).fileDataOff as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(romfs_header),
            "::",
            stringify!(fileDataOff)
        )
    );
}
/// RomFS directory.
#[repr(C)]
pub struct romfs_dir {
    /// < Offset of the parent directory.
    pub parent: u32,
    /// < Offset of the next sibling directory.
    pub sibling: u32,
    /// < Offset of the first child directory.
    pub childDir: u32,
    /// < Offset of the first file.
    pub childFile: u32,
    /// < Directory hash table pointer.
    pub nextHash: u32,
    /// < Name length.
    pub nameLen: u32,
    /// < Name. (UTF-8)
    pub name: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_romfs_dir() {
    assert_eq!(
        ::core::mem::size_of::<romfs_dir>(),
        24usize,
        concat!("Size of: ", stringify!(romfs_dir))
    );
    assert_eq!(
        ::core::mem::align_of::<romfs_dir>(),
        4usize,
        concat!("Alignment of ", stringify!(romfs_dir))
    );
}
/// RomFS file.
#[repr(C)]
pub struct romfs_file {
    /// < Offset of the parent directory.
    pub parent: u32,
    /// < Offset of the next sibling file.
    pub sibling: u32,
    /// < Offset of the file's data.
    pub dataOff: u64,
    /// < Length of the file's data.
    pub dataSize: u64,
    /// < File hash table pointer.
    pub nextHash: u32,
    /// < Name length.
    pub nameLen: u32,
    /// < Name. (UTF-8)
    pub name: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_romfs_file() {
    assert_eq!(
        ::core::mem::size_of::<romfs_file>(),
        32usize,
        concat!("Size of: ", stringify!(romfs_file))
    );
    assert_eq!(
        ::core::mem::align_of::<romfs_file>(),
        8usize,
        concat!("Alignment of ", stringify!(romfs_file))
    );
}
extern "C" {
    /// @brief Mounts the Application's RomFS.
    /// @param name Device mount name.
    pub fn romfsMount(name: *const ctypes::c_char) -> Result;
}
extern "C" {
    /// @brief Mounts RomFS from an open file.
    /// @param file FsFile of the RomFS image.
    /// @param offset Offset of the RomFS within the file.
    /// @param name Device mount name.
    pub fn romfsMountFromFile(file: FsFile, offset: u64, name: *const ctypes::c_char) -> Result;
}
extern "C" {
    /// @brief Mounts RomFS from an open storage.
    /// @param storage FsStorage of the RomFS image.
    /// @param offset Offset of the RomFS within the storage.
    /// @param name Device mount name.
    pub fn romfsMountFromStorage(
        storage: FsStorage,
        offset: u64,
        name: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    /// @brief Mounts RomFS from a file path in a mounted fsdev device.
    /// @param path File path.
    /// @param offset Offset of the RomFS within the file.
    /// @param name Device mount name.
    pub fn romfsMountFromFsdev(
        path: *const ctypes::c_char,
        offset: u64,
        name: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    /// @brief Mounts RomFS from a system data archive.
    /// @param dataId Title ID of system data archive to mount.
    /// @param storageId Storage ID to mount from.
    /// @param name Device mount name.
    pub fn romfsMountFromDataArchive(
        dataId: u64,
        storageId: FsStorageId,
        name: *const ctypes::c_char,
    ) -> Result;
}
extern "C" {
    /// Unmounts the RomFS device.
    pub fn romfsUnmount(name: *const ctypes::c_char) -> Result;
}
/// Configuration structure for socketInitalize
#[repr(C)]
pub struct SocketInitConfig {
    /// < Observed 1 on 2.0 LibAppletWeb, 2 on 3.0.
    pub bsdsockets_version: u32,
    /// < Size of the TCP transfer (send) buffer (initial or fixed).
    pub tcp_tx_buf_size: u32,
    /// < Size of the TCP recieve buffer (initial or fixed).
    pub tcp_rx_buf_size: u32,
    /// < Maximum size of the TCP transfer (send) buffer. If it is 0, the size of the buffer is fixed to its initial value.
    pub tcp_tx_buf_max_size: u32,
    /// < Maximum size of the TCP receive buffer. If it is 0, the size of the buffer is fixed to its initial value.
    pub tcp_rx_buf_max_size: u32,
    /// < Size of the UDP transfer (send) buffer (typically 0x2400 bytes).
    pub udp_tx_buf_size: u32,
    /// < Size of the UDP receive buffer (typically 0xA500 bytes).
    pub udp_rx_buf_size: u32,
    /// < Number of buffers for each socket (standard values range from 1 to 8).
    pub sb_efficiency: u32,
    /// < For getaddrinfo.
    pub serialized_out_addrinfos_max_size: usize,
    /// < For gethostbyname/gethostbyaddr.
    pub serialized_out_hostent_max_size: usize,
    /// < For name gethostbyname/getaddrinfo: bypass the Name Server Daemon.
    pub bypass_nsd: bool,
    /// < For DNS requests: timeout or 0.
    pub dns_timeout: ctypes::c_int,
}
#[test]
fn bindgen_test_layout_SocketInitConfig() {
    assert_eq!(
        ::core::mem::size_of::<SocketInitConfig>(),
        56usize,
        concat!("Size of: ", stringify!(SocketInitConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<SocketInitConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(SocketInitConfig))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SocketInitConfig>())).bsdsockets_version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketInitConfig),
            "::",
            stringify!(bsdsockets_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SocketInitConfig>())).tcp_tx_buf_size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketInitConfig),
            "::",
            stringify!(tcp_tx_buf_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SocketInitConfig>())).tcp_rx_buf_size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketInitConfig),
            "::",
            stringify!(tcp_rx_buf_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SocketInitConfig>())).tcp_tx_buf_max_size as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketInitConfig),
            "::",
            stringify!(tcp_tx_buf_max_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SocketInitConfig>())).tcp_rx_buf_max_size as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketInitConfig),
            "::",
            stringify!(tcp_rx_buf_max_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SocketInitConfig>())).udp_tx_buf_size as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketInitConfig),
            "::",
            stringify!(udp_tx_buf_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SocketInitConfig>())).udp_rx_buf_size as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketInitConfig),
            "::",
            stringify!(udp_rx_buf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SocketInitConfig>())).sb_efficiency as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketInitConfig),
            "::",
            stringify!(sb_efficiency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SocketInitConfig>())).serialized_out_addrinfos_max_size
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketInitConfig),
            "::",
            stringify!(serialized_out_addrinfos_max_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SocketInitConfig>())).serialized_out_hostent_max_size
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketInitConfig),
            "::",
            stringify!(serialized_out_hostent_max_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SocketInitConfig>())).bypass_nsd as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketInitConfig),
            "::",
            stringify!(bypass_nsd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SocketInitConfig>())).dns_timeout as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketInitConfig),
            "::",
            stringify!(dns_timeout)
        )
    );
}
extern "C" {
    /// Fetch the default configuration for the socket driver.
    pub fn socketGetDefaultInitConfig() -> *const SocketInitConfig;
}
extern "C" {
    /// Initalize the socket driver.
    pub fn socketInitialize(config: *const SocketInitConfig) -> Result;
}
extern "C" {
    /// Fetch the last bsd:u/s Switch result code (thread-local).
    pub fn socketGetLastBsdResult() -> Result;
}
extern "C" {
    /// Fetch the last sfdnsres Switch result code (thread-local).
    pub fn socketGetLastSfdnsresResult() -> Result;
}
extern "C" {
    /// Deinitialize the socket driver.
    pub fn socketExit();
}
/// Context for AES-128 operations.
#[repr(C)]
pub struct Aes128Context {
    pub round_keys: [[u8; 16usize]; 11usize],
}
#[test]
fn bindgen_test_layout_Aes128Context() {
    assert_eq!(
        ::core::mem::size_of::<Aes128Context>(),
        176usize,
        concat!("Size of: ", stringify!(Aes128Context))
    );
    assert_eq!(
        ::core::mem::align_of::<Aes128Context>(),
        1usize,
        concat!("Alignment of ", stringify!(Aes128Context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes128Context>())).round_keys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes128Context),
            "::",
            stringify!(round_keys)
        )
    );
}
/// Context for AES-192 operations.
#[repr(C)]
pub struct Aes192Context {
    pub round_keys: [[u8; 16usize]; 13usize],
}
#[test]
fn bindgen_test_layout_Aes192Context() {
    assert_eq!(
        ::core::mem::size_of::<Aes192Context>(),
        208usize,
        concat!("Size of: ", stringify!(Aes192Context))
    );
    assert_eq!(
        ::core::mem::align_of::<Aes192Context>(),
        1usize,
        concat!("Alignment of ", stringify!(Aes192Context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes192Context>())).round_keys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes192Context),
            "::",
            stringify!(round_keys)
        )
    );
}
/// Context for AES-256 operations.
#[repr(C)]
pub struct Aes256Context {
    pub round_keys: [[u8; 16usize]; 15usize],
}
#[test]
fn bindgen_test_layout_Aes256Context() {
    assert_eq!(
        ::core::mem::size_of::<Aes256Context>(),
        240usize,
        concat!("Size of: ", stringify!(Aes256Context))
    );
    assert_eq!(
        ::core::mem::align_of::<Aes256Context>(),
        1usize,
        concat!("Alignment of ", stringify!(Aes256Context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes256Context>())).round_keys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes256Context),
            "::",
            stringify!(round_keys)
        )
    );
}
extern "C" {
    /// Initialize a 128-bit AES context.
    pub fn aes128ContextCreate(
        out: *mut Aes128Context,
        key: *const ctypes::c_void,
        is_encryptor: bool,
    );
}
extern "C" {
    /// Encrypt using an AES context (Requires is_encryptor when initializing)
    pub fn aes128EncryptBlock(
        ctx: *const Aes128Context,
        dst: *mut ctypes::c_void,
        src: *const ctypes::c_void,
    );
}
extern "C" {
    /// Decrypt using an AES context (Requires !is_encryptor when initializing)
    pub fn aes128DecryptBlock(
        ctx: *const Aes128Context,
        dst: *mut ctypes::c_void,
        src: *const ctypes::c_void,
    );
}
extern "C" {
    /// Initialize a 192-bit AES context.
    pub fn aes192ContextCreate(
        out: *mut Aes192Context,
        key: *const ctypes::c_void,
        is_encryptor: bool,
    );
}
extern "C" {
    /// Encrypt using an AES context (Requires is_encryptor when initializing)
    pub fn aes192EncryptBlock(
        ctx: *const Aes192Context,
        dst: *mut ctypes::c_void,
        src: *const ctypes::c_void,
    );
}
extern "C" {
    /// Decrypt using an AES context (Requires !is_encryptor when initializing)
    pub fn aes192DecryptBlock(
        ctx: *const Aes192Context,
        dst: *mut ctypes::c_void,
        src: *const ctypes::c_void,
    );
}
extern "C" {
    /// Initialize a 256-bit AES context.
    pub fn aes256ContextCreate(
        out: *mut Aes256Context,
        key: *const ctypes::c_void,
        is_encryptor: bool,
    );
}
extern "C" {
    /// Encrypt using an AES context (Requires is_encryptor when initializing)
    pub fn aes256EncryptBlock(
        ctx: *const Aes256Context,
        dst: *mut ctypes::c_void,
        src: *const ctypes::c_void,
    );
}
extern "C" {
    /// Decrypt using an AES context (Requires !is_encryptor when initializing)
    pub fn aes256DecryptBlock(
        ctx: *const Aes256Context,
        dst: *mut ctypes::c_void,
        src: *const ctypes::c_void,
    );
}
/// Context for AES-128 CBC.
#[repr(C)]
pub struct Aes128CbcContext {
    pub aes_ctx: Aes128Context,
    pub iv: [u8; 16usize],
    pub buffer: [u8; 16usize],
    pub num_buffered: usize,
}
#[test]
fn bindgen_test_layout_Aes128CbcContext() {
    assert_eq!(
        ::core::mem::size_of::<Aes128CbcContext>(),
        216usize,
        concat!("Size of: ", stringify!(Aes128CbcContext))
    );
    assert_eq!(
        ::core::mem::align_of::<Aes128CbcContext>(),
        8usize,
        concat!("Alignment of ", stringify!(Aes128CbcContext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes128CbcContext>())).aes_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes128CbcContext),
            "::",
            stringify!(aes_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes128CbcContext>())).iv as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes128CbcContext),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes128CbcContext>())).buffer as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes128CbcContext),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes128CbcContext>())).num_buffered as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes128CbcContext),
            "::",
            stringify!(num_buffered)
        )
    );
}
/// Context for AES-192 CBC.
#[repr(C)]
pub struct Aes192CbcContext {
    pub aes_ctx: Aes192Context,
    pub iv: [u8; 16usize],
    pub buffer: [u8; 16usize],
    pub num_buffered: usize,
}
#[test]
fn bindgen_test_layout_Aes192CbcContext() {
    assert_eq!(
        ::core::mem::size_of::<Aes192CbcContext>(),
        248usize,
        concat!("Size of: ", stringify!(Aes192CbcContext))
    );
    assert_eq!(
        ::core::mem::align_of::<Aes192CbcContext>(),
        8usize,
        concat!("Alignment of ", stringify!(Aes192CbcContext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes192CbcContext>())).aes_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes192CbcContext),
            "::",
            stringify!(aes_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes192CbcContext>())).iv as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes192CbcContext),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes192CbcContext>())).buffer as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes192CbcContext),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes192CbcContext>())).num_buffered as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes192CbcContext),
            "::",
            stringify!(num_buffered)
        )
    );
}
/// Context for AES-256 CBC.
#[repr(C)]
pub struct Aes256CbcContext {
    pub aes_ctx: Aes256Context,
    pub iv: [u8; 16usize],
    pub buffer: [u8; 16usize],
    pub num_buffered: usize,
}
#[test]
fn bindgen_test_layout_Aes256CbcContext() {
    assert_eq!(
        ::core::mem::size_of::<Aes256CbcContext>(),
        280usize,
        concat!("Size of: ", stringify!(Aes256CbcContext))
    );
    assert_eq!(
        ::core::mem::align_of::<Aes256CbcContext>(),
        8usize,
        concat!("Alignment of ", stringify!(Aes256CbcContext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes256CbcContext>())).aes_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes256CbcContext),
            "::",
            stringify!(aes_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes256CbcContext>())).iv as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes256CbcContext),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes256CbcContext>())).buffer as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes256CbcContext),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes256CbcContext>())).num_buffered as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes256CbcContext),
            "::",
            stringify!(num_buffered)
        )
    );
}
extern "C" {
    /// 128-bit CBC API.
    pub fn aes128CbcContextCreate(
        out: *mut Aes128CbcContext,
        key: *const ctypes::c_void,
        iv: *const ctypes::c_void,
        is_encryptor: bool,
    );
}
extern "C" {
    pub fn aes128CbcContextResetIv(ctx: *mut Aes128CbcContext, iv: *const ctypes::c_void);
}
extern "C" {
    pub fn aes128CbcEncrypt(
        ctx: *mut Aes128CbcContext,
        dst: *mut ctypes::c_void,
        src: *const ctypes::c_void,
        size: usize,
    ) -> usize;
}
extern "C" {
    pub fn aes128CbcDecrypt(
        ctx: *mut Aes128CbcContext,
        dst: *mut ctypes::c_void,
        src: *const ctypes::c_void,
        size: usize,
    ) -> usize;
}
extern "C" {
    /// 192-bit CBC API.
    pub fn aes192CbcContextCreate(
        out: *mut Aes192CbcContext,
        key: *const ctypes::c_void,
        iv: *const ctypes::c_void,
        is_encryptor: bool,
    );
}
extern "C" {
    pub fn aes192CbcContextResetIv(ctx: *mut Aes192CbcContext, iv: *const ctypes::c_void);
}
extern "C" {
    pub fn aes192CbcEncrypt(
        ctx: *mut Aes192CbcContext,
        dst: *mut ctypes::c_void,
        src: *const ctypes::c_void,
        size: usize,
    ) -> usize;
}
extern "C" {
    pub fn aes192CbcDecrypt(
        ctx: *mut Aes192CbcContext,
        dst: *mut ctypes::c_void,
        src: *const ctypes::c_void,
        size: usize,
    ) -> usize;
}
extern "C" {
    /// 256-bit CBC API.
    pub fn aes256CbcContextCreate(
        out: *mut Aes256CbcContext,
        key: *const ctypes::c_void,
        iv: *const ctypes::c_void,
        is_encryptor: bool,
    );
}
extern "C" {
    pub fn aes256CbcContextResetIv(ctx: *mut Aes256CbcContext, iv: *const ctypes::c_void);
}
extern "C" {
    pub fn aes256CbcEncrypt(
        ctx: *mut Aes256CbcContext,
        dst: *mut ctypes::c_void,
        src: *const ctypes::c_void,
        size: usize,
    ) -> usize;
}
extern "C" {
    pub fn aes256CbcDecrypt(
        ctx: *mut Aes256CbcContext,
        dst: *mut ctypes::c_void,
        src: *const ctypes::c_void,
        size: usize,
    ) -> usize;
}
/// Context for AES-128 CTR.
#[repr(C)]
pub struct Aes128CtrContext {
    pub aes_ctx: Aes128Context,
    pub ctr: [u8; 16usize],
    pub enc_ctr_buffer: [u8; 16usize],
    pub buffer_offset: usize,
}
#[test]
fn bindgen_test_layout_Aes128CtrContext() {
    assert_eq!(
        ::core::mem::size_of::<Aes128CtrContext>(),
        216usize,
        concat!("Size of: ", stringify!(Aes128CtrContext))
    );
    assert_eq!(
        ::core::mem::align_of::<Aes128CtrContext>(),
        8usize,
        concat!("Alignment of ", stringify!(Aes128CtrContext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes128CtrContext>())).aes_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes128CtrContext),
            "::",
            stringify!(aes_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes128CtrContext>())).ctr as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes128CtrContext),
            "::",
            stringify!(ctr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<Aes128CtrContext>())).enc_ctr_buffer as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes128CtrContext),
            "::",
            stringify!(enc_ctr_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes128CtrContext>())).buffer_offset as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes128CtrContext),
            "::",
            stringify!(buffer_offset)
        )
    );
}
/// Context for AES-192 CTR.
#[repr(C)]
pub struct Aes192CtrContext {
    pub aes_ctx: Aes192Context,
    pub ctr: [u8; 16usize],
    pub enc_ctr_buffer: [u8; 16usize],
    pub buffer_offset: usize,
}
#[test]
fn bindgen_test_layout_Aes192CtrContext() {
    assert_eq!(
        ::core::mem::size_of::<Aes192CtrContext>(),
        248usize,
        concat!("Size of: ", stringify!(Aes192CtrContext))
    );
    assert_eq!(
        ::core::mem::align_of::<Aes192CtrContext>(),
        8usize,
        concat!("Alignment of ", stringify!(Aes192CtrContext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes192CtrContext>())).aes_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes192CtrContext),
            "::",
            stringify!(aes_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes192CtrContext>())).ctr as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes192CtrContext),
            "::",
            stringify!(ctr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<Aes192CtrContext>())).enc_ctr_buffer as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes192CtrContext),
            "::",
            stringify!(enc_ctr_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes192CtrContext>())).buffer_offset as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes192CtrContext),
            "::",
            stringify!(buffer_offset)
        )
    );
}
/// Context for AES-256 CTR.
#[repr(C)]
pub struct Aes256CtrContext {
    pub aes_ctx: Aes256Context,
    pub ctr: [u8; 16usize],
    pub enc_ctr_buffer: [u8; 16usize],
    pub buffer_offset: usize,
}
#[test]
fn bindgen_test_layout_Aes256CtrContext() {
    assert_eq!(
        ::core::mem::size_of::<Aes256CtrContext>(),
        280usize,
        concat!("Size of: ", stringify!(Aes256CtrContext))
    );
    assert_eq!(
        ::core::mem::align_of::<Aes256CtrContext>(),
        8usize,
        concat!("Alignment of ", stringify!(Aes256CtrContext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes256CtrContext>())).aes_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes256CtrContext),
            "::",
            stringify!(aes_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes256CtrContext>())).ctr as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes256CtrContext),
            "::",
            stringify!(ctr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<Aes256CtrContext>())).enc_ctr_buffer as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes256CtrContext),
            "::",
            stringify!(enc_ctr_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes256CtrContext>())).buffer_offset as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes256CtrContext),
            "::",
            stringify!(buffer_offset)
        )
    );
}
extern "C" {
    /// 128-bit CTR API.
    pub fn aes128CtrContextCreate(
        out: *mut Aes128CtrContext,
        key: *const ctypes::c_void,
        ctr: *const ctypes::c_void,
    );
}
extern "C" {
    pub fn aes128CtrContextResetCtr(ctx: *mut Aes128CtrContext, ctr: *const ctypes::c_void);
}
extern "C" {
    pub fn aes128CtrCrypt(
        ctx: *mut Aes128CtrContext,
        dst: *mut ctypes::c_void,
        src: *const ctypes::c_void,
        size: usize,
    );
}
extern "C" {
    /// 192-bit CTR API.
    pub fn aes192CtrContextCreate(
        out: *mut Aes192CtrContext,
        key: *const ctypes::c_void,
        ctr: *const ctypes::c_void,
    );
}
extern "C" {
    pub fn aes192CtrContextResetCtr(ctx: *mut Aes192CtrContext, ctr: *const ctypes::c_void);
}
extern "C" {
    pub fn aes192CtrCrypt(
        ctx: *mut Aes192CtrContext,
        dst: *mut ctypes::c_void,
        src: *const ctypes::c_void,
        size: usize,
    );
}
extern "C" {
    /// 256-bit CTR API.
    pub fn aes256CtrContextCreate(
        out: *mut Aes256CtrContext,
        key: *const ctypes::c_void,
        ctr: *const ctypes::c_void,
    );
}
extern "C" {
    pub fn aes256CtrContextResetCtr(ctx: *mut Aes256CtrContext, ctr: *const ctypes::c_void);
}
extern "C" {
    pub fn aes256CtrCrypt(
        ctx: *mut Aes256CtrContext,
        dst: *mut ctypes::c_void,
        src: *const ctypes::c_void,
        size: usize,
    );
}
/// Context for AES-128 XTS.
#[repr(C)]
pub struct Aes128XtsContext {
    pub aes_ctx: Aes128Context,
    pub tweak_ctx: Aes128Context,
    pub tweak: [u8; 16usize],
    pub buffer: [u8; 16usize],
    pub num_buffered: usize,
}
#[test]
fn bindgen_test_layout_Aes128XtsContext() {
    assert_eq!(
        ::core::mem::size_of::<Aes128XtsContext>(),
        392usize,
        concat!("Size of: ", stringify!(Aes128XtsContext))
    );
    assert_eq!(
        ::core::mem::align_of::<Aes128XtsContext>(),
        8usize,
        concat!("Alignment of ", stringify!(Aes128XtsContext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes128XtsContext>())).aes_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes128XtsContext),
            "::",
            stringify!(aes_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes128XtsContext>())).tweak_ctx as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes128XtsContext),
            "::",
            stringify!(tweak_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes128XtsContext>())).tweak as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes128XtsContext),
            "::",
            stringify!(tweak)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes128XtsContext>())).buffer as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes128XtsContext),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes128XtsContext>())).num_buffered as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes128XtsContext),
            "::",
            stringify!(num_buffered)
        )
    );
}
/// Context for AES-192 XTS.
#[repr(C)]
pub struct Aes192XtsContext {
    pub aes_ctx: Aes192Context,
    pub tweak_ctx: Aes192Context,
    pub tweak: [u8; 16usize],
    pub buffer: [u8; 16usize],
    pub num_buffered: usize,
}
#[test]
fn bindgen_test_layout_Aes192XtsContext() {
    assert_eq!(
        ::core::mem::size_of::<Aes192XtsContext>(),
        456usize,
        concat!("Size of: ", stringify!(Aes192XtsContext))
    );
    assert_eq!(
        ::core::mem::align_of::<Aes192XtsContext>(),
        8usize,
        concat!("Alignment of ", stringify!(Aes192XtsContext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes192XtsContext>())).aes_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes192XtsContext),
            "::",
            stringify!(aes_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes192XtsContext>())).tweak_ctx as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes192XtsContext),
            "::",
            stringify!(tweak_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes192XtsContext>())).tweak as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes192XtsContext),
            "::",
            stringify!(tweak)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes192XtsContext>())).buffer as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes192XtsContext),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes192XtsContext>())).num_buffered as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes192XtsContext),
            "::",
            stringify!(num_buffered)
        )
    );
}
/// Context for AES-256 XTS.
#[repr(C)]
pub struct Aes256XtsContext {
    pub aes_ctx: Aes256Context,
    pub tweak_ctx: Aes256Context,
    pub tweak: [u8; 16usize],
    pub buffer: [u8; 16usize],
    pub num_buffered: usize,
}
#[test]
fn bindgen_test_layout_Aes256XtsContext() {
    assert_eq!(
        ::core::mem::size_of::<Aes256XtsContext>(),
        520usize,
        concat!("Size of: ", stringify!(Aes256XtsContext))
    );
    assert_eq!(
        ::core::mem::align_of::<Aes256XtsContext>(),
        8usize,
        concat!("Alignment of ", stringify!(Aes256XtsContext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes256XtsContext>())).aes_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes256XtsContext),
            "::",
            stringify!(aes_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes256XtsContext>())).tweak_ctx as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes256XtsContext),
            "::",
            stringify!(tweak_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes256XtsContext>())).tweak as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes256XtsContext),
            "::",
            stringify!(tweak)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes256XtsContext>())).buffer as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes256XtsContext),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes256XtsContext>())).num_buffered as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes256XtsContext),
            "::",
            stringify!(num_buffered)
        )
    );
}
extern "C" {
    /// 128-bit XTS API.
    pub fn aes128XtsContextCreate(
        out: *mut Aes128XtsContext,
        key0: *const ctypes::c_void,
        key1: *const ctypes::c_void,
        is_encryptor: bool,
    );
}
extern "C" {
    pub fn aes128XtsContextResetTweak(ctx: *mut Aes128XtsContext, tweak: *const ctypes::c_void);
}
extern "C" {
    pub fn aes128XtsContextResetSector(ctx: *mut Aes128XtsContext, sector: u64, is_nintendo: bool);
}
extern "C" {
    pub fn aes128XtsEncrypt(
        ctx: *mut Aes128XtsContext,
        dst: *mut ctypes::c_void,
        src: *const ctypes::c_void,
        size: usize,
    ) -> usize;
}
extern "C" {
    pub fn aes128XtsDecrypt(
        ctx: *mut Aes128XtsContext,
        dst: *mut ctypes::c_void,
        src: *const ctypes::c_void,
        size: usize,
    ) -> usize;
}
extern "C" {
    /// 192-bit XTS API.
    pub fn aes192XtsContextCreate(
        out: *mut Aes192XtsContext,
        key0: *const ctypes::c_void,
        key1: *const ctypes::c_void,
        is_encryptor: bool,
    );
}
extern "C" {
    pub fn aes192XtsContextResetTweak(ctx: *mut Aes192XtsContext, tweak: *const ctypes::c_void);
}
extern "C" {
    pub fn aes192XtsContextResetSector(ctx: *mut Aes192XtsContext, sector: u64, is_nintendo: bool);
}
extern "C" {
    pub fn aes192XtsEncrypt(
        ctx: *mut Aes192XtsContext,
        dst: *mut ctypes::c_void,
        src: *const ctypes::c_void,
        size: usize,
    ) -> usize;
}
extern "C" {
    pub fn aes192XtsDecrypt(
        ctx: *mut Aes192XtsContext,
        dst: *mut ctypes::c_void,
        src: *const ctypes::c_void,
        size: usize,
    ) -> usize;
}
extern "C" {
    /// 256-bit XTS API.
    pub fn aes256XtsContextCreate(
        out: *mut Aes256XtsContext,
        key0: *const ctypes::c_void,
        key1: *const ctypes::c_void,
        is_encryptor: bool,
    );
}
extern "C" {
    pub fn aes256XtsContextResetTweak(ctx: *mut Aes256XtsContext, tweak: *const ctypes::c_void);
}
extern "C" {
    pub fn aes256XtsContextResetSector(ctx: *mut Aes256XtsContext, sector: u64, is_nintendo: bool);
}
extern "C" {
    pub fn aes256XtsEncrypt(
        ctx: *mut Aes256XtsContext,
        dst: *mut ctypes::c_void,
        src: *const ctypes::c_void,
        size: usize,
    ) -> usize;
}
extern "C" {
    pub fn aes256XtsDecrypt(
        ctx: *mut Aes256XtsContext,
        dst: *mut ctypes::c_void,
        src: *const ctypes::c_void,
        size: usize,
    ) -> usize;
}
/// Context for AES-128 CMAC.
#[repr(C)]
pub struct Aes128CmacContext {
    pub ctx: Aes128Context,
    pub subkey: [u8; 16usize],
    pub mac: [u8; 16usize],
    pub buffer: [u8; 16usize],
    pub num_buffered: usize,
    pub finalized: bool,
}
#[test]
fn bindgen_test_layout_Aes128CmacContext() {
    assert_eq!(
        ::core::mem::size_of::<Aes128CmacContext>(),
        240usize,
        concat!("Size of: ", stringify!(Aes128CmacContext))
    );
    assert_eq!(
        ::core::mem::align_of::<Aes128CmacContext>(),
        8usize,
        concat!("Alignment of ", stringify!(Aes128CmacContext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes128CmacContext>())).ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes128CmacContext),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes128CmacContext>())).subkey as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes128CmacContext),
            "::",
            stringify!(subkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes128CmacContext>())).mac as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes128CmacContext),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes128CmacContext>())).buffer as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes128CmacContext),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes128CmacContext>())).num_buffered as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes128CmacContext),
            "::",
            stringify!(num_buffered)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes128CmacContext>())).finalized as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes128CmacContext),
            "::",
            stringify!(finalized)
        )
    );
}
/// Context for AES-192 CMAC.
#[repr(C)]
pub struct Aes192CmacContext {
    pub ctx: Aes192Context,
    pub subkey: [u8; 16usize],
    pub mac: [u8; 16usize],
    pub buffer: [u8; 16usize],
    pub num_buffered: usize,
    pub finalized: bool,
}
#[test]
fn bindgen_test_layout_Aes192CmacContext() {
    assert_eq!(
        ::core::mem::size_of::<Aes192CmacContext>(),
        272usize,
        concat!("Size of: ", stringify!(Aes192CmacContext))
    );
    assert_eq!(
        ::core::mem::align_of::<Aes192CmacContext>(),
        8usize,
        concat!("Alignment of ", stringify!(Aes192CmacContext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes192CmacContext>())).ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes192CmacContext),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes192CmacContext>())).subkey as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes192CmacContext),
            "::",
            stringify!(subkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes192CmacContext>())).mac as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes192CmacContext),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes192CmacContext>())).buffer as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes192CmacContext),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes192CmacContext>())).num_buffered as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes192CmacContext),
            "::",
            stringify!(num_buffered)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes192CmacContext>())).finalized as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes192CmacContext),
            "::",
            stringify!(finalized)
        )
    );
}
/// Context for AES-256 CMAC.
#[repr(C)]
pub struct Aes256CmacContext {
    pub ctx: Aes256Context,
    pub subkey: [u8; 16usize],
    pub mac: [u8; 16usize],
    pub buffer: [u8; 16usize],
    pub num_buffered: usize,
    pub finalized: bool,
}
#[test]
fn bindgen_test_layout_Aes256CmacContext() {
    assert_eq!(
        ::core::mem::size_of::<Aes256CmacContext>(),
        304usize,
        concat!("Size of: ", stringify!(Aes256CmacContext))
    );
    assert_eq!(
        ::core::mem::align_of::<Aes256CmacContext>(),
        8usize,
        concat!("Alignment of ", stringify!(Aes256CmacContext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes256CmacContext>())).ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes256CmacContext),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes256CmacContext>())).subkey as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes256CmacContext),
            "::",
            stringify!(subkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes256CmacContext>())).mac as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes256CmacContext),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes256CmacContext>())).buffer as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes256CmacContext),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes256CmacContext>())).num_buffered as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes256CmacContext),
            "::",
            stringify!(num_buffered)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aes256CmacContext>())).finalized as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes256CmacContext),
            "::",
            stringify!(finalized)
        )
    );
}
extern "C" {
    /// Initialize an AES-128-CMAC context.
    pub fn cmacAes128ContextCreate(out: *mut Aes128CmacContext, key: *const ctypes::c_void);
}
extern "C" {
    /// Updates AES-128-CMAC context with data to hash
    pub fn cmacAes128ContextUpdate(
        ctx: *mut Aes128CmacContext,
        src: *const ctypes::c_void,
        size: usize,
    );
}
extern "C" {
    /// Gets the context's output mac, finalizes the context.
    pub fn cmacAes128ContextGetMac(ctx: *mut Aes128CmacContext, dst: *mut ctypes::c_void);
}
extern "C" {
    /// Simple all-in-one AES-128-CMAC calculator.
    pub fn cmacAes128CalculateMac(
        dst: *mut ctypes::c_void,
        key: *const ctypes::c_void,
        src: *const ctypes::c_void,
        size: usize,
    );
}
extern "C" {
    /// Initialize an AES-192-CMAC context.
    pub fn cmacAes192ContextCreate(out: *mut Aes192CmacContext, key: *const ctypes::c_void);
}
extern "C" {
    /// Updates AES-192-CMAC context with data to hash
    pub fn cmacAes192ContextUpdate(
        ctx: *mut Aes192CmacContext,
        src: *const ctypes::c_void,
        size: usize,
    );
}
extern "C" {
    /// Gets the context's output mac, finalizes the context.
    pub fn cmacAes192ContextGetMac(ctx: *mut Aes192CmacContext, dst: *mut ctypes::c_void);
}
extern "C" {
    /// Simple all-in-one AES-192-CMAC calculator.
    pub fn cmacAes192CalculateMac(
        dst: *mut ctypes::c_void,
        key: *const ctypes::c_void,
        src: *const ctypes::c_void,
        size: usize,
    );
}
extern "C" {
    /// Initialize an AES-256-CMAC context.
    pub fn cmacAes256ContextCreate(out: *mut Aes256CmacContext, key: *const ctypes::c_void);
}
extern "C" {
    /// Updates AES-256-CMAC context with data to hash
    pub fn cmacAes256ContextUpdate(
        ctx: *mut Aes256CmacContext,
        src: *const ctypes::c_void,
        size: usize,
    );
}
extern "C" {
    /// Gets the context's output mac, finalizes the context.
    pub fn cmacAes256ContextGetMac(ctx: *mut Aes256CmacContext, dst: *mut ctypes::c_void);
}
extern "C" {
    /// Simple all-in-one AES-256-CMAC calculator.
    pub fn cmacAes256CalculateMac(
        dst: *mut ctypes::c_void,
        key: *const ctypes::c_void,
        src: *const ctypes::c_void,
        size: usize,
    );
}
/// Context for SHA256 operations.
#[repr(C)]
pub struct Sha256Context {
    pub intermediate_hash: [u32; 8usize],
    pub buffer: [u8; 64usize],
    pub bits_consumed: u64,
    pub num_buffered: usize,
    pub finalized: bool,
}
#[test]
fn bindgen_test_layout_Sha256Context() {
    assert_eq!(
        ::core::mem::size_of::<Sha256Context>(),
        120usize,
        concat!("Size of: ", stringify!(Sha256Context))
    );
    assert_eq!(
        ::core::mem::align_of::<Sha256Context>(),
        8usize,
        concat!("Alignment of ", stringify!(Sha256Context))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<Sha256Context>())).intermediate_hash as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sha256Context),
            "::",
            stringify!(intermediate_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sha256Context>())).buffer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Sha256Context),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sha256Context>())).bits_consumed as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Sha256Context),
            "::",
            stringify!(bits_consumed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sha256Context>())).num_buffered as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Sha256Context),
            "::",
            stringify!(num_buffered)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sha256Context>())).finalized as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Sha256Context),
            "::",
            stringify!(finalized)
        )
    );
}
extern "C" {
    /// Initialize a SHA256 context.
    pub fn sha256ContextCreate(out: *mut Sha256Context);
}
extern "C" {
    /// Updates SHA256 context with data to hash
    pub fn sha256ContextUpdate(ctx: *mut Sha256Context, src: *const ctypes::c_void, size: usize);
}
extern "C" {
    /// Gets the context's output hash, finalizes the context.
    pub fn sha256ContextGetHash(ctx: *mut Sha256Context, dst: *mut ctypes::c_void);
}
extern "C" {
    /// Simple all-in-one SHA256 calculator.
    pub fn sha256CalculateHash(dst: *mut ctypes::c_void, src: *const ctypes::c_void, size: usize);
}
/// Context for SHA1 operations.
#[repr(C)]
pub struct Sha1Context {
    pub intermediate_hash: [u32; 5usize],
    pub buffer: [u8; 64usize],
    pub bits_consumed: u64,
    pub num_buffered: usize,
    pub finalized: bool,
}
#[test]
fn bindgen_test_layout_Sha1Context() {
    assert_eq!(
        ::core::mem::size_of::<Sha1Context>(),
        112usize,
        concat!("Size of: ", stringify!(Sha1Context))
    );
    assert_eq!(
        ::core::mem::align_of::<Sha1Context>(),
        8usize,
        concat!("Alignment of ", stringify!(Sha1Context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sha1Context>())).intermediate_hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sha1Context),
            "::",
            stringify!(intermediate_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sha1Context>())).buffer as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Sha1Context),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sha1Context>())).bits_consumed as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Sha1Context),
            "::",
            stringify!(bits_consumed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sha1Context>())).num_buffered as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Sha1Context),
            "::",
            stringify!(num_buffered)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sha1Context>())).finalized as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Sha1Context),
            "::",
            stringify!(finalized)
        )
    );
}
extern "C" {
    /// Initialize a SHA1 context.
    pub fn sha1ContextCreate(out: *mut Sha1Context);
}
extern "C" {
    /// Updates SHA1 context with data to hash
    pub fn sha1ContextUpdate(ctx: *mut Sha1Context, src: *const ctypes::c_void, size: usize);
}
extern "C" {
    /// Gets the context's output hash, finalizes the context.
    pub fn sha1ContextGetHash(ctx: *mut Sha1Context, dst: *mut ctypes::c_void);
}
extern "C" {
    /// Simple all-in-one SHA1 calculator.
    pub fn sha1CalculateHash(dst: *mut ctypes::c_void, src: *const ctypes::c_void, size: usize);
}
/// Context for HMAC-SHA1 operations.
#[repr(C)]
pub struct HmacSha1Context {
    pub sha_ctx: Sha1Context,
    pub key: [u32; 16usize],
    pub mac: [u32; 5usize],
    pub finalized: bool,
}
#[test]
fn bindgen_test_layout_HmacSha1Context() {
    assert_eq!(
        ::core::mem::size_of::<HmacSha1Context>(),
        200usize,
        concat!("Size of: ", stringify!(HmacSha1Context))
    );
    assert_eq!(
        ::core::mem::align_of::<HmacSha1Context>(),
        8usize,
        concat!("Alignment of ", stringify!(HmacSha1Context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HmacSha1Context>())).sha_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HmacSha1Context),
            "::",
            stringify!(sha_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HmacSha1Context>())).key as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(HmacSha1Context),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HmacSha1Context>())).mac as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(HmacSha1Context),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HmacSha1Context>())).finalized as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(HmacSha1Context),
            "::",
            stringify!(finalized)
        )
    );
}
/// Context for HMAC-SHA256 operations.
#[repr(C)]
pub struct HmacSha256Context {
    pub sha_ctx: Sha256Context,
    pub key: [u32; 16usize],
    pub mac: [u32; 8usize],
    pub finalized: bool,
}
#[test]
fn bindgen_test_layout_HmacSha256Context() {
    assert_eq!(
        ::core::mem::size_of::<HmacSha256Context>(),
        224usize,
        concat!("Size of: ", stringify!(HmacSha256Context))
    );
    assert_eq!(
        ::core::mem::align_of::<HmacSha256Context>(),
        8usize,
        concat!("Alignment of ", stringify!(HmacSha256Context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HmacSha256Context>())).sha_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HmacSha256Context),
            "::",
            stringify!(sha_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HmacSha256Context>())).key as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(HmacSha256Context),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HmacSha256Context>())).mac as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(HmacSha256Context),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HmacSha256Context>())).finalized as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(HmacSha256Context),
            "::",
            stringify!(finalized)
        )
    );
}
extern "C" {
    /// Initialize a HMAC-SHA256 context.
    pub fn hmacSha256ContextCreate(
        out: *mut HmacSha256Context,
        key: *const ctypes::c_void,
        key_size: usize,
    );
}
extern "C" {
    /// Updates HMAC-SHA256 context with data to hash
    pub fn hmacSha256ContextUpdate(
        ctx: *mut HmacSha256Context,
        src: *const ctypes::c_void,
        size: usize,
    );
}
extern "C" {
    /// Gets the context's output mac, finalizes the context.
    pub fn hmacSha256ContextGetMac(ctx: *mut HmacSha256Context, dst: *mut ctypes::c_void);
}
extern "C" {
    /// Simple all-in-one HMAC-SHA256 calculator.
    pub fn hmacSha256CalculateMac(
        dst: *mut ctypes::c_void,
        key: *const ctypes::c_void,
        key_size: usize,
        src: *const ctypes::c_void,
        size: usize,
    );
}
extern "C" {
    /// Initialize a HMAC-SHA1 context.
    pub fn hmacSha1ContextCreate(
        out: *mut HmacSha1Context,
        key: *const ctypes::c_void,
        key_size: usize,
    );
}
extern "C" {
    /// Updates HMAC-SHA1 context with data to hash
    pub fn hmacSha1ContextUpdate(
        ctx: *mut HmacSha1Context,
        src: *const ctypes::c_void,
        size: usize,
    );
}
extern "C" {
    /// Gets the context's output mac, finalizes the context.
    pub fn hmacSha1ContextGetMac(ctx: *mut HmacSha1Context, dst: *mut ctypes::c_void);
}
extern "C" {
    /// Simple all-in-one HMAC-SHA1 calculator.
    pub fn hmacSha1CalculateMac(
        dst: *mut ctypes::c_void,
        key: *const ctypes::c_void,
        key_size: usize,
        src: *const ctypes::c_void,
        size: usize,
    );
}
pub type __uint128_t = [u64; 2];
pub type __int128_t = [u64; 2];
pub type __builtin_va_list = *mut ctypes::c_char;
